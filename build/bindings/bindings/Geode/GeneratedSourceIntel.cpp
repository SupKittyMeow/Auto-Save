
#include <stdexcept>
#include <Geode/Bindings.hpp>
#include <Geode/utils/addresser.hpp>
#include <Geode/modify/Traits.hpp>
#include <Geode/loader/Tulip.hpp>

using namespace geode;
using namespace geode::modifier;
using cocos2d::CCDestructor;

std::unordered_map<void*, bool>& CCDestructor::destructorLock() {{
	static auto ret = new std::unordered_map<void*, bool>;
	return *ret;
}}
bool& CCDestructor::globalLock() {{
	static thread_local bool ret = false;
	return ret; 
}}
bool& CCDestructor::lock(void* self) {
	return destructorLock()[self];
}
CCDestructor::~CCDestructor() {{
	destructorLock().erase(this);
}}

auto wrapFunction(uintptr_t address, tulip::hook::WrapperMetadata const& metadata) {
	auto wrapped = geode::hook::createWrapper(reinterpret_cast<void*>(address), metadata);
	if (wrapped.isErr()) {{
		throw std::runtime_error(wrapped.unwrapErr());
	}}
	return wrapped.unwrap();
}

// So apparently Clang considers cdecl to return floats through ST0, whereas 
// MSVC thinks they are returned through XMM0. This has caused a lot of pain 
// and misery for me


auto cocos2d::CCEGLViewProtocol::getViewPortRect() const  -> decltype(getViewPortRect()) {
	using FunctionType = decltype(getViewPortRect())(*)(cocos2d::CCEGLViewProtocol const *);
	static auto func = wrapFunction(base::get() + 0x518860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCEGLViewProtocol::getFrameSize() const  -> decltype(getFrameSize()) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::getFrameSize not implemented");
}

auto cocos2d::CCEGLViewProtocol::setFrameSize(float p0, float p1) -> decltype(setFrameSize(p0, p1)) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::setFrameSize not implemented");
}

auto cocos2d::CCEGLViewProtocol::getVisibleSize() const  -> decltype(getVisibleSize()) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::getVisibleSize not implemented");
}

auto cocos2d::CCEGLViewProtocol::getVisibleOrigin() const  -> decltype(getVisibleOrigin()) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::getVisibleOrigin not implemented");
}

auto cocos2d::CCEGLViewProtocol::setDesignResolutionSize(float p0, float p1, ResolutionPolicy p2) -> decltype(setDesignResolutionSize(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::setDesignResolutionSize not implemented");
}

auto cocos2d::CCEGLViewProtocol::getDesignResolutionSize() const  -> decltype(getDesignResolutionSize()) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::getDesignResolutionSize not implemented");
}

auto cocos2d::CCEGLViewProtocol::setTouchDelegate(cocos2d::EGLTouchDelegate* p0) -> decltype(setTouchDelegate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::EGLTouchDelegate*>::func(&cocos2d::CCEGLViewProtocol::setTouchDelegate), this);
	using FunctionType = decltype(setTouchDelegate(p0))(*)(cocos2d::CCEGLViewProtocol*, cocos2d::EGLTouchDelegate*);
	static auto func = wrapFunction(base::get() + 0x518010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCEGLViewProtocol::setViewPortInPoints(float p0, float p1, float p2, float p3) -> decltype(setViewPortInPoints(p0, p1, p2, p3)) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::setViewPortInPoints not implemented");
}

auto cocos2d::CCEGLViewProtocol::setScissorInPoints(float p0, float p1, float p2, float p3) -> decltype(setScissorInPoints(p0, p1, p2, p3)) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::setScissorInPoints not implemented");
}

auto cocos2d::CCEGLViewProtocol::isScissorEnabled() -> decltype(isScissorEnabled()) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::isScissorEnabled not implemented");
}

auto cocos2d::CCEGLViewProtocol::getScissorRect() -> decltype(getScissorRect()) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::getScissorRect not implemented");
}

auto cocos2d::CCEGLViewProtocol::setViewName(char const* p0) -> decltype(setViewName(p0)) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::setViewName not implemented");
}

auto cocos2d::CCEGLViewProtocol::pollInputEvents() -> decltype(pollInputEvents()) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::pollInputEvents not implemented");
}

auto cocos2d::CCEaseInOut::create(cocos2d::CCActionInterval* p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCActionInterval*, float);
	static auto func = wrapFunction(base::get() + 0x51d020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCEaseInOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseInOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseInOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseInOut::update not implemented");
}

auto cocos2d::CCEaseInOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseInOut::reverse not implemented");
}

auto cocos2d::CCEaseBackOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseBackOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseBackOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseBackOut::update not implemented");
}

auto cocos2d::CCEaseBackOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseBackOut::reverse not implemented");
}

auto cocos2d::CCEaseBounceOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseBounceOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseBounceOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseBounceOut::update not implemented");
}

auto cocos2d::CCEaseBounceOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseBounceOut::reverse not implemented");
}

auto cocos2d::CCEaseElasticOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseElasticOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseElasticOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseElasticOut::update not implemented");
}

auto cocos2d::CCEaseElasticOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseElasticOut::reverse not implemented");
}

auto cocos2d::CCEaseExponentialOut::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x51d480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCEaseExponentialOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseExponentialOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseExponentialOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseExponentialOut::update not implemented");
}

auto cocos2d::CCEaseExponentialOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseExponentialOut::reverse not implemented");
}

auto cocos2d::CCEaseSineIn::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x51d8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCEaseSineIn::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseSineIn::copyWithZone not implemented");
}

auto cocos2d::CCEaseSineIn::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseSineIn::update not implemented");
}

auto cocos2d::CCEaseSineIn::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseSineIn::reverse not implemented");
}

auto cocos2d::CCEaseSineOut::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x51da90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCEaseSineOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseSineOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseSineOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseSineOut::update not implemented");
}

auto cocos2d::CCEaseSineOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseSineOut::reverse not implemented");
}

auto cocos2d::CCEaseSineInOut::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x51dc70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCEaseSineInOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseSineInOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseSineInOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseSineInOut::update not implemented");
}

auto cocos2d::CCEaseSineInOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseSineInOut::reverse not implemented");
}

auto cocos2d::CCMotionStreak::create(float p0, float p1, float p2, cocos2d::_ccColor3B const& p3, cocos2d::CCTexture2D* p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(float, float, float, cocos2d::_ccColor3B const&, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x57d6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto cocos2d::CCMotionStreak::create(float p0, float p1, float p2, cocos2d::_ccColor3B const& p3, char const* p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(float, float, float, cocos2d::_ccColor3B const&, char const*);
	static auto func = wrapFunction(base::get() + 0x57d500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto cocos2d::CCMotionStreak::initWithFade(float p0, float p1, float p2, cocos2d::_ccColor3B const& p3, cocos2d::CCTexture2D* p4) -> decltype(initWithFade(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithFade(p0, p1, p2, p3, p4))(*)(cocos2d::CCMotionStreak*, float, float, float, cocos2d::_ccColor3B const&, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x57d7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCMotionStreak::initWithFade(float p0, float p1, float p2, cocos2d::_ccColor3B const& p3, char const* p4) -> decltype(initWithFade(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithFade(p0, p1, p2, p3, p4))(*)(cocos2d::CCMotionStreak*, float, float, float, cocos2d::_ccColor3B const&, char const*);
	static auto func = wrapFunction(base::get() + 0x57d640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

cocos2d::CCMotionStreak::CCMotionStreak() {
		m_bFastMode = false;
		m_bStartingPositionInitialized = false;
		m_pTexture = nullptr;
		m_fStroke = 0.0f;
		m_fFadeDelta = 0.0f;
		m_fMinSeg = 0.0f;
		m_uMaxPoints = 0;
		m_uNuPoints = 0;
		m_uPreviousNuPoints = 0;
		m_pPointVertexes = nullptr;
		m_pPointState = nullptr;
		m_pColorPointer = nullptr;
		m_pTexCoords = nullptr;

		m_bRepeatMode = false;
		m_fRepeatSpeed = 1.0f;
		m_fRepeatTime = 0.0f;
		m_bDontOpacityFade = false;
		m_tPositionR = cocos2d::CCPointZero;

		m_tBlendFunc.src = GL_SRC_ALPHA;
		m_tBlendFunc.dst = GL_ONE_MINUS_SRC_ALPHA;
	}

auto cocos2d::CCMotionStreak::reset() -> decltype(reset()) {
	using FunctionType = decltype(reset())(*)(cocos2d::CCMotionStreak*);
	static auto func = wrapFunction(base::get() + 0x57e280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCMotionStreak::resumeStroke() -> decltype(resumeStroke()) {
	using FunctionType = decltype(resumeStroke())(*)(cocos2d::CCMotionStreak*);
	static auto func = wrapFunction(base::get() + 0x57dc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCMotionStreak::~CCMotionStreak() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCMotionStreak*);
	static auto func = wrapFunction(base::get() + 0x57d3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCMotionStreak(geode::CutoffConstructor, sizeof(cocos2d::CCMotionStreak));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCMotionStreak::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCMotionStreak::update), this);
	using FunctionType = decltype(update(p0))(*)(cocos2d::CCMotionStreak*, float);
	static auto func = wrapFunction(base::get() + 0x57dc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMotionStreak::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCMotionStreak::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(cocos2d::CCMotionStreak*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x57d9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMotionStreak::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMotionStreak::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCMotionStreak*);
	static auto func = wrapFunction(base::get() + 0x57e2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMotionStreak::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMotionStreak::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::CCMotionStreak*);
	static auto func = wrapFunction(base::get() + 0x57db60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMotionStreak::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCMotionStreak::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCMotionStreak*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x57db40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMotionStreak::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCMotionStreak::setOpacityModifyRGB), this);
	using FunctionType = decltype(setOpacityModifyRGB(p0))(*)(cocos2d::CCMotionStreak*, bool);
	static auto func = wrapFunction(base::get() + 0x57db80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMotionStreak::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMotionStreak::isOpacityModifyRGB), this);
	using FunctionType = decltype(isOpacityModifyRGB())(*)(cocos2d::CCMotionStreak*);
	static auto func = wrapFunction(base::get() + 0x57dba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMotionStreak::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccBlendFunc>::func(&cocos2d::CCMotionStreak::setBlendFunc), this);
	using FunctionType = decltype(setBlendFunc(p0))(*)(cocos2d::CCMotionStreak*, cocos2d::_ccBlendFunc);
	static auto func = wrapFunction(base::get() + 0x57db00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMotionStreak::getBlendFunc() -> decltype(getBlendFunc()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMotionStreak::getBlendFunc), this);
	using FunctionType = decltype(getBlendFunc())(*)(cocos2d::CCMotionStreak*);
	static auto func = wrapFunction(base::get() + 0x57db20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMotionStreak::getTexture() -> decltype(getTexture()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMotionStreak::getTexture), this);
	using FunctionType = decltype(getTexture())(*)(cocos2d::CCMotionStreak*);
	static auto func = wrapFunction(base::get() + 0x57da50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMotionStreak::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&cocos2d::CCMotionStreak::setTexture), this);
	using FunctionType = decltype(setTexture(p0))(*)(cocos2d::CCMotionStreak*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x57da70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMoveBy::create(float p0, cocos2d::CCPoint const& p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3bb420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCMoveBy::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCMoveBy::copyWithZone not implemented");
}

auto cocos2d::CCMoveBy::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCMoveBy::update not implemented");
}

auto cocos2d::CCMoveBy::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCMoveBy::startWithTarget not implemented");
}

auto cocos2d::CCMoveBy::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCMoveBy::reverse not implemented");
}

auto cocos2d::CCMoveTo::create(float p0, cocos2d::CCPoint const& p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3bb800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCMoveTo::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCMoveTo::copyWithZone not implemented");
}

auto cocos2d::CCMoveTo::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCMoveTo::startWithTarget not implemented");
}

auto cocos2d::CCScaleBy::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x3bd6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCScaleBy::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCScaleBy::copyWithZone not implemented");
}

auto cocos2d::CCScaleBy::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCScaleBy::startWithTarget not implemented");
}

auto cocos2d::CCScaleBy::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCScaleBy::reverse not implemented");
}

auto cocos2d::CCScaleTo::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x3bd2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCScaleTo::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCScaleTo::copyWithZone not implemented");
}

auto cocos2d::CCScaleTo::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCScaleTo::update not implemented");
}

auto cocos2d::CCScaleTo::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCScaleTo::startWithTarget not implemented");
}

auto cocos2d::CCTintTo::create(float p0, unsigned char p1, unsigned char p2, unsigned char p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(float, unsigned char, unsigned char, unsigned char);
	static auto func = wrapFunction(base::get() + 0x3be5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto cocos2d::CCTintTo::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCTintTo::copyWithZone not implemented");
}

auto cocos2d::CCTintTo::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCTintTo::update not implemented");
}

auto cocos2d::CCTintTo::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCTintTo::startWithTarget not implemented");
}

auto cocos2d::CCScene::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x28cbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCScene::getHighestChildZ() -> decltype(getHighestChildZ()) {
	using FunctionType = decltype(getHighestChildZ())(*)(cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x28cca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCScene::~CCScene() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x28cb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCScene(geode::CutoffConstructor, sizeof(cocos2d::CCScene));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCScene::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCScene::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x28cba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSet::anyObject() -> decltype(anyObject()) {
	using FunctionType = decltype(anyObject())(*)(cocos2d::CCSet*);
	static auto func = wrapFunction(base::get() + 0x7bfee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSet::count() -> decltype(count()) {
	using FunctionType = decltype(count())(*)(cocos2d::CCSet*);
	static auto func = wrapFunction(base::get() + 0x7bfd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSet::acceptVisitor(cocos2d::CCDataVisitor& p0) -> decltype(acceptVisitor(p0)) {
	throw std::runtime_error("cocos2d::CCSet::acceptVisitor not implemented");
}

auto cocos2d::CCShaderCache::sharedShaderCache() -> decltype(sharedShaderCache()) {
	using FunctionType = decltype(sharedShaderCache())(*)();
	static auto func = wrapFunction(base::get() + 0x1fc770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCShaderCache::programForKey(char const* p0) -> decltype(programForKey(p0)) {
	using FunctionType = decltype(programForKey(p0))(*)(cocos2d::CCShaderCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x1fd650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCParticleSystem::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x7d3960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCParticleSystem::initParticle(cocos2d::sCCParticle* p0) -> decltype(initParticle(p0)) {
	using FunctionType = decltype(initParticle(p0))(*)(cocos2d::CCParticleSystem*, cocos2d::sCCParticle*);
	static auto func = wrapFunction(base::get() + 0x7d5a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCParticleSystem::initWithDictionary(cocos2d::CCDictionary* p0, char const* p1, bool p2) -> decltype(initWithDictionary(p0, p1, p2)) {
	using FunctionType = decltype(initWithDictionary(p0, p1, p2))(*)(cocos2d::CCParticleSystem*, cocos2d::CCDictionary*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x7d3ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCParticleSystem::initWithDictionary(cocos2d::CCDictionary* p0, bool p1) -> decltype(initWithDictionary(p0, p1)) {
	using FunctionType = decltype(initWithDictionary(p0, p1))(*)(cocos2d::CCParticleSystem*, cocos2d::CCDictionary*, bool);
	static auto func = wrapFunction(base::get() + 0x7d55d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCParticleSystem::initWithFile(char const* p0, bool p1) -> decltype(initWithFile(p0, p1)) {
	using FunctionType = decltype(initWithFile(p0, p1))(*)(cocos2d::CCParticleSystem*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x7d39c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

cocos2d::CCParticleSystem::~CCParticleSystem() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCParticleSystem*);
	static auto func = wrapFunction(base::get() + 0x7d5860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCParticleSystem(geode::CutoffConstructor, sizeof(cocos2d::CCParticleSystem));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCParticleSystem::resetSystem() -> decltype(resetSystem()) {
	using FunctionType = decltype(resetSystem())(*)(cocos2d::CCParticleSystem*);
	static auto func = wrapFunction(base::get() + 0x7d6b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCParticleSystem::resumeSystem() -> decltype(resumeSystem()) {
	using FunctionType = decltype(resumeSystem())(*)(cocos2d::CCParticleSystem*);
	static auto func = wrapFunction(base::get() + 0x7d6b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCParticleSystem::stopSystem() -> decltype(stopSystem()) {
	using FunctionType = decltype(stopSystem())(*)(cocos2d::CCParticleSystem*);
	static auto func = wrapFunction(base::get() + 0x7d6ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCParticleSystem::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCParticleSystem::update), this);
	using FunctionType = decltype(update(p0))(*)(cocos2d::CCParticleSystem*, float);
	static auto func = wrapFunction(base::get() + 0x7d6cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCParticleSystem::init() -> decltype(init()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::init not implemented");
}

auto cocos2d::CCParticleSystem::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setScaleX not implemented");
}

auto cocos2d::CCParticleSystem::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setScaleY not implemented");
}

auto cocos2d::CCParticleSystem::setScale(float p0) -> decltype(setScale(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setScale not implemented");
}

auto cocos2d::CCParticleSystem::setVisible(bool p0) -> decltype(setVisible(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setVisible not implemented");
}

auto cocos2d::CCParticleSystem::setRotation(float p0) -> decltype(setRotation(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRotation not implemented");
}

auto cocos2d::CCParticleSystem::getBatchNode() -> decltype(getBatchNode()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getBatchNode not implemented");
}

auto cocos2d::CCParticleSystem::setBatchNode(cocos2d::CCParticleBatchNode* p0) -> decltype(setBatchNode(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setBatchNode not implemented");
}

auto cocos2d::CCParticleSystem::getParticleCount() -> decltype(getParticleCount()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getParticleCount not implemented");
}

auto cocos2d::CCParticleSystem::getDuration() -> decltype(getDuration()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getDuration not implemented");
}

auto cocos2d::CCParticleSystem::setDuration(float p0) -> decltype(setDuration(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setDuration not implemented");
}

auto cocos2d::CCParticleSystem::getSourcePosition() -> decltype(getSourcePosition()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getSourcePosition not implemented");
}

auto cocos2d::CCParticleSystem::setSourcePosition(cocos2d::CCPoint const& p0) -> decltype(setSourcePosition(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setSourcePosition not implemented");
}

auto cocos2d::CCParticleSystem::getPosVar() -> decltype(getPosVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getPosVar not implemented");
}

auto cocos2d::CCParticleSystem::setPosVar(cocos2d::CCPoint const& p0) -> decltype(setPosVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setPosVar not implemented");
}

auto cocos2d::CCParticleSystem::getLife() -> decltype(getLife()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getLife not implemented");
}

auto cocos2d::CCParticleSystem::setLife(float p0) -> decltype(setLife(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setLife not implemented");
}

auto cocos2d::CCParticleSystem::getLifeVar() -> decltype(getLifeVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getLifeVar not implemented");
}

auto cocos2d::CCParticleSystem::setLifeVar(float p0) -> decltype(setLifeVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setLifeVar not implemented");
}

auto cocos2d::CCParticleSystem::getAngle() -> decltype(getAngle()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getAngle not implemented");
}

auto cocos2d::CCParticleSystem::setAngle(float p0) -> decltype(setAngle(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setAngle not implemented");
}

auto cocos2d::CCParticleSystem::getAngleVar() -> decltype(getAngleVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getAngleVar not implemented");
}

auto cocos2d::CCParticleSystem::setAngleVar(float p0) -> decltype(setAngleVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setAngleVar not implemented");
}

auto cocos2d::CCParticleSystem::updateEmissionRate() -> decltype(updateEmissionRate()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::updateEmissionRate not implemented");
}

auto cocos2d::CCParticleSystem::getGravity() -> decltype(getGravity()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getGravity not implemented");
}

auto cocos2d::CCParticleSystem::setGravity(cocos2d::CCPoint const& p0) -> decltype(setGravity(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setGravity not implemented");
}

auto cocos2d::CCParticleSystem::getSpeed() -> decltype(getSpeed()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getSpeed not implemented");
}

auto cocos2d::CCParticleSystem::setSpeed(float p0) -> decltype(setSpeed(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setSpeed not implemented");
}

auto cocos2d::CCParticleSystem::getSpeedVar() -> decltype(getSpeedVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getSpeedVar not implemented");
}

auto cocos2d::CCParticleSystem::setSpeedVar(float p0) -> decltype(setSpeedVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setSpeedVar not implemented");
}

auto cocos2d::CCParticleSystem::getTangentialAccel() -> decltype(getTangentialAccel()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getTangentialAccel not implemented");
}

auto cocos2d::CCParticleSystem::setTangentialAccel(float p0) -> decltype(setTangentialAccel(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setTangentialAccel not implemented");
}

auto cocos2d::CCParticleSystem::getTangentialAccelVar() -> decltype(getTangentialAccelVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getTangentialAccelVar not implemented");
}

auto cocos2d::CCParticleSystem::setTangentialAccelVar(float p0) -> decltype(setTangentialAccelVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setTangentialAccelVar not implemented");
}

auto cocos2d::CCParticleSystem::getRadialAccel() -> decltype(getRadialAccel()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRadialAccel not implemented");
}

auto cocos2d::CCParticleSystem::setRadialAccel(float p0) -> decltype(setRadialAccel(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRadialAccel not implemented");
}

auto cocos2d::CCParticleSystem::getRadialAccelVar() -> decltype(getRadialAccelVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRadialAccelVar not implemented");
}

auto cocos2d::CCParticleSystem::setRadialAccelVar(float p0) -> decltype(setRadialAccelVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRadialAccelVar not implemented");
}

auto cocos2d::CCParticleSystem::getRotationIsDir() -> decltype(getRotationIsDir()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRotationIsDir not implemented");
}

auto cocos2d::CCParticleSystem::setRotationIsDir(bool p0) -> decltype(setRotationIsDir(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRotationIsDir not implemented");
}

auto cocos2d::CCParticleSystem::getStartRadius() -> decltype(getStartRadius()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartRadius not implemented");
}

auto cocos2d::CCParticleSystem::setStartRadius(float p0) -> decltype(setStartRadius(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartRadius not implemented");
}

auto cocos2d::CCParticleSystem::getStartRadiusVar() -> decltype(getStartRadiusVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartRadiusVar not implemented");
}

auto cocos2d::CCParticleSystem::setStartRadiusVar(float p0) -> decltype(setStartRadiusVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartRadiusVar not implemented");
}

auto cocos2d::CCParticleSystem::getEndRadius() -> decltype(getEndRadius()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndRadius not implemented");
}

auto cocos2d::CCParticleSystem::setEndRadius(float p0) -> decltype(setEndRadius(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndRadius not implemented");
}

auto cocos2d::CCParticleSystem::getEndRadiusVar() -> decltype(getEndRadiusVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndRadiusVar not implemented");
}

auto cocos2d::CCParticleSystem::setEndRadiusVar(float p0) -> decltype(setEndRadiusVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndRadiusVar not implemented");
}

auto cocos2d::CCParticleSystem::getRotatePerSecond() -> decltype(getRotatePerSecond()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRotatePerSecond not implemented");
}

auto cocos2d::CCParticleSystem::setRotatePerSecond(float p0) -> decltype(setRotatePerSecond(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRotatePerSecond not implemented");
}

auto cocos2d::CCParticleSystem::getRotatePerSecondVar() -> decltype(getRotatePerSecondVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRotatePerSecondVar not implemented");
}

auto cocos2d::CCParticleSystem::setRotatePerSecondVar(float p0) -> decltype(setRotatePerSecondVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRotatePerSecondVar not implemented");
}

auto cocos2d::CCParticleSystem::isActive() -> decltype(isActive()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::isActive not implemented");
}

auto cocos2d::CCParticleSystem::isBlendAdditive() -> decltype(isBlendAdditive()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::isBlendAdditive not implemented");
}

auto cocos2d::CCParticleSystem::setBlendAdditive(bool p0) -> decltype(setBlendAdditive(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setBlendAdditive not implemented");
}

auto cocos2d::CCParticleSystem::getStartSize() -> decltype(getStartSize()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartSize not implemented");
}

auto cocos2d::CCParticleSystem::setStartSize(float p0) -> decltype(setStartSize(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartSize not implemented");
}

auto cocos2d::CCParticleSystem::getStartSizeVar() -> decltype(getStartSizeVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartSizeVar not implemented");
}

auto cocos2d::CCParticleSystem::setStartSizeVar(float p0) -> decltype(setStartSizeVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartSizeVar not implemented");
}

auto cocos2d::CCParticleSystem::getEndSize() -> decltype(getEndSize()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndSize not implemented");
}

auto cocos2d::CCParticleSystem::setEndSize(float p0) -> decltype(setEndSize(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndSize not implemented");
}

auto cocos2d::CCParticleSystem::getEndSizeVar() -> decltype(getEndSizeVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndSizeVar not implemented");
}

auto cocos2d::CCParticleSystem::setEndSizeVar(float p0) -> decltype(setEndSizeVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndSizeVar not implemented");
}

auto cocos2d::CCParticleSystem::getStartColor() -> decltype(getStartColor()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartColor not implemented");
}

auto cocos2d::CCParticleSystem::setStartColor(cocos2d::_ccColor4F const& p0) -> decltype(setStartColor(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartColor not implemented");
}

auto cocos2d::CCParticleSystem::getStartColorVar() -> decltype(getStartColorVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartColorVar not implemented");
}

auto cocos2d::CCParticleSystem::setStartColorVar(cocos2d::_ccColor4F const& p0) -> decltype(setStartColorVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartColorVar not implemented");
}

auto cocos2d::CCParticleSystem::getEndColor() -> decltype(getEndColor()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndColor not implemented");
}

auto cocos2d::CCParticleSystem::setEndColor(cocos2d::_ccColor4F const& p0) -> decltype(setEndColor(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndColor not implemented");
}

auto cocos2d::CCParticleSystem::getEndColorVar() -> decltype(getEndColorVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndColorVar not implemented");
}

auto cocos2d::CCParticleSystem::setEndColorVar(cocos2d::_ccColor4F const& p0) -> decltype(setEndColorVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndColorVar not implemented");
}

auto cocos2d::CCParticleSystem::getStartSpin() -> decltype(getStartSpin()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartSpin not implemented");
}

auto cocos2d::CCParticleSystem::setStartSpin(float p0) -> decltype(setStartSpin(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartSpin not implemented");
}

auto cocos2d::CCParticleSystem::getStartSpinVar() -> decltype(getStartSpinVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartSpinVar not implemented");
}

auto cocos2d::CCParticleSystem::setStartSpinVar(float p0) -> decltype(setStartSpinVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartSpinVar not implemented");
}

auto cocos2d::CCParticleSystem::getEndSpin() -> decltype(getEndSpin()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndSpin not implemented");
}

auto cocos2d::CCParticleSystem::setEndSpin(float p0) -> decltype(setEndSpin(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndSpin not implemented");
}

auto cocos2d::CCParticleSystem::getEndSpinVar() -> decltype(getEndSpinVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndSpinVar not implemented");
}

auto cocos2d::CCParticleSystem::setEndSpinVar(float p0) -> decltype(setEndSpinVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndSpinVar not implemented");
}

auto cocos2d::CCParticleSystem::getEmissionRate() -> decltype(getEmissionRate()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEmissionRate not implemented");
}

auto cocos2d::CCParticleSystem::setEmissionRate(float p0) -> decltype(setEmissionRate(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEmissionRate not implemented");
}

auto cocos2d::CCParticleSystem::getTotalParticles() -> decltype(getTotalParticles()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getTotalParticles not implemented");
}

auto cocos2d::CCParticleSystem::setTotalParticles(unsigned int p0) -> decltype(setTotalParticles(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setTotalParticles not implemented");
}

auto cocos2d::CCParticleSystem::getOpacityModifyRGB() -> decltype(getOpacityModifyRGB()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getOpacityModifyRGB not implemented");
}

auto cocos2d::CCParticleSystem::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setOpacityModifyRGB not implemented");
}

auto cocos2d::CCParticleSystem::getPositionType() -> decltype(getPositionType()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getPositionType not implemented");
}

auto cocos2d::CCParticleSystem::setPositionType(cocos2d::tCCPositionType p0) -> decltype(setPositionType(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setPositionType not implemented");
}

auto cocos2d::CCParticleSystem::isAutoRemoveOnFinish() -> decltype(isAutoRemoveOnFinish()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::isAutoRemoveOnFinish not implemented");
}

auto cocos2d::CCParticleSystem::setAutoRemoveOnFinish(bool p0) -> decltype(setAutoRemoveOnFinish(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setAutoRemoveOnFinish not implemented");
}

auto cocos2d::CCParticleSystem::getEmitterMode() -> decltype(getEmitterMode()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEmitterMode not implemented");
}

auto cocos2d::CCParticleSystem::setEmitterMode(int p0) -> decltype(setEmitterMode(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEmitterMode not implemented");
}

auto cocos2d::CCParticleSystem::initWithTotalParticles(unsigned int p0, bool p1) -> decltype(initWithTotalParticles(p0, p1)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::initWithTotalParticles not implemented");
}

auto cocos2d::CCParticleSystem::updateQuadWithParticle(cocos2d::sCCParticle* p0, cocos2d::CCPoint const& p1) -> decltype(updateQuadWithParticle(p0, p1)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::updateQuadWithParticle not implemented");
}

auto cocos2d::CCParticleSystem::postStep() -> decltype(postStep()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::postStep not implemented");
}

auto cocos2d::CCParticleSystem::updateWithNoTime() -> decltype(updateWithNoTime()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::updateWithNoTime not implemented");
}

auto cocos2d::CCParticleSystem::updateBlendFunc() -> decltype(updateBlendFunc()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::updateBlendFunc not implemented");
}

auto cocos2d::CCParticleSystem::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setBlendFunc not implemented");
}

auto cocos2d::CCParticleSystem::getBlendFunc() -> decltype(getBlendFunc()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getBlendFunc not implemented");
}

auto cocos2d::CCParticleSystem::getTexture() -> decltype(getTexture()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getTexture not implemented");
}

auto cocos2d::CCParticleSystem::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setTexture not implemented");
}

auto cocos2d::CCParticleSystemQuad::create(char const* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, bool);
	static auto func = wrapFunction(base::get() + 0x60dce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCParticleSystemQuad::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x60f030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

cocos2d::CCParticleSystemQuad::~CCParticleSystemQuad() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0x60dc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCParticleSystemQuad(geode::CutoffConstructor, sizeof(cocos2d::CCParticleSystemQuad));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCParticleSystemQuad::draw() -> decltype(draw()) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::draw not implemented");
}

auto cocos2d::CCParticleSystemQuad::setBatchNode(cocos2d::CCParticleBatchNode* p0) -> decltype(setBatchNode(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::setBatchNode not implemented");
}

auto cocos2d::CCParticleSystemQuad::setTotalParticles(unsigned int p0) -> decltype(setTotalParticles(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::setTotalParticles not implemented");
}

auto cocos2d::CCParticleSystemQuad::initWithTotalParticles(unsigned int p0, bool p1) -> decltype(initWithTotalParticles(p0, p1)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::initWithTotalParticles not implemented");
}

auto cocos2d::CCParticleSystemQuad::updateQuadWithParticle(cocos2d::sCCParticle* p0, cocos2d::CCPoint const& p1) -> decltype(updateQuadWithParticle(p0, p1)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::updateQuadWithParticle not implemented");
}

auto cocos2d::CCParticleSystemQuad::postStep() -> decltype(postStep()) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::postStep not implemented");
}

auto cocos2d::CCParticleSystemQuad::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::setTexture not implemented");
}

auto cocos2d::CCProgressTimer::create(cocos2d::CCSprite* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x60f290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCProgressTimer::getColor() const  -> decltype(getColor()) {
	throw std::runtime_error("cocos2d::CCProgressTimer::getColor not implemented");
}

auto cocos2d::CCProgressTimer::getOpacity() const  -> decltype(getOpacity()) {
	throw std::runtime_error("cocos2d::CCProgressTimer::getOpacity not implemented");
}

auto cocos2d::CCProgressTimer::draw() -> decltype(draw()) {
	throw std::runtime_error("cocos2d::CCProgressTimer::draw not implemented");
}

auto cocos2d::CCProgressTimer::getMidpoint() -> decltype(getMidpoint()) {
	throw std::runtime_error("cocos2d::CCProgressTimer::getMidpoint not implemented");
}

auto cocos2d::CCProgressTimer::setMidpoint(cocos2d::CCPoint p0) -> decltype(setMidpoint(p0)) {
	throw std::runtime_error("cocos2d::CCProgressTimer::setMidpoint not implemented");
}

auto cocos2d::CCProgressTimer::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	throw std::runtime_error("cocos2d::CCProgressTimer::setColor not implemented");
}

auto cocos2d::CCProgressTimer::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("cocos2d::CCProgressTimer::setOpacity not implemented");
}

auto cocos2d::CCFadeIn::create(float p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(float);
	static auto func = wrapFunction(base::get() + 0x3bde30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCFadeIn::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCZone*>::func(&cocos2d::CCFadeIn::copyWithZone), this);
	using FunctionType = decltype(copyWithZone(p0))(*)(cocos2d::CCFadeIn*, cocos2d::CCZone*);
	static auto func = wrapFunction(base::get() + 0x3bded0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCFadeIn::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCFadeIn::update not implemented");
}

auto cocos2d::CCFadeIn::reverse() -> decltype(reverse()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCFadeIn::reverse), this);
	using FunctionType = decltype(reverse())(*)(cocos2d::CCFadeIn*);
	static auto func = wrapFunction(base::get() + 0x3be270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCFadeOut::create(float p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(float);
	static auto func = wrapFunction(base::get() + 0x3be0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCFadeOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCFadeOut::copyWithZone not implemented");
}

auto cocos2d::CCFadeOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCFadeOut::update not implemented");
}

auto cocos2d::CCFadeOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCFadeOut::reverse not implemented");
}

auto cocos2d::CCFadeTo::create(float p0, unsigned char p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, unsigned char);
	static auto func = wrapFunction(base::get() + 0x3be320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCFadeTo::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCFadeTo::copyWithZone not implemented");
}

auto cocos2d::CCFadeTo::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCFadeTo::update not implemented");
}

auto cocos2d::CCFadeTo::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCFadeTo::startWithTarget not implemented");
}

auto cocos2d::CCFileUtils::addSearchPath(char const* p0) -> decltype(addSearchPath(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::addSearchPath not implemented");
}

auto cocos2d::CCFileUtils::addSearchResolutionsOrder(char const* p0) -> decltype(addSearchResolutionsOrder(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::addSearchResolutionsOrder not implemented");
}

auto cocos2d::CCFileUtils::addSuffix(gd::string p0, gd::string p1) -> decltype(addSuffix(p0, p1)) {
	throw std::runtime_error("cocos2d::CCFileUtils::addSuffix not implemented");
}

auto cocos2d::CCFileUtils::createCCArrayWithContentsOfFile(gd::string const& p0) -> decltype(createCCArrayWithContentsOfFile(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::createCCArrayWithContentsOfFile not implemented");
}

auto cocos2d::CCFileUtils::createCCDictionaryWithContentsOfFile(gd::string const& p0) -> decltype(createCCDictionaryWithContentsOfFile(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::createCCDictionaryWithContentsOfFile not implemented");
}

auto cocos2d::CCFileUtils::fullPathForFilename(char const* p0, bool p1) -> decltype(fullPathForFilename(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, bool>::func(&cocos2d::CCFileUtils::fullPathForFilename), this);
	using FunctionType = decltype(fullPathForFilename(p0, p1))(*)(cocos2d::CCFileUtils*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x4445e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCFileUtils::fullPathFromRelativeFile(char const* p0, char const* p1) -> decltype(fullPathFromRelativeFile(p0, p1)) {
	throw std::runtime_error("cocos2d::CCFileUtils::fullPathFromRelativeFile not implemented");
}

auto cocos2d::CCFileUtils::getFileData(char const* p0, char const* p1, unsigned long* p2) -> decltype(getFileData(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, char const*, unsigned long*>::func(&cocos2d::CCFileUtils::getFileData), this);
	using FunctionType = decltype(getFileData(p0, p1, p2))(*)(cocos2d::CCFileUtils*, char const*, char const*, unsigned long*);
	static auto func = wrapFunction(base::get() + 0x443aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCFileUtils::getFileDataFromZip(char const* p0, char const* p1, unsigned long* p2) -> decltype(getFileDataFromZip(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::CCFileUtils::getFileDataFromZip not implemented");
}

auto cocos2d::CCFileUtils::getFullPathForDirectoryAndFilename(gd::string const& p0, gd::string const& p1) -> decltype(getFullPathForDirectoryAndFilename(p0, p1)) {
	throw std::runtime_error("cocos2d::CCFileUtils::getFullPathForDirectoryAndFilename not implemented");
}

auto cocos2d::CCFileUtils::getNewFilename(char const* p0) -> decltype(getNewFilename(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::getNewFilename not implemented");
}

auto cocos2d::CCFileUtils::getPathForFilename(gd::string const& p0, gd::string const& p1, gd::string const& p2) -> decltype(getPathForFilename(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::CCFileUtils::getPathForFilename not implemented");
}

auto cocos2d::CCFileUtils::getSearchPaths() -> decltype(getSearchPaths()) {
	throw std::runtime_error("cocos2d::CCFileUtils::getSearchPaths not implemented");
}

auto cocos2d::CCFileUtils::getSearchResolutionsOrder() -> decltype(getSearchResolutionsOrder()) {
	throw std::runtime_error("cocos2d::CCFileUtils::getSearchResolutionsOrder not implemented");
}

auto cocos2d::CCFileUtils::getWritablePath2() -> decltype(getWritablePath2()) {
	throw std::runtime_error("cocos2d::CCFileUtils::getWritablePath2 not implemented");
}

auto cocos2d::CCFileUtils::init() -> decltype(init()) {
	throw std::runtime_error("cocos2d::CCFileUtils::init not implemented");
}

auto cocos2d::CCFileUtils::isAbsolutePath(gd::string const& p0) -> decltype(isAbsolutePath(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::isAbsolutePath not implemented");
}

auto cocos2d::CCFileUtils::isPopupNotify() -> decltype(isPopupNotify()) {
	throw std::runtime_error("cocos2d::CCFileUtils::isPopupNotify not implemented");
}

auto cocos2d::CCFileUtils::loadFilenameLookupDictionaryFromFile(char const* p0) -> decltype(loadFilenameLookupDictionaryFromFile(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::loadFilenameLookupDictionaryFromFile not implemented");
}

auto cocos2d::CCFileUtils::purgeCachedEntries() -> decltype(purgeCachedEntries()) {
	throw std::runtime_error("cocos2d::CCFileUtils::purgeCachedEntries not implemented");
}

auto cocos2d::CCFileUtils::removeFullPath(char const* p0) -> decltype(removeFullPath(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::removeFullPath not implemented");
}

auto cocos2d::CCFileUtils::removeSearchPath(char const* p0) -> decltype(removeSearchPath(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::removeSearchPath not implemented");
}

auto cocos2d::CCFileUtils::setFilenameLookupDictionary(cocos2d::CCDictionary* p0) -> decltype(setFilenameLookupDictionary(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::setFilenameLookupDictionary not implemented");
}

auto cocos2d::CCFileUtils::setPopupNotify(bool p0) -> decltype(setPopupNotify(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::setPopupNotify not implemented");
}

auto cocos2d::CCFileUtils::setSearchPaths(gd::vector<gd::string> const& p0) -> decltype(setSearchPaths(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::setSearchPaths not implemented");
}

auto cocos2d::CCFileUtils::setSearchResolutionsOrder(gd::vector<gd::string> const& p0) -> decltype(setSearchResolutionsOrder(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::setSearchResolutionsOrder not implemented");
}

auto cocos2d::CCFileUtils::sharedFileUtils() -> decltype(sharedFileUtils()) {
	using FunctionType = decltype(sharedFileUtils())(*)();
	static auto func = wrapFunction(base::get() + 0x616a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCFileUtils::shouldUseHD() -> decltype(shouldUseHD()) {
	throw std::runtime_error("cocos2d::CCFileUtils::shouldUseHD not implemented");
}

auto cocos2d::CCFileUtils::writeToFile(cocos2d::CCDictionary* p0, gd::string const& p1) -> decltype(writeToFile(p0, p1)) {
	throw std::runtime_error("cocos2d::CCFileUtils::writeToFile not implemented");
}

auto cocos2d::CCGLProgram::setUniformsForBuiltins() -> decltype(setUniformsForBuiltins()) {
	using FunctionType = decltype(setUniformsForBuiltins())(*)(cocos2d::CCGLProgram*);
	static auto func = wrapFunction(base::get() + 0x435940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCGLProgram::use() -> decltype(use()) {
	using FunctionType = decltype(use())(*)(cocos2d::CCGLProgram*);
	static auto func = wrapFunction(base::get() + 0x434970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x26ee60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

cocos2d::CCNode::CCNode() {
	using FunctionType = void(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCNode::~CCNode() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCNode(geode::CutoffConstructor, sizeof(cocos2d::CCNode));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCNode::getActionByTag(int p0) -> decltype(getActionByTag(p0)) {
	using FunctionType = decltype(getActionByTag(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x270140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::boundingBox() -> decltype(boundingBox()) {
	using FunctionType = decltype(boundingBox())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26edf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::convertToNodeSpace(cocos2d::CCPoint const& p0) -> decltype(convertToNodeSpace(p0)) {
	using FunctionType = decltype(convertToNodeSpace(p0))(*)(cocos2d::CCNode*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x270db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::convertToWorldSpace(cocos2d::CCPoint const& p0) -> decltype(convertToWorldSpace(p0)) {
	using FunctionType = decltype(convertToWorldSpace(p0))(*)(cocos2d::CCNode*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x270df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::resumeSchedulerAndActions() -> decltype(resumeSchedulerAndActions()) {
	using FunctionType = decltype(resumeSchedulerAndActions())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26fd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::runAction(cocos2d::CCAction* p0) -> decltype(runAction(p0)) {
	using FunctionType = decltype(runAction(p0))(*)(cocos2d::CCNode*, cocos2d::CCAction*);
	static auto func = wrapFunction(base::get() + 0x2700d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::schedule(cocos2d::SEL_SCHEDULE p0) -> decltype(schedule(p0)) {
	using FunctionType = decltype(schedule(p0))(*)(cocos2d::CCNode*, cocos2d::SEL_SCHEDULE);
	static auto func = wrapFunction(base::get() + 0x270300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::schedule(cocos2d::SEL_SCHEDULE p0, float p1) -> decltype(schedule(p0, p1)) {
	using FunctionType = decltype(schedule(p0, p1))(*)(cocos2d::CCNode*, cocos2d::SEL_SCHEDULE, float);
	static auto func = wrapFunction(base::get() + 0x270360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCNode::scheduleOnce(cocos2d::SEL_SCHEDULE p0, float p1) -> decltype(scheduleOnce(p0, p1)) {
	using FunctionType = decltype(scheduleOnce(p0, p1))(*)(cocos2d::CCNode*, cocos2d::SEL_SCHEDULE, float);
	static auto func = wrapFunction(base::get() + 0x270390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCNode::scheduleUpdate() -> decltype(scheduleUpdate()) {
	using FunctionType = decltype(scheduleUpdate())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2701e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::stopAction(cocos2d::CCAction* p0) -> decltype(stopAction(p0)) {
	using FunctionType = decltype(stopAction(p0))(*)(cocos2d::CCNode*, cocos2d::CCAction*);
	static auto func = wrapFunction(base::get() + 0x270100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::stopActionByTag(int p0) -> decltype(stopActionByTag(p0)) {
	using FunctionType = decltype(stopActionByTag(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x270120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::stopAllActions() -> decltype(stopAllActions()) {
	using FunctionType = decltype(stopAllActions())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ef50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::unscheduleAllSelectors() -> decltype(unscheduleAllSelectors()) {
	using FunctionType = decltype(unscheduleAllSelectors())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ef70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::unscheduleUpdate() -> decltype(unscheduleUpdate()) {
	using FunctionType = decltype(unscheduleUpdate())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2702b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::update), this);
	using FunctionType = decltype(update(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x2703e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setZOrder(int p0) -> decltype(setZOrder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::setZOrder), this);
	using FunctionType = decltype(setZOrder(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x26e700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::_setZOrder(int p0) -> decltype(_setZOrder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::_setZOrder), this);
	using FunctionType = decltype(_setZOrder(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x26e6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getZOrder() -> decltype(getZOrder()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getZOrder), this);
	using FunctionType = decltype(getZOrder())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setVertexZ(float p0) -> decltype(setVertexZ(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setVertexZ), this);
	using FunctionType = decltype(setVertexZ(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getVertexZ() -> decltype(getVertexZ()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getVertexZ), this);
	using FunctionType = decltype(getVertexZ())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScaleX() -> decltype(getScaleX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScaleX), this);
	using FunctionType = decltype(getScaleX())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScaleY() -> decltype(getScaleY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScaleY), this);
	using FunctionType = decltype(getScaleY())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScale() -> decltype(getScale()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScale), this);
	using FunctionType = decltype(getScale())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScale(float p0, float p1) -> decltype(setScale(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&cocos2d::CCNode::setScale), this);
	using FunctionType = decltype(setScale(p0, p1))(*)(cocos2d::CCNode*, float, float);
	static auto func = wrapFunction(base::get() + 0x26e840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCNode::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(cocos2d::CCNode*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x26e8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getPosition() -> decltype(getPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getPosition), this);
	using FunctionType = decltype(getPosition())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setPosition(float p0, float p1) -> decltype(setPosition(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&cocos2d::CCNode::setPosition), this);
	using FunctionType = decltype(setPosition(p0, p1))(*)(cocos2d::CCNode*, float, float);
	static auto func = wrapFunction(base::get() + 0x26e910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::getPosition(float* p0, float* p1) -> decltype(getPosition(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float*, float*>::func(&cocos2d::CCNode::getPosition), this);
	using FunctionType = decltype(getPosition(p0, p1))(*)(cocos2d::CCNode*, float*, float*);
	static auto func = wrapFunction(base::get() + 0x26e8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::setPositionX(float p0) -> decltype(setPositionX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setPositionX), this);
	using FunctionType = decltype(setPositionX(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getPositionX() -> decltype(getPositionX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getPositionX), this);
	using FunctionType = decltype(getPositionX())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setPositionY(float p0) -> decltype(setPositionY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setPositionY), this);
	using FunctionType = decltype(setPositionY(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getPositionY() -> decltype(getPositionY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getPositionY), this);
	using FunctionType = decltype(getPositionY())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setSkewX(float p0) -> decltype(setSkewX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setSkewX), this);
	using FunctionType = decltype(setSkewX(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getSkewX() -> decltype(getSkewX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getSkewX), this);
	using FunctionType = decltype(getSkewX())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setSkewY(float p0) -> decltype(setSkewY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setSkewY), this);
	using FunctionType = decltype(setSkewY(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getSkewY() -> decltype(getSkewY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getSkewY), this);
	using FunctionType = decltype(getSkewY())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setAnchorPoint(cocos2d::CCPoint const& p0) -> decltype(setAnchorPoint(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCNode::setAnchorPoint), this);
	using FunctionType = decltype(setAnchorPoint(p0))(*)(cocos2d::CCNode*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x26eb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getAnchorPoint() -> decltype(getAnchorPoint()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getAnchorPoint), this);
	using FunctionType = decltype(getAnchorPoint())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26eb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::getAnchorPointInPoints() -> decltype(getAnchorPointInPoints()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getAnchorPointInPoints), this);
	using FunctionType = decltype(getAnchorPointInPoints())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26eb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setContentSize(cocos2d::CCSize const& p0) -> decltype(setContentSize(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSize const&>::func(&cocos2d::CCNode::setContentSize), this);
	using FunctionType = decltype(setContentSize(p0))(*)(cocos2d::CCNode*, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x26ec00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getContentSize() const  -> decltype(getContentSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getContentSize), this);
	using FunctionType = decltype(getContentSize())(*)(cocos2d::CCNode const *);
	static auto func = wrapFunction(base::get() + 0x26ebc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::getScaledContentSize() -> decltype(getScaledContentSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScaledContentSize), this);
	using FunctionType = decltype(getScaledContentSize())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ebd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNode::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x26eb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::isVisible() -> decltype(isVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::isVisible), this);
	using FunctionType = decltype(isVisible())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26eb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getRotation() -> decltype(getRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getRotation), this);
	using FunctionType = decltype(getRotation())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getRotationX() -> decltype(getRotationX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getRotationX), this);
	using FunctionType = decltype(getRotationX())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x26e7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getRotationY() -> decltype(getRotationY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getRotationY), this);
	using FunctionType = decltype(getRotationY())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setOrderOfArrival(unsigned int p0) -> decltype(setOrderOfArrival(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned int>::func(&cocos2d::CCNode::setOrderOfArrival), this);
	using FunctionType = decltype(setOrderOfArrival(p0))(*)(cocos2d::CCNode*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x26ed20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getOrderOfArrival() -> decltype(getOrderOfArrival()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getOrderOfArrival), this);
	using FunctionType = decltype(getOrderOfArrival())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ed10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setGLServerState(cocos2d::ccGLServerState p0) -> decltype(setGLServerState(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccGLServerState>::func(&cocos2d::CCNode::setGLServerState), this);
	using FunctionType = decltype(setGLServerState(p0))(*)(cocos2d::CCNode*, cocos2d::ccGLServerState);
	static auto func = wrapFunction(base::get() + 0x26ed60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getGLServerState() -> decltype(getGLServerState()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getGLServerState), this);
	using FunctionType = decltype(getGLServerState())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ed50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::ignoreAnchorPointForPosition(bool p0) -> decltype(ignoreAnchorPointForPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNode::ignoreAnchorPointForPosition), this);
	using FunctionType = decltype(ignoreAnchorPointForPosition(p0))(*)(cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x26ecc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::isIgnoreAnchorPointForPosition() -> decltype(isIgnoreAnchorPointForPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::isIgnoreAnchorPointForPosition), this);
	using FunctionType = decltype(isIgnoreAnchorPointForPosition())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ecb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::addChild(cocos2d::CCNode* p0) -> decltype(addChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCNode::addChild), this);
	using FunctionType = decltype(addChild(p0))(*)(cocos2d::CCNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26f1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::addChild(cocos2d::CCNode* p0, int p1) -> decltype(addChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCNode::addChild), this);
	using FunctionType = decltype(addChild(p0, p1))(*)(cocos2d::CCNode*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x26f190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::addChild(cocos2d::CCNode* p0, int p1, int p2) -> decltype(addChild(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int, int>::func(&cocos2d::CCNode::addChild), this);
	using FunctionType = decltype(addChild(p0, p1, p2))(*)(cocos2d::CCNode*, cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x26f060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCNode::getChildByTag(int p0) -> decltype(getChildByTag(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::getChildByTag), this);
	using FunctionType = decltype(getChildByTag(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x26efe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getChildren() -> decltype(getChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getChildren), this);
	using FunctionType = decltype(getChildren())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26e9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::getChildrenCount() const  -> decltype(getChildrenCount()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getChildrenCount), this);
	using FunctionType = decltype(getChildrenCount())(*)(cocos2d::CCNode const *);
	static auto func = wrapFunction(base::get() + 0x26ea40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setParent(cocos2d::CCNode* p0) -> decltype(setParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCNode::setParent), this);
	using FunctionType = decltype(setParent(p0))(*)(cocos2d::CCNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26eca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getParent() -> decltype(getParent()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getParent), this);
	using FunctionType = decltype(getParent())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ec90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::removeFromParent() -> decltype(removeFromParent()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::removeFromParent), this);
	using FunctionType = decltype(removeFromParent())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26f1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::removeFromParentAndCleanup(bool p0) -> decltype(removeFromParentAndCleanup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNode::removeFromParentAndCleanup), this);
	using FunctionType = decltype(removeFromParentAndCleanup(p0))(*)(cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x26f1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeMeAndCleanup() -> decltype(removeMeAndCleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::removeMeAndCleanup), this);
	using FunctionType = decltype(removeMeAndCleanup())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26f220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::removeChild(cocos2d::CCNode* p0) -> decltype(removeChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCNode::removeChild), this);
	using FunctionType = decltype(removeChild(p0))(*)(cocos2d::CCNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26f240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeChild(cocos2d::CCNode* p0, bool p1) -> decltype(removeChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, bool>::func(&cocos2d::CCNode::removeChild), this);
	using FunctionType = decltype(removeChild(p0, p1))(*)(cocos2d::CCNode*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x26f260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::removeChildByTag(int p0) -> decltype(removeChildByTag(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::removeChildByTag), this);
	using FunctionType = decltype(removeChildByTag(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x26f3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeChildByTag(int p0, bool p1) -> decltype(removeChildByTag(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&cocos2d::CCNode::removeChildByTag), this);
	using FunctionType = decltype(removeChildByTag(p0, p1))(*)(cocos2d::CCNode*, int, bool);
	static auto func = wrapFunction(base::get() + 0x26f3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::removeAllChildren() -> decltype(removeAllChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::removeAllChildren), this);
	using FunctionType = decltype(removeAllChildren())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26f410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::removeAllChildrenWithCleanup(bool p0) -> decltype(removeAllChildrenWithCleanup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNode::removeAllChildrenWithCleanup), this);
	using FunctionType = decltype(removeAllChildrenWithCleanup(p0))(*)(cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x26f430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::reorderChild(cocos2d::CCNode* p0, int p1) -> decltype(reorderChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCNode::reorderChild), this);
	using FunctionType = decltype(reorderChild(p0, p1))(*)(cocos2d::CCNode*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x26f550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::sortAllChildren() -> decltype(sortAllChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::sortAllChildren), this);
	using FunctionType = decltype(sortAllChildren())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26f690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::getGrid() -> decltype(getGrid()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getGrid), this);
	using FunctionType = decltype(getGrid())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26eab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setGrid(cocos2d::CCGridBase* p0) -> decltype(setGrid(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCGridBase*>::func(&cocos2d::CCNode::setGrid), this);
	using FunctionType = decltype(setGrid(p0))(*)(cocos2d::CCNode*, cocos2d::CCGridBase*);
	static auto func = wrapFunction(base::get() + 0x26eac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getUserData() -> decltype(getUserData()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getUserData), this);
	using FunctionType = decltype(getUserData())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ecf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setUserData(void* p0) -> decltype(setUserData(p0)) {
	auto self = addresser::thunkAdjust(Resolve<void*>::func(&cocos2d::CCNode::setUserData), this);
	using FunctionType = decltype(setUserData(p0))(*)(cocos2d::CCNode*, void*);
	static auto func = wrapFunction(base::get() + 0x26ed00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getUserObject() -> decltype(getUserObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getUserObject), this);
	using FunctionType = decltype(getUserObject())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ed40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setUserObject(cocos2d::CCObject* p0) -> decltype(setUserObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&cocos2d::CCNode::setUserObject), this);
	using FunctionType = decltype(setUserObject(p0))(*)(cocos2d::CCNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26ed70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getShaderProgram() -> decltype(getShaderProgram()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getShaderProgram), this);
	using FunctionType = decltype(getShaderProgram())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ed30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setShaderProgram(cocos2d::CCGLProgram* p0) -> decltype(setShaderProgram(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCGLProgram*>::func(&cocos2d::CCNode::setShaderProgram), this);
	using FunctionType = decltype(setShaderProgram(p0))(*)(cocos2d::CCNode*, cocos2d::CCGLProgram*);
	static auto func = wrapFunction(base::get() + 0x26edb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getCamera() -> decltype(getCamera()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getCamera), this);
	using FunctionType = decltype(getCamera())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ea60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::isRunning() -> decltype(isRunning()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::isRunning), this);
	using FunctionType = decltype(isRunning())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26ec80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::registerScriptHandler(int p0) -> decltype(registerScriptHandler(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::registerScriptHandler), this);
	using FunctionType = decltype(registerScriptHandler(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x270000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::unregisterScriptHandler() -> decltype(unregisterScriptHandler()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::unregisterScriptHandler), this);
	using FunctionType = decltype(unregisterScriptHandler())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x270030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26fca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26fdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26fee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::onExitTransitionDidStart() -> decltype(onExitTransitionDidStart()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::onExitTransitionDidStart), this);
	using FunctionType = decltype(onExitTransitionDidStart())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26fe40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::cleanup() -> decltype(cleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::cleanup), this);
	using FunctionType = decltype(cleanup())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26eec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26fa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::visit), this);
	using FunctionType = decltype(visit())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26fa70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setActionManager(cocos2d::CCActionManager* p0) -> decltype(setActionManager(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCActionManager*>::func(&cocos2d::CCNode::setActionManager), this);
	using FunctionType = decltype(setActionManager(p0))(*)(cocos2d::CCNode*, cocos2d::CCActionManager*);
	static auto func = wrapFunction(base::get() + 0x270070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getActionManager() -> decltype(getActionManager()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getActionManager), this);
	using FunctionType = decltype(getActionManager())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2700c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScheduler(cocos2d::CCScheduler* p0) -> decltype(setScheduler(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCScheduler*>::func(&cocos2d::CCNode::setScheduler), this);
	using FunctionType = decltype(setScheduler(p0))(*)(cocos2d::CCNode*, cocos2d::CCScheduler*);
	static auto func = wrapFunction(base::get() + 0x270180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScheduler() -> decltype(getScheduler()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScheduler), this);
	using FunctionType = decltype(getScheduler())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2701d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::updateTransform() -> decltype(updateTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::updateTransform), this);
	using FunctionType = decltype(updateTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x271040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::nodeToParentTransform() -> decltype(nodeToParentTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::nodeToParentTransform), this);
	using FunctionType = decltype(nodeToParentTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x270450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::nodeToParentTransformFast() -> decltype(nodeToParentTransformFast()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::nodeToParentTransformFast), this);
	using FunctionType = decltype(nodeToParentTransformFast())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x270760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::parentToNodeTransform() -> decltype(parentToNodeTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::parentToNodeTransform), this);
	using FunctionType = decltype(parentToNodeTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x270bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::nodeToWorldTransform() -> decltype(nodeToWorldTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::nodeToWorldTransform), this);
	using FunctionType = decltype(nodeToWorldTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x270c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::nodeToWorldTransformFast() -> decltype(nodeToWorldTransformFast()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::nodeToWorldTransformFast), this);
	using FunctionType = decltype(nodeToWorldTransformFast())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x270ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::worldToNodeTransform() -> decltype(worldToNodeTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::worldToNodeTransform), this);
	using FunctionType = decltype(worldToNodeTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x270d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::addComponent(cocos2d::CCComponent* p0) -> decltype(addComponent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCComponent*>::func(&cocos2d::CCNode::addComponent), this);
	using FunctionType = decltype(addComponent(p0))(*)(cocos2d::CCNode*, cocos2d::CCComponent*);
	static auto func = wrapFunction(base::get() + 0x2710b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeComponent(char const* p0) -> decltype(removeComponent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCNode::removeComponent), this);
	using FunctionType = decltype(removeComponent(p0))(*)(cocos2d::CCNode*, char const*);
	static auto func = wrapFunction(base::get() + 0x2710d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeComponent(cocos2d::CCComponent* p0) -> decltype(removeComponent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCComponent*>::func(&cocos2d::CCNode::removeComponent), this);
	using FunctionType = decltype(removeComponent(p0))(*)(cocos2d::CCNode*, cocos2d::CCComponent*);
	static auto func = wrapFunction(base::get() + 0x2710f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeAllComponents() -> decltype(removeAllComponents()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::removeAllComponents), this);
	using FunctionType = decltype(removeAllComponents())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x271110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&cocos2d::CCNode::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(cocos2d::CCNode*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x271020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::updateTweenActionInt(float p0, int p1) -> decltype(updateTweenActionInt(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&cocos2d::CCNode::updateTweenActionInt), this);
	using FunctionType = decltype(updateTweenActionInt(p0, p1))(*)(cocos2d::CCNode*, float, int);
	static auto func = wrapFunction(base::get() + 0x271030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCScheduler::pauseTarget(cocos2d::CCObject* p0) -> decltype(pauseTarget(p0)) {
	using FunctionType = decltype(pauseTarget(p0))(*)(cocos2d::CCScheduler*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x44cc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCScheduler::scheduleSelector(cocos2d::SEL_SCHEDULE p0, cocos2d::CCObject* p1, float p2, unsigned int p3, float p4, bool p5) -> decltype(scheduleSelector(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(scheduleSelector(p0, p1, p2, p3, p4, p5))(*)(cocos2d::CCScheduler*, cocos2d::SEL_SCHEDULE, cocos2d::CCObject*, float, unsigned int, float, bool);
	static auto func = wrapFunction(base::get() + 0x44b680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto cocos2d::CCScheduler::scheduleSelector(cocos2d::SEL_SCHEDULE p0, cocos2d::CCObject* p1, float p2, bool p3) -> decltype(scheduleSelector(p0, p1, p2, p3)) {
	using FunctionType = decltype(scheduleSelector(p0, p1, p2, p3))(*)(cocos2d::CCScheduler*, cocos2d::SEL_SCHEDULE, cocos2d::CCObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x44b660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto cocos2d::CCScheduler::scheduleUpdateForTarget(cocos2d::CCObject* p0, int p1, bool p2) -> decltype(scheduleUpdateForTarget(p0, p1, p2)) {
	using FunctionType = decltype(scheduleUpdateForTarget(p0, p1, p2))(*)(cocos2d::CCScheduler*, cocos2d::CCObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x44c260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCScheduler::unscheduleSelector(cocos2d::SEL_SCHEDULE p0, cocos2d::CCObject* p1) -> decltype(unscheduleSelector(p0, p1)) {
	using FunctionType = decltype(unscheduleSelector(p0, p1))(*)(cocos2d::CCScheduler*, cocos2d::SEL_SCHEDULE, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x44b190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCScheduler::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCScheduler::update), this);
	using FunctionType = decltype(update(p0))(*)(cocos2d::CCScheduler*, float);
	static auto func = wrapFunction(base::get() + 0x44d2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x4ba620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

cocos2d::CCLayer::CCLayer() {
	using FunctionType = void(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4ba060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCLayer::~CCLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4ba350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLayer(geode::CutoffConstructor, sizeof(cocos2d::CCLayer));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4ba5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4baeb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4bb040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4baf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4ba740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::registerScriptTouchHandler(int p0, bool p1, int p2, bool p3) -> decltype(registerScriptTouchHandler(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool, int, bool>::func(&cocos2d::CCLayer::registerScriptTouchHandler), this);
	using FunctionType = decltype(registerScriptTouchHandler(p0, p1, p2, p3))(*)(cocos2d::CCLayer*, int, bool, int, bool);
	static auto func = wrapFunction(base::get() + 0x4ba7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto cocos2d::CCLayer::unregisterScriptTouchHandler() -> decltype(unregisterScriptTouchHandler()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::unregisterScriptTouchHandler), this);
	using FunctionType = decltype(unregisterScriptTouchHandler())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4ba820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::isTouchEnabled() -> decltype(isTouchEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isTouchEnabled), this);
	using FunctionType = decltype(isTouchEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4ba8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setTouchEnabled(bool p0) -> decltype(setTouchEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setTouchEnabled), this);
	using FunctionType = decltype(setTouchEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4ba8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::setTouchMode(cocos2d::ccTouchesMode p0) -> decltype(setTouchMode(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccTouchesMode>::func(&cocos2d::CCLayer::setTouchMode), this);
	using FunctionType = decltype(setTouchMode(p0))(*)(cocos2d::CCLayer*, cocos2d::ccTouchesMode);
	static auto func = wrapFunction(base::get() + 0x4ba950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::getTouchMode() -> decltype(getTouchMode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::getTouchMode), this);
	using FunctionType = decltype(getTouchMode())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4baa00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setTouchPriority(int p0) -> decltype(setTouchPriority(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCLayer::setTouchPriority), this);
	using FunctionType = decltype(setTouchPriority(p0))(*)(cocos2d::CCLayer*, int);
	static auto func = wrapFunction(base::get() + 0x4ba9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::getTouchPriority() -> decltype(getTouchPriority()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::getTouchPriority), this);
	using FunctionType = decltype(getTouchPriority())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4ba9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::isAccelerometerEnabled() -> decltype(isAccelerometerEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isAccelerometerEnabled), this);
	using FunctionType = decltype(isAccelerometerEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4baa10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setAccelerometerEnabled(bool p0) -> decltype(setAccelerometerEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setAccelerometerEnabled), this);
	using FunctionType = decltype(setAccelerometerEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4baa20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::setAccelerometerInterval(double p0) -> decltype(setAccelerometerInterval(p0)) {
	auto self = addresser::thunkAdjust(Resolve<double>::func(&cocos2d::CCLayer::setAccelerometerInterval), this);
	using FunctionType = decltype(setAccelerometerInterval(p0))(*)(cocos2d::CCLayer*, double);
	static auto func = wrapFunction(base::get() + 0x4baa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::isKeypadEnabled() -> decltype(isKeypadEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isKeypadEnabled), this);
	using FunctionType = decltype(isKeypadEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4bab60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setKeypadEnabled(bool p0) -> decltype(setKeypadEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setKeypadEnabled), this);
	using FunctionType = decltype(setKeypadEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4bab70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::isKeyboardEnabled() -> decltype(isKeyboardEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isKeyboardEnabled), this);
	using FunctionType = decltype(isKeyboardEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4babe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setKeyboardEnabled(bool p0) -> decltype(setKeyboardEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setKeyboardEnabled), this);
	using FunctionType = decltype(setKeyboardEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4babf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::isMouseEnabled() -> decltype(isMouseEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isMouseEnabled), this);
	using FunctionType = decltype(isMouseEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4bac50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setMouseEnabled(bool p0) -> decltype(setMouseEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setMouseEnabled), this);
	using FunctionType = decltype(setMouseEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4bac60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4bb080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4bb110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4bb190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4bb210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchesBegan(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchesBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchesBegan), this);
	using FunctionType = decltype(ccTouchesBegan(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4bb290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchesMoved(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchesMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchesMoved), this);
	using FunctionType = decltype(ccTouchesMoved(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4bb310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchesEnded(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchesEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchesEnded), this);
	using FunctionType = decltype(ccTouchesEnded(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4bb390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchesCancelled(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchesCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchesCancelled), this);
	using FunctionType = decltype(ccTouchesCancelled(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4bb410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::setPreviousPriority(int p0) -> decltype(setPreviousPriority(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCLayer::setPreviousPriority), this);
	using FunctionType = decltype(setPreviousPriority(p0))(*)(cocos2d::CCLayer*, int);
	static auto func = wrapFunction(base::get() + 0x6ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::getPreviousPriority() -> decltype(getPreviousPriority()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::getPreviousPriority), this);
	using FunctionType = decltype(getPreviousPriority())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x6f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::didAccelerate(cocos2d::CCAcceleration* p0) -> decltype(didAccelerate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCAcceleration*>::func(&cocos2d::CCLayer::didAccelerate), this);
	using FunctionType = decltype(didAccelerate(p0))(*)(cocos2d::CCLayer*, cocos2d::CCAcceleration*);
	static auto func = wrapFunction(base::get() + 0x4baa90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4bad10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::keyMenuClicked() -> decltype(keyMenuClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::keyMenuClicked), this);
	using FunctionType = decltype(keyMenuClicked())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4badb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&cocos2d::CCLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(cocos2d::CCLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4bae30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::create(cocos2d::_ccColor4B const& p0, cocos2d::_ccColor4B const& p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&);
	static auto func = wrapFunction(base::get() + 0x4bd4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCLayerGradient::create(cocos2d::_ccColor4B const& p0, cocos2d::_ccColor4B const& p1, cocos2d::CCPoint const& p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x4bd760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::CCLayerGradient::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x4bd860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::updateColor() -> decltype(updateColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::updateColor), this);
	using FunctionType = decltype(updateColor())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x4bd9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::initWithColor(cocos2d::_ccColor4B const& p0, cocos2d::_ccColor4B const& p1) -> decltype(initWithColor(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&>::func(&cocos2d::CCLayerGradient::initWithColor), this);
	using FunctionType = decltype(initWithColor(p0, p1))(*)(cocos2d::CCLayerGradient*, cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&);
	static auto func = wrapFunction(base::get() + 0x4bd890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayerGradient::initWithColor(cocos2d::_ccColor4B const& p0, cocos2d::_ccColor4B const& p1, cocos2d::CCPoint const& p2) -> decltype(initWithColor(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&, cocos2d::CCPoint const&>::func(&cocos2d::CCLayerGradient::initWithColor), this);
	using FunctionType = decltype(initWithColor(p0, p1, p2))(*)(cocos2d::CCLayerGradient*, cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x4bd8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCLayerGradient::getStartColor() -> decltype(getStartColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getStartColor), this);
	using FunctionType = decltype(getStartColor())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x4bdb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setStartColor(cocos2d::_ccColor3B const& p0) -> decltype(setStartColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerGradient::setStartColor), this);
	using FunctionType = decltype(setStartColor(p0))(*)(cocos2d::CCLayerGradient*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x4bdba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::getEndColor() -> decltype(getEndColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getEndColor), this);
	using FunctionType = decltype(getEndColor())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x4bdbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setEndColor(cocos2d::_ccColor3B const& p0) -> decltype(setEndColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerGradient::setEndColor), this);
	using FunctionType = decltype(setEndColor(p0))(*)(cocos2d::CCLayerGradient*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x4bdbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::getStartOpacity() -> decltype(getStartOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getStartOpacity), this);
	using FunctionType = decltype(getStartOpacity())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x4bdc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setStartOpacity(unsigned char p0) -> decltype(setStartOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerGradient::setStartOpacity), this);
	using FunctionType = decltype(setStartOpacity(p0))(*)(cocos2d::CCLayerGradient*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x4bdc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::getEndOpacity() -> decltype(getEndOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getEndOpacity), this);
	using FunctionType = decltype(getEndOpacity())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x4bdc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setEndOpacity(unsigned char p0) -> decltype(setEndOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerGradient::setEndOpacity), this);
	using FunctionType = decltype(setEndOpacity(p0))(*)(cocos2d::CCLayerGradient*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x4bdc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::getVector() -> decltype(getVector()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getVector), this);
	using FunctionType = decltype(getVector())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x4bdc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setVector(cocos2d::CCPoint const& p0) -> decltype(setVector(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCLayerGradient::setVector), this);
	using FunctionType = decltype(setVector(p0))(*)(cocos2d::CCLayerGradient*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x4bdc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::setCompressedInterpolation(bool p0) -> decltype(setCompressedInterpolation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayerGradient::setCompressedInterpolation), this);
	using FunctionType = decltype(setCompressedInterpolation(p0))(*)(cocos2d::CCLayerGradient*, bool);
	static auto func = wrapFunction(base::get() + 0x4bdd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::isCompressedInterpolation() -> decltype(isCompressedInterpolation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::isCompressedInterpolation), this);
	using FunctionType = decltype(isCompressedInterpolation())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x4bdd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

cocos2d::CCObject::CCObject() {
	using FunctionType = void(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x493bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCObject::~CCObject() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x493d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCObject(geode::CutoffConstructor, sizeof(cocos2d::CCObject));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCObject::autorelease() -> decltype(autorelease()) {
	using FunctionType = decltype(autorelease())(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x493e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCObject::release() -> decltype(release()) {
	using FunctionType = decltype(release())(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x493e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCObject::retain() -> decltype(retain()) {
	using FunctionType = decltype(retain())(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x493e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCObject::getTag() const  -> decltype(getTag()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCObject::getTag), this);
	using FunctionType = decltype(getTag())(*)(cocos2d::CCObject const *);
	static auto func = wrapFunction(base::get() + 0x493eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCObject::isEqual(cocos2d::CCObject const* p0) -> decltype(isEqual(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject const*>::func(&cocos2d::CCObject::isEqual), this);
	using FunctionType = decltype(isEqual(p0))(*)(cocos2d::CCObject*, cocos2d::CCObject const*);
	static auto func = wrapFunction(base::get() + 0x493e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCObject::acceptVisitor(cocos2d::CCDataVisitor& p0) -> decltype(acceptVisitor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCDataVisitor&>::func(&cocos2d::CCObject::acceptVisitor), this);
	using FunctionType = decltype(acceptVisitor(p0))(*)(cocos2d::CCObject*, cocos2d::CCDataVisitor&);
	static auto func = wrapFunction(base::get() + 0x493e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&cocos2d::CCObject::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(cocos2d::CCObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x493ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCObject::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCObject::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x493ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCObject::setTag(int p0) -> decltype(setTag(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCObject::setTag), this);
	using FunctionType = decltype(setTag(p0))(*)(cocos2d::CCObject*, int);
	static auto func = wrapFunction(base::get() + 0x493ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCOrbitCamera::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCOrbitCamera::copyWithZone not implemented");
}

auto cocos2d::CCOrbitCamera::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCOrbitCamera::update not implemented");
}

auto cocos2d::CCOrbitCamera::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCOrbitCamera::startWithTarget not implemented");
}

auto cocos2d::CCLayerColor::create(cocos2d::_ccColor4B const& p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::_ccColor4B const&);
	static auto func = wrapFunction(base::get() + 0x4bcc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCLayerColor::create(cocos2d::_ccColor4B const& p0, float p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::_ccColor4B const&, float, float);
	static auto func = wrapFunction(base::get() + 0x4bca80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

cocos2d::CCLayerColor::CCLayerColor() {
	using FunctionType = void(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x4bc3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCLayerColor::~CCLayerColor() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x4bc600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLayerColor(geode::CutoffConstructor, sizeof(cocos2d::CCLayerColor));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLayerColor::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerColor::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x4bce00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerColor::setContentSize(cocos2d::CCSize const& p0) -> decltype(setContentSize(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSize const&>::func(&cocos2d::CCLayerColor::setContentSize), this);
	using FunctionType = decltype(setContentSize(p0))(*)(cocos2d::CCLayerColor*, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x4bcff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerColor::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x4bd130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerColor::initWithColor(cocos2d::_ccColor4B const& p0, float p1, float p2) -> decltype(initWithColor(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4B const&, float, float>::func(&cocos2d::CCLayerColor::initWithColor), this);
	using FunctionType = decltype(initWithColor(p0, p1, p2))(*)(cocos2d::CCLayerColor*, cocos2d::_ccColor4B const&, float, float);
	static auto func = wrapFunction(base::get() + 0x4bce50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCLayerColor::initWithColor(cocos2d::_ccColor4B const& p0) -> decltype(initWithColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4B const&>::func(&cocos2d::CCLayerColor::initWithColor), this);
	using FunctionType = decltype(initWithColor(p0))(*)(cocos2d::CCLayerColor*, cocos2d::_ccColor4B const&);
	static auto func = wrapFunction(base::get() + 0x4bcf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::updateColor() -> decltype(updateColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerColor::updateColor), this);
	using FunctionType = decltype(updateColor())(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x4bd0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerColor::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerColor::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCLayerColor*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x4bd200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerColor::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCLayerColor*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x4bd380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccBlendFunc>::func(&cocos2d::CCLayerColor::setBlendFunc), this);
	using FunctionType = decltype(setBlendFunc(p0))(*)(cocos2d::CCLayerColor*, cocos2d::_ccBlendFunc);
	static auto func = wrapFunction(base::get() + 0x4bc890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::getBlendFunc() -> decltype(getBlendFunc()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerColor::getBlendFunc), this);
	using FunctionType = decltype(getBlendFunc())(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x4bc870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

cocos2d::CCLayerRGBA::CCLayerRGBA() {
	using FunctionType = void(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bb5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCLayerRGBA::~CCLayerRGBA() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bb800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLayerRGBA(geode::CutoffConstructor, sizeof(cocos2d::CCLayerRGBA));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLayerRGBA::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bba70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerRGBA::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCLayerRGBA*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x4bbcb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::getColor() -> decltype(getColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::getColor), this);
	using FunctionType = decltype(getColor())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bbc70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::getDisplayedColor() -> decltype(getDisplayedColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::getDisplayedColor), this);
	using FunctionType = decltype(getDisplayedColor())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bbc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::getDisplayedOpacity() -> decltype(getDisplayedOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::getDisplayedOpacity), this);
	using FunctionType = decltype(getDisplayedOpacity())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bbb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bbaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerRGBA::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCLayerRGBA*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x4bbb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::isCascadeColorEnabled() -> decltype(isCascadeColorEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::isCascadeColorEnabled), this);
	using FunctionType = decltype(isCascadeColorEnabled())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bc210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::setCascadeColorEnabled(bool p0) -> decltype(setCascadeColorEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayerRGBA::setCascadeColorEnabled), this);
	using FunctionType = decltype(setCascadeColorEnabled(p0))(*)(cocos2d::CCLayerRGBA*, bool);
	static auto func = wrapFunction(base::get() + 0x4bc230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerRGBA::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(p0))(*)(cocos2d::CCLayerRGBA*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x4bbfb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::isCascadeOpacityEnabled() -> decltype(isCascadeOpacityEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::isCascadeOpacityEnabled), this);
	using FunctionType = decltype(isCascadeOpacityEnabled())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x4bc1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::setCascadeOpacityEnabled(bool p0) -> decltype(setCascadeOpacityEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayerRGBA::setCascadeOpacityEnabled), this);
	using FunctionType = decltype(setCascadeOpacityEnabled(p0))(*)(cocos2d::CCLayerRGBA*, bool);
	static auto func = wrapFunction(base::get() + 0x4bc1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerRGBA::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(p0))(*)(cocos2d::CCLayerRGBA*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x4bbe20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMouseDispatcher::dispatchScrollMSG(float p0, float p1) -> decltype(dispatchScrollMSG(p0, p1)) {
	using FunctionType = decltype(dispatchScrollMSG(p0, p1))(*)(cocos2d::CCMouseDispatcher*, float, float);
	static auto func = wrapFunction(base::get() + 0x578540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTexture2D::PVRImagesHavePremultipliedAlpha(bool p0) -> decltype(PVRImagesHavePremultipliedAlpha(p0)) {
	using FunctionType = decltype(PVRImagesHavePremultipliedAlpha(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x483620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCTexture2D::defaultAlphaPixelFormat() -> decltype(defaultAlphaPixelFormat()) {
	using FunctionType = decltype(defaultAlphaPixelFormat())(*)();
	static auto func = wrapFunction(base::get() + 0x4837f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCTexture2D::setDefaultAlphaPixelFormat(cocos2d::CCTexture2DPixelFormat p0) -> decltype(setDefaultAlphaPixelFormat(p0)) {
	using FunctionType = decltype(setDefaultAlphaPixelFormat(p0))(*)(cocos2d::CCTexture2DPixelFormat);
	static auto func = wrapFunction(base::get() + 0x4837e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCTexture2D::initPremultipliedATextureWithImage(cocos2d::CCImage* p0, unsigned int p1, unsigned int p2) -> decltype(initPremultipliedATextureWithImage(p0, p1, p2)) {
	using FunctionType = decltype(initPremultipliedATextureWithImage(p0, p1, p2))(*)(cocos2d::CCTexture2D*, cocos2d::CCImage*, unsigned int, unsigned int);
	static auto func = wrapFunction(base::get() + 0x4827a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTexture2D::initWithData(void const* p0, cocos2d::CCTexture2DPixelFormat p1, unsigned int p2, unsigned int p3, cocos2d::CCSize const& p4) -> decltype(initWithData(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithData(p0, p1, p2, p3, p4))(*)(cocos2d::CCTexture2D*, void const*, cocos2d::CCTexture2DPixelFormat, unsigned int, unsigned int, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x4823e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCTexture2D::initWithETCFile(char const* p0) -> decltype(initWithETCFile(p0)) {
	using FunctionType = decltype(initWithETCFile(p0))(*)(cocos2d::CCTexture2D*, char const*);
	static auto func = wrapFunction(base::get() + 0x483550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::initWithImage(cocos2d::CCImage* p0) -> decltype(initWithImage(p0)) {
	using FunctionType = decltype(initWithImage(p0))(*)(cocos2d::CCTexture2D*, cocos2d::CCImage*);
	static auto func = wrapFunction(base::get() + 0x482740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::initWithPVRFile(char const* p0) -> decltype(initWithPVRFile(p0)) {
	using FunctionType = decltype(initWithPVRFile(p0))(*)(cocos2d::CCTexture2D*, char const*);
	static auto func = wrapFunction(base::get() + 0x483470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::initWithString(char const* p0, char const* p1, float p2) -> decltype(initWithString(p0, p1, p2)) {
	using FunctionType = decltype(initWithString(p0, p1, p2))(*)(cocos2d::CCTexture2D*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x4830c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTexture2D::initWithString(char const* p0, char const* p1, float p2, cocos2d::CCSize const& p3, cocos2d::CCTextAlignment p4, cocos2d::CCVerticalTextAlignment p5) -> decltype(initWithString(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(initWithString(p0, p1, p2, p3, p4, p5))(*)(cocos2d::CCTexture2D*, char const*, char const*, float, cocos2d::CCSize const&, cocos2d::CCTextAlignment, cocos2d::CCVerticalTextAlignment);
	static auto func = wrapFunction(base::get() + 0x483120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto cocos2d::CCTexture2D::initWithString(char const* p0, cocos2d::_ccFontDefinition* p1) -> decltype(initWithString(p0, p1)) {
	using FunctionType = decltype(initWithString(p0, p1))(*)(cocos2d::CCTexture2D*, char const*, cocos2d::_ccFontDefinition*);
	static auto func = wrapFunction(base::get() + 0x483260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTexture2D::getContentSizeInPixels() -> decltype(getContentSizeInPixels()) {
	using FunctionType = decltype(getContentSizeInPixels())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x4822e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::setAliasTexParameters() -> decltype(setAliasTexParameters()) {
	using FunctionType = decltype(setAliasTexParameters())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x483710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::setAntiAliasTexParameters() -> decltype(setAntiAliasTexParameters()) {
	using FunctionType = decltype(setAntiAliasTexParameters())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x483760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::setTexParameters(cocos2d::_ccTexParams* p0) -> decltype(setTexParameters(p0)) {
	using FunctionType = decltype(setTexParameters(p0))(*)(cocos2d::CCTexture2D*, cocos2d::_ccTexParams*);
	static auto func = wrapFunction(base::get() + 0x483680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCTexture2D::~CCTexture2D() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x4821e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCTexture2D(geode::CutoffConstructor, sizeof(cocos2d::CCTexture2D));
	CCDestructor::lock(this) = true;
}

cocos2d::CCTexture2D::CCTexture2D() {
	using FunctionType = void(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x4820e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::bitsPerPixelForFormat(cocos2d::CCTexture2DPixelFormat p0) -> decltype(bitsPerPixelForFormat(p0)) {
	using FunctionType = decltype(bitsPerPixelForFormat(p0))(*)(cocos2d::CCTexture2D*, cocos2d::CCTexture2DPixelFormat);
	static auto func = wrapFunction(base::get() + 0x4826e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::bitsPerPixelForFormat() -> decltype(bitsPerPixelForFormat()) {
	using FunctionType = decltype(bitsPerPixelForFormat())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x483800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::description() -> decltype(description()) {
	using FunctionType = decltype(description())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::drawAtPoint(cocos2d::CCPoint const& p0) -> decltype(drawAtPoint(p0)) {
	using FunctionType = decltype(drawAtPoint(p0))(*)(cocos2d::CCTexture2D*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x483270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::drawInRect(cocos2d::CCRect const& p0) -> decltype(drawInRect(p0)) {
	using FunctionType = decltype(drawInRect(p0))(*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x483380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::generateMipmap() -> decltype(generateMipmap()) {
	using FunctionType = decltype(generateMipmap())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x483630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::hasMipmaps() -> decltype(hasMipmaps()) {
	using FunctionType = decltype(hasMipmaps())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x483670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::hasPremultipliedAlpha() -> decltype(hasPremultipliedAlpha()) {
	using FunctionType = decltype(hasPremultipliedAlpha())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x4823d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::keepData(void* p0, unsigned int p1) -> decltype(keepData(p0, p1)) {
	using FunctionType = decltype(keepData(p0, p1))(*)(cocos2d::CCTexture2D*, void*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x4823c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTexture2D::releaseData(void* p0) -> decltype(releaseData(p0)) {
	using FunctionType = decltype(releaseData(p0))(*)(cocos2d::CCTexture2D*, void*);
	static auto func = wrapFunction(base::get() + 0x4823b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::releaseGLTexture() -> decltype(releaseGLTexture()) {
	using FunctionType = decltype(releaseGLTexture())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::stringForFormat() -> decltype(stringForFormat()) {
	using FunctionType = decltype(stringForFormat())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x4837b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::getPixelFormat() -> decltype(getPixelFormat()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getPixelFormat), this);
	using FunctionType = decltype(getPixelFormat())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getPixelsWide() -> decltype(getPixelsWide()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getPixelsWide), this);
	using FunctionType = decltype(getPixelsWide())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getPixelsHigh() -> decltype(getPixelsHigh()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getPixelsHigh), this);
	using FunctionType = decltype(getPixelsHigh())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getName() -> decltype(getName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getName), this);
	using FunctionType = decltype(getName())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getMaxS() -> decltype(getMaxS()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getMaxS), this);
	using FunctionType = decltype(getMaxS())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x4822f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::setMaxS(float p0) -> decltype(setMaxS(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCTexture2D::setMaxS), this);
	using FunctionType = decltype(setMaxS(p0))(*)(cocos2d::CCTexture2D*, float);
	static auto func = wrapFunction(base::get() + 0x482300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCTexture2D::getMaxT() -> decltype(getMaxT()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getMaxT), this);
	using FunctionType = decltype(getMaxT())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::setMaxT(float p0) -> decltype(setMaxT(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCTexture2D::setMaxT), this);
	using FunctionType = decltype(setMaxT(p0))(*)(cocos2d::CCTexture2D*, float);
	static auto func = wrapFunction(base::get() + 0x482320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCTexture2D::getContentSize() -> decltype(getContentSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getContentSize), this);
	using FunctionType = decltype(getContentSize())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getShaderProgram() -> decltype(getShaderProgram()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getShaderProgram), this);
	using FunctionType = decltype(getShaderProgram())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x482330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::setShaderProgram(cocos2d::CCGLProgram* p0) -> decltype(setShaderProgram(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCGLProgram*>::func(&cocos2d::CCTexture2D::setShaderProgram), this);
	using FunctionType = decltype(setShaderProgram(p0))(*)(cocos2d::CCTexture2D*, cocos2d::CCGLProgram*);
	static auto func = wrapFunction(base::get() + 0x482340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCTextureCache::sharedTextureCache() -> decltype(sharedTextureCache()) {
	using FunctionType = decltype(sharedTextureCache())(*)();
	static auto func = wrapFunction(base::get() + 0x5f61d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCTextureCache::addImage(char const* p0, bool p1) -> decltype(addImage(p0, p1)) {
	using FunctionType = decltype(addImage(p0, p1))(*)(cocos2d::CCTextureCache*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x5f7450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTextureCache::addImageAsync(char const* p0, cocos2d::CCObject* p1, cocos2d::SEL_MenuHandler p2, int p3, cocos2d::CCTexture2DPixelFormat p4) -> decltype(addImageAsync(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(addImageAsync(p0, p1, p2, p3, p4))(*)(cocos2d::CCTextureCache*, char const*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler, int, cocos2d::CCTexture2DPixelFormat);
	static auto func = wrapFunction(base::get() + 0x5f6650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCTextureCache::addUIImage(cocos2d::CCImage* p0, char const* p1) -> decltype(addUIImage(p0, p1)) {
	using FunctionType = decltype(addUIImage(p0, p1))(*)(cocos2d::CCTextureCache*, cocos2d::CCImage*, char const*);
	static auto func = wrapFunction(base::get() + 0x5f8250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTextureCache::textureForKey(char const* p0) -> decltype(textureForKey(p0)) {
	using FunctionType = decltype(textureForKey(p0))(*)(cocos2d::CCTextureCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x5f8850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouch::getLocation() const  -> decltype(getLocation()) {
	using FunctionType = decltype(getLocation())(*)(cocos2d::CCTouch const *);
	static auto func = wrapFunction(base::get() + 0x5a550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouch::getPreviousLocation() const  -> decltype(getPreviousLocation()) {
	using FunctionType = decltype(getPreviousLocation())(*)(cocos2d::CCTouch const *);
	static auto func = wrapFunction(base::get() + 0x5a580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouch::getStartLocation() const  -> decltype(getStartLocation()) {
	using FunctionType = decltype(getStartLocation())(*)(cocos2d::CCTouch const *);
	static auto func = wrapFunction(base::get() + 0x5a5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouch::getDelta() const  -> decltype(getDelta()) {
	using FunctionType = decltype(getDelta())(*)(cocos2d::CCTouch const *);
	static auto func = wrapFunction(base::get() + 0x5a5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void cocos2d::CCTouchDelegate::setPreviousPriority(int p0) {}

int cocos2d::CCTouchDelegate::getPreviousPriority() { return 0; }

auto cocos2d::CCTouchDispatcher::setDispatchEvents(bool p0) -> decltype(setDispatchEvents(p0)) {
	using FunctionType = decltype(setDispatchEvents(p0))(*)(cocos2d::CCTouchDispatcher*, bool);
	static auto func = wrapFunction(base::get() + 0x4d56d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouchDispatcher::setPriority(int p1, cocos2d::CCTouchDelegate* p2) -> decltype(setPriority(p1, p2)) {
	using FunctionType = decltype(setPriority(p1, p2))(*)(cocos2d::CCTouchDispatcher*, int, cocos2d::CCTouchDelegate*);
	static auto func = wrapFunction(base::get() + 0x4d6130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p1, p2);
}

auto cocos2d::CCTouchDispatcher::addPrioTargetedDelegate(cocos2d::CCTouchDelegate* p0, int p1, bool p2) -> decltype(addPrioTargetedDelegate(p0, p1, p2)) {
	using FunctionType = decltype(addPrioTargetedDelegate(p0, p1, p2))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCTouchDelegate*, int, bool);
	static auto func = wrapFunction(base::get() + 0x4d5990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTouchDispatcher::addTargetedDelegate(cocos2d::CCTouchDelegate* p0, int p1, bool p2) -> decltype(addTargetedDelegate(p0, p1, p2)) {
	using FunctionType = decltype(addTargetedDelegate(p0, p1, p2))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCTouchDelegate*, int, bool);
	static auto func = wrapFunction(base::get() + 0x4d59b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTouchDispatcher::findHandler(cocos2d::CCTouchDelegate* p0) -> decltype(findHandler(p0)) {
	using FunctionType = decltype(findHandler(p0))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCTouchDelegate*);
	static auto func = wrapFunction(base::get() + 0x4d5fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouchDispatcher::isUsingForcePrio() -> decltype(isUsingForcePrio()) {
	using FunctionType = decltype(isUsingForcePrio())(*)(cocos2d::CCTouchDispatcher*);
	static auto func = wrapFunction(base::get() + 0x4d5980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouchDispatcher::registerForcePrio(cocos2d::CCObject* p0, int p1) -> decltype(registerForcePrio(p0, p1)) {
	using FunctionType = decltype(registerForcePrio(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCObject*, int);
	static auto func = wrapFunction(base::get() + 0x4d5890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTouchDispatcher::touches(cocos2d::CCSet* p0, cocos2d::CCEvent* p1, unsigned int p2) -> decltype(touches(p0, p1, p2)) {
	using FunctionType = decltype(touches(p0, p1, p2))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x4d62a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTouchDispatcher::unregisterForcePrio(cocos2d::CCObject* p0) -> decltype(unregisterForcePrio(p0)) {
	using FunctionType = decltype(unregisterForcePrio(p0))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4d5930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouchDispatcher::touchesBegan(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(touchesBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCTouchDispatcher::touchesBegan), this);
	using FunctionType = decltype(touchesBegan(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d68e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTouchDispatcher::touchesMoved(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(touchesMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCTouchDispatcher::touchesMoved), this);
	using FunctionType = decltype(touchesMoved(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d6920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTouchDispatcher::touchesEnded(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(touchesEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCTouchDispatcher::touchesEnded), this);
	using FunctionType = decltype(touchesEnded(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d6960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTouchDispatcher::touchesCancelled(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(touchesCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCTouchDispatcher::touchesCancelled), this);
	using FunctionType = decltype(touchesCancelled(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d69a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTouchHandler::getDelegate() -> decltype(getDelegate()) {
	using FunctionType = decltype(getDelegate())(*)(cocos2d::CCTouchHandler*);
	static auto func = wrapFunction(base::get() + 0x48a010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouchHandler::getPriority() -> decltype(getPriority()) {
	using FunctionType = decltype(getPriority())(*)(cocos2d::CCTouchHandler*);
	static auto func = wrapFunction(base::get() + 0x48a090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouchHandler::initWithDelegate(cocos2d::CCTouchDelegate* p0, int p1) -> decltype(initWithDelegate(p0, p1)) {
	throw std::runtime_error("cocos2d::CCTouchHandler::initWithDelegate not implemented");
}

auto cocos2d::CCEGLView::swapBuffers() -> decltype(swapBuffers()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCEGLView::swapBuffers), this);
	using FunctionType = decltype(swapBuffers())(*)(cocos2d::CCEGLView*);
	static auto func = wrapFunction(base::get() + 0x50e130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCImage::initWithImageData(void* p0, int p1, cocos2d::CCImage::EImageFormat p2, int p3, int p4, int p5, int p6) -> decltype(initWithImageData(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(initWithImageData(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCImage*, void*, int, cocos2d::CCImage::EImageFormat, int, int, int, int);
	static auto func = wrapFunction(base::get() + 0x492d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto cocos2d::CCImage::initWithImageFile(char const* p0, cocos2d::CCImage::EImageFormat p1) -> decltype(initWithImageFile(p0, p1)) {
	using FunctionType = decltype(initWithImageFile(p0, p1))(*)(cocos2d::CCImage*, char const*, cocos2d::CCImage::EImageFormat);
	static auto func = wrapFunction(base::get() + 0x492b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

cocos2d::CCImage::CCImage() {
	using FunctionType = void(*)(cocos2d::CCImage*);
	static auto func = wrapFunction(base::get() + 0x492a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCImage::~CCImage() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCImage*);
	static auto func = wrapFunction(base::get() + 0x492af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCImage(geode::CutoffConstructor, sizeof(cocos2d::CCImage));
	CCDestructor::lock(this) = true;
}

cocos2d::CCIMEDelegate::~CCIMEDelegate() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCIMEDelegate*);
	static auto func = wrapFunction(base::get() + 0x4c5c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCIMEDelegate(geode::CutoffConstructor, sizeof(cocos2d::CCIMEDelegate));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCIMEDelegate::attachWithIME() -> decltype(attachWithIME()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCIMEDelegate::attachWithIME), this);
	using FunctionType = decltype(attachWithIME())(*)(cocos2d::CCIMEDelegate*);
	static auto func = wrapFunction(base::get() + 0x4c5c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCIMEDelegate::detachWithIME() -> decltype(detachWithIME()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCIMEDelegate::detachWithIME), this);
	using FunctionType = decltype(detachWithIME())(*)(cocos2d::CCIMEDelegate*);
	static auto func = wrapFunction(base::get() + 0x4c5e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void cocos2d::CCIMEDelegate::deleteForward() {}

auto cocos2d::CCIMEDispatcher::dispatchDeleteBackward() -> decltype(dispatchDeleteBackward()) {
	using FunctionType = decltype(dispatchDeleteBackward())(*)(cocos2d::CCIMEDispatcher*);
	static auto func = wrapFunction(base::get() + 0x4c6140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCIMEDispatcher::dispatchDeleteForward() -> decltype(dispatchDeleteForward()) {
	using FunctionType = decltype(dispatchDeleteForward())(*)(cocos2d::CCIMEDispatcher*);
	static auto func = wrapFunction(base::get() + 0x4c6160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCIMEDispatcher::dispatchInsertText(char const* p0, int p1, cocos2d::enumKeyCodes p2) -> decltype(dispatchInsertText(p0, p1, p2)) {
	using FunctionType = decltype(dispatchInsertText(p0, p1, p2))(*)(cocos2d::CCIMEDispatcher*, char const*, int, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4c6110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCKeyboardDispatcher::dispatchKeyboardMSG(cocos2d::enumKeyCodes p0, bool p1, bool p2) -> decltype(dispatchKeyboardMSG(p0, p1, p2)) {
	using FunctionType = decltype(dispatchKeyboardMSG(p0, p1, p2))(*)(cocos2d::CCKeyboardDispatcher*, cocos2d::enumKeyCodes, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1fdbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCKeyboardDispatcher::updateModifierKeys(bool p0, bool p1, bool p2, bool p3) -> decltype(updateModifierKeys(p0, p1, p2, p3)) {
	using FunctionType = decltype(updateModifierKeys(p0, p1, p2, p3))(*)(cocos2d::CCKeyboardDispatcher*, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1fde80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto cocos2d::CCDirector::sharedDirector() -> decltype(sharedDirector()) {
	using FunctionType = decltype(sharedDirector())(*)();
	static auto func = wrapFunction(base::get() + 0x48b350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCDirector::getWinSize() -> decltype(getWinSize()) {
	using FunctionType = decltype(getWinSize())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x48c750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::convertToGL(cocos2d::CCPoint const& p0) -> decltype(convertToGL(p0)) {
	using FunctionType = decltype(convertToGL(p0))(*)(cocos2d::CCDirector*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x48cc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::drawScene() -> decltype(drawScene()) {
	using FunctionType = decltype(drawScene())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x48bcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::popSceneWithTransition(float p0, cocos2d::PopTransition p1) -> decltype(popSceneWithTransition(p0, p1)) {
	using FunctionType = decltype(popSceneWithTransition(p0, p1))(*)(cocos2d::CCDirector*, float, cocos2d::PopTransition);
	static auto func = wrapFunction(base::get() + 0x48d2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCDirector::pushScene(cocos2d::CCScene* p0) -> decltype(pushScene(p0)) {
	using FunctionType = decltype(pushScene(p0))(*)(cocos2d::CCDirector*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x48d060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::replaceScene(cocos2d::CCScene* p0) -> decltype(replaceScene(p0)) {
	using FunctionType = decltype(replaceScene(p0))(*)(cocos2d::CCDirector*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x48d110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::willSwitchToScene(cocos2d::CCScene* p0) -> decltype(willSwitchToScene(p0)) {
	using FunctionType = decltype(willSwitchToScene(p0))(*)(cocos2d::CCDirector*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x48cf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::init() -> decltype(init()) {
	throw std::runtime_error("cocos2d::CCDirector::init not implemented");
}

auto cocos2d::CCDirector::getScheduler() -> decltype(getScheduler()) {
	throw std::runtime_error("cocos2d::CCDirector::getScheduler not implemented");
}

auto cocos2d::CCDirector::setScheduler(cocos2d::CCScheduler* p0) -> decltype(setScheduler(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setScheduler not implemented");
}

auto cocos2d::CCDirector::getActionManager() -> decltype(getActionManager()) {
	throw std::runtime_error("cocos2d::CCDirector::getActionManager not implemented");
}

auto cocos2d::CCDirector::setActionManager(cocos2d::CCActionManager* p0) -> decltype(setActionManager(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setActionManager not implemented");
}

auto cocos2d::CCDirector::getTouchDispatcher() -> decltype(getTouchDispatcher()) {
	throw std::runtime_error("cocos2d::CCDirector::getTouchDispatcher not implemented");
}

auto cocos2d::CCDirector::setTouchDispatcher(cocos2d::CCTouchDispatcher* p0) -> decltype(setTouchDispatcher(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setTouchDispatcher not implemented");
}

auto cocos2d::CCDirector::getKeypadDispatcher() -> decltype(getKeypadDispatcher()) {
	throw std::runtime_error("cocos2d::CCDirector::getKeypadDispatcher not implemented");
}

auto cocos2d::CCDirector::setKeypadDispatcher(cocos2d::CCKeypadDispatcher* p0) -> decltype(setKeypadDispatcher(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setKeypadDispatcher not implemented");
}

auto cocos2d::CCDirector::getKeyboardDispatcher() -> decltype(getKeyboardDispatcher()) {
	throw std::runtime_error("cocos2d::CCDirector::getKeyboardDispatcher not implemented");
}

auto cocos2d::CCDirector::setKeyboardDispatcher(cocos2d::CCKeyboardDispatcher* p0) -> decltype(setKeyboardDispatcher(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setKeyboardDispatcher not implemented");
}

auto cocos2d::CCDirector::getMouseDispatcher() -> decltype(getMouseDispatcher()) {
	throw std::runtime_error("cocos2d::CCDirector::getMouseDispatcher not implemented");
}

auto cocos2d::CCDirector::setMouseDispatcher(cocos2d::CCMouseDispatcher* p0) -> decltype(setMouseDispatcher(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setMouseDispatcher not implemented");
}

auto cocos2d::CCDirector::getAccelerometer() -> decltype(getAccelerometer()) {
	throw std::runtime_error("cocos2d::CCDirector::getAccelerometer not implemented");
}

auto cocos2d::CCDirector::setAccelerometer(cocos2d::CCAccelerometer* p0) -> decltype(setAccelerometer(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setAccelerometer not implemented");
}

auto cocos2d::CCDirector::getDeltaTime() -> decltype(getDeltaTime()) {
	throw std::runtime_error("cocos2d::CCDirector::getDeltaTime not implemented");
}

cocos2d::CCNodeRGBA::CCNodeRGBA() {
	using FunctionType = void(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x271180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCNodeRGBA::~CCNodeRGBA() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2711e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCNodeRGBA(geode::CutoffConstructor, sizeof(cocos2d::CCNodeRGBA));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCNodeRGBA::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x271210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCNodeRGBA::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCNodeRGBA*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x271630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::getColor() -> decltype(getColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::getColor), this);
	using FunctionType = decltype(getColor())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2715f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::getDisplayedColor() -> decltype(getDisplayedColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::getDisplayedColor), this);
	using FunctionType = decltype(getDisplayedColor())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x271610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::getDisplayedOpacity() -> decltype(getDisplayedOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::getDisplayedOpacity), this);
	using FunctionType = decltype(getDisplayedOpacity())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2712c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2712a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCNodeRGBA::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCNodeRGBA*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x2712e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::isCascadeColorEnabled() -> decltype(isCascadeColorEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::isCascadeColorEnabled), this);
	using FunctionType = decltype(isCascadeColorEnabled())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2719c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::setCascadeColorEnabled(bool p0) -> decltype(setCascadeColorEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNodeRGBA::setCascadeColorEnabled), this);
	using FunctionType = decltype(setCascadeColorEnabled(p0))(*)(cocos2d::CCNodeRGBA*, bool);
	static auto func = wrapFunction(base::get() + 0x2719e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCNodeRGBA::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(p0))(*)(cocos2d::CCNodeRGBA*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x2717a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::isCascadeOpacityEnabled() -> decltype(isCascadeOpacityEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::isCascadeOpacityEnabled), this);
	using FunctionType = decltype(isCascadeOpacityEnabled())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2715b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::setCascadeOpacityEnabled(bool p0) -> decltype(setCascadeOpacityEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNodeRGBA::setCascadeOpacityEnabled), this);
	using FunctionType = decltype(setCascadeOpacityEnabled(p0))(*)(cocos2d::CCNodeRGBA*, bool);
	static auto func = wrapFunction(base::get() + 0x2715d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCNodeRGBA::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(p0))(*)(cocos2d::CCNodeRGBA*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x271420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSequence::create(cocos2d::CCArray* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3b8e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSequence::createWithVariableList(cocos2d::CCFiniteTimeAction* p0, va_list p1) -> decltype(createWithVariableList(p0, p1)) {
	using FunctionType = decltype(createWithVariableList(p0, p1))(*)(cocos2d::CCFiniteTimeAction*, va_list);
	static auto func = wrapFunction(base::get() + 0x3b8b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCSequence::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCSequence::copyWithZone not implemented");
}

auto cocos2d::CCSequence::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCSequence::update not implemented");
}

auto cocos2d::CCSequence::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCSequence::startWithTarget not implemented");
}

auto cocos2d::CCSequence::stop() -> decltype(stop()) {
	throw std::runtime_error("cocos2d::CCSequence::stop not implemented");
}

auto cocos2d::CCSequence::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCSequence::reverse not implemented");
}

auto cocos2d::CCSprite::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x2843b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2846b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCSprite::createWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(createWithSpriteFrame(p0)) {
	using FunctionType = decltype(createWithSpriteFrame(p0))(*)(cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x284590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSprite::createWithSpriteFrameName(char const* p0) -> decltype(createWithSpriteFrameName(p0)) {
	using FunctionType = decltype(createWithSpriteFrameName(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x284680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSprite::createWithTexture(cocos2d::CCTexture2D* p0) -> decltype(createWithTexture(p0)) {
	using FunctionType = decltype(createWithTexture(p0))(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x284130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSprite::createWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(createWithTexture(p0, p1)) {
	using FunctionType = decltype(createWithTexture(p0, p1))(*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x2842c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCSprite::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	using FunctionType = decltype(setFlipX(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x286360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSprite::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	using FunctionType = decltype(setFlipY(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x2863b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCSprite::CCSprite() {
	using FunctionType = void(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x284b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCSprite::~CCSprite() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x284c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCSprite(geode::CutoffConstructor, sizeof(cocos2d::CCSprite));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCSprite::isFlipX() -> decltype(isFlipX()) {
	using FunctionType = decltype(isFlipX())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x2863a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSprite::isFlipY() -> decltype(isFlipY()) {
	using FunctionType = decltype(isFlipY())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x2863f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x284790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setVertexZ(float p0) -> decltype(setVertexZ(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setVertexZ), this);
	using FunctionType = decltype(setVertexZ(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x286200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x2860a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x286110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x286180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCSprite::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(cocos2d::CCSprite*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x285df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setSkewX(float p0) -> decltype(setSkewX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setSkewX), this);
	using FunctionType = decltype(setSkewX(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x285fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setSkewY(float p0) -> decltype(setSkewY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setSkewY), this);
	using FunctionType = decltype(setSkewY(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x286030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setAnchorPoint(cocos2d::CCPoint const& p0) -> decltype(setAnchorPoint(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCSprite::setAnchorPoint), this);
	using FunctionType = decltype(setAnchorPoint(p0))(*)(cocos2d::CCSprite*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x286270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x2862f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x285e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x285ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x285f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::ignoreAnchorPointForPosition(bool p0) -> decltype(ignoreAnchorPointForPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::ignoreAnchorPointForPosition), this);
	using FunctionType = decltype(ignoreAnchorPointForPosition(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x2862e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::addChild(cocos2d::CCNode* p0) -> decltype(addChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCSprite::addChild), this);
	using FunctionType = decltype(addChild(p0))(*)(cocos2d::CCSprite*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x285930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::addChild(cocos2d::CCNode* p0, int p1) -> decltype(addChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCSprite::addChild), this);
	using FunctionType = decltype(addChild(p0, p1))(*)(cocos2d::CCSprite*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x285940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::addChild(cocos2d::CCNode* p0, int p1, int p2) -> decltype(addChild(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int, int>::func(&cocos2d::CCSprite::addChild), this);
	using FunctionType = decltype(addChild(p0, p1, p2))(*)(cocos2d::CCSprite*, cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x285950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCSprite::removeChild(cocos2d::CCNode* p0, bool p1) -> decltype(removeChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, bool>::func(&cocos2d::CCSprite::removeChild), this);
	using FunctionType = decltype(removeChild(p0, p1))(*)(cocos2d::CCSprite*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x285a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::removeAllChildrenWithCleanup(bool p0) -> decltype(removeAllChildrenWithCleanup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::removeAllChildrenWithCleanup), this);
	using FunctionType = decltype(removeAllChildrenWithCleanup(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x285ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::reorderChild(cocos2d::CCNode* p0, int p1) -> decltype(reorderChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCSprite::reorderChild), this);
	using FunctionType = decltype(reorderChild(p0, p1))(*)(cocos2d::CCSprite*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x285a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::sortAllChildren() -> decltype(sortAllChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::sortAllChildren), this);
	using FunctionType = decltype(sortAllChildren())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x285b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x285810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::updateTransform() -> decltype(updateTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::updateTransform), this);
	using FunctionType = decltype(updateTransform())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x285350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&cocos2d::CCSprite::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(cocos2d::CCSprite*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x284950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(initWithTexture(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&>::func(&cocos2d::CCSprite::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1))(*)(cocos2d::CCSprite*, cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x284930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) -> decltype(initWithTexture(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool>::func(&cocos2d::CCSprite::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1, p2))(*)(cocos2d::CCSprite*, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool);
	static auto func = wrapFunction(base::get() + 0x2847b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCSprite::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(initWithSpriteFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&cocos2d::CCSprite::initWithSpriteFrame), this);
	using FunctionType = decltype(initWithSpriteFrame(p0))(*)(cocos2d::CCSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x284ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::initWithSpriteFrameName(char const* p0) -> decltype(initWithSpriteFrameName(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCSprite::initWithSpriteFrameName), this);
	using FunctionType = decltype(initWithSpriteFrameName(p0))(*)(cocos2d::CCSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x284b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::initWithFile(char const* p0) -> decltype(initWithFile(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCSprite::initWithFile), this);
	using FunctionType = decltype(initWithFile(p0))(*)(cocos2d::CCSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x2849c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::initWithFile(char const* p0, cocos2d::CCRect const& p1) -> decltype(initWithFile(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, cocos2d::CCRect const&>::func(&cocos2d::CCSprite::initWithFile), this);
	using FunctionType = decltype(initWithFile(p0, p1))(*)(cocos2d::CCSprite*, char const*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x284a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::setChildColor(cocos2d::_ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCSprite::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(cocos2d::CCSprite*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x286900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setChildOpacity(unsigned char p0) -> decltype(setChildOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCSprite::setChildOpacity), this);
	using FunctionType = decltype(setChildOpacity(p0))(*)(cocos2d::CCSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x2866d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::getBatchNode() -> decltype(getBatchNode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::getBatchNode), this);
	using FunctionType = decltype(getBatchNode())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x2870f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setBatchNode(cocos2d::CCSpriteBatchNode* p0) -> decltype(setBatchNode(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteBatchNode*>::func(&cocos2d::CCSprite::setBatchNode), this);
	using FunctionType = decltype(setBatchNode(p0))(*)(cocos2d::CCSprite*, cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x287100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::refreshTextureRect() -> decltype(refreshTextureRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::refreshTextureRect), this);
	using FunctionType = decltype(refreshTextureRect())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x284d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setTextureRect(cocos2d::CCRect const& p0) -> decltype(setTextureRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect const&>::func(&cocos2d::CCSprite::setTextureRect), this);
	using FunctionType = decltype(setTextureRect(p0))(*)(cocos2d::CCSprite*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x284d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setTextureRect(cocos2d::CCRect const& p0, bool p1, cocos2d::CCSize const& p2) -> decltype(setTextureRect(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect const&, bool, cocos2d::CCSize const&>::func(&cocos2d::CCSprite::setTextureRect), this);
	using FunctionType = decltype(setTextureRect(p0, p1, p2))(*)(cocos2d::CCSprite*, cocos2d::CCRect const&, bool, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x284db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCSprite::setVertexRect(cocos2d::CCRect const& p0) -> decltype(setVertexRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect const&>::func(&cocos2d::CCSprite::setVertexRect), this);
	using FunctionType = decltype(setVertexRect(p0))(*)(cocos2d::CCSprite*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x2850f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setDisplayFrame(cocos2d::CCSpriteFrame* p0) -> decltype(setDisplayFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&cocos2d::CCSprite::setDisplayFrame), this);
	using FunctionType = decltype(setDisplayFrame(p0))(*)(cocos2d::CCSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x286de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::isFrameDisplayed(cocos2d::CCSpriteFrame* p0) -> decltype(isFrameDisplayed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&cocos2d::CCSprite::isFrameDisplayed), this);
	using FunctionType = decltype(isFrameDisplayed(p0))(*)(cocos2d::CCSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x286eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::displayFrame() -> decltype(displayFrame()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::displayFrame), this);
	using FunctionType = decltype(displayFrame())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x286f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setDisplayFrameWithAnimationName(char const* p0, int p1) -> decltype(setDisplayFrameWithAnimationName(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&cocos2d::CCSprite::setDisplayFrameWithAnimationName), this);
	using FunctionType = decltype(setDisplayFrameWithAnimationName(p0, p1))(*)(cocos2d::CCSprite*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x286e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::setTextureCoords(cocos2d::CCRect const& p0) -> decltype(setTextureCoords(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect const&>::func(&cocos2d::CCSprite::setTextureCoords), this);
	using FunctionType = decltype(setTextureCoords(p0))(*)(cocos2d::CCSprite*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x285110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::updateBlendFunc() -> decltype(updateBlendFunc()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::updateBlendFunc), this);
	using FunctionType = decltype(updateBlendFunc())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x287170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setReorderChildDirtyRecursively() -> decltype(setReorderChildDirtyRecursively()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::setReorderChildDirtyRecursively), this);
	using FunctionType = decltype(setReorderChildDirtyRecursively())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x285d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setDirtyRecursively(bool p0) -> decltype(setDirtyRecursively(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::setDirtyRecursively), this);
	using FunctionType = decltype(setDirtyRecursively(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x285d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x286520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCSprite::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(p0))(*)(cocos2d::CCSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x286c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCSprite::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCSprite*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x286780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCSprite::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(p0))(*)(cocos2d::CCSprite*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x286b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::setOpacityModifyRGB), this);
	using FunctionType = decltype(setOpacityModifyRGB(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x2869b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::isOpacityModifyRGB), this);
	using FunctionType = decltype(isOpacityModifyRGB())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x286b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&cocos2d::CCSprite::setTexture), this);
	using FunctionType = decltype(setTexture(p0))(*)(cocos2d::CCSprite*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x2871d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::getTexture() -> decltype(getTexture()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::getTexture), this);
	using FunctionType = decltype(getTexture())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x287340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::create(char const* p0, char const* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x5e0fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCLabelBMFont::create(char const* p0, char const* p1, float p2, cocos2d::CCTextAlignment p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(char const*, char const*, float, cocos2d::CCTextAlignment);
	static auto func = wrapFunction(base::get() + 0x5e0ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto cocos2d::CCLabelBMFont::create(char const* p0, char const* p1, float p2, cocos2d::CCTextAlignment p3, cocos2d::CCPoint p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(char const*, char const*, float, cocos2d::CCTextAlignment, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x5e0e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto cocos2d::CCLabelBMFont::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x5e0d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCLabelBMFont::setFntFile(char const* p0) -> decltype(setFntFile(p0)) {
	using FunctionType = decltype(setFntFile(p0))(*)(cocos2d::CCLabelBMFont*, char const*);
	static auto func = wrapFunction(base::get() + 0x5e4670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCLabelBMFont::createFontChars() -> decltype(createFontChars()) {
	using FunctionType = decltype(createFontChars())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e1780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCLabelBMFont::limitLabelWidth(float p0, float p1, float p2) -> decltype(limitLabelWidth(p0, p1, p2)) {
	using FunctionType = decltype(limitLabelWidth(p0, p1, p2))(*)(cocos2d::CCLabelBMFont*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x5e4790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

cocos2d::CCLabelBMFont::~CCLabelBMFont() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e1630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLabelBMFont(geode::CutoffConstructor, sizeof(cocos2d::CCLabelBMFont));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLabelBMFont::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e13d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCLabelBMFont::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(cocos2d::CCLabelBMFont*, float);
	static auto func = wrapFunction(base::get() + 0x5e4630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCLabelBMFont::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(cocos2d::CCLabelBMFont*, float);
	static auto func = wrapFunction(base::get() + 0x5e4650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCLabelBMFont::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(cocos2d::CCLabelBMFont*, float);
	static auto func = wrapFunction(base::get() + 0x5e4610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setAnchorPoint(cocos2d::CCPoint const& p0) -> decltype(setAnchorPoint(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCLabelBMFont::setAnchorPoint), this);
	using FunctionType = decltype(setAnchorPoint(p0))(*)(cocos2d::CCLabelBMFont*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x5e2c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setString(char const* p0) -> decltype(setString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCLabelBMFont::setString), this);
	using FunctionType = decltype(setString(p0))(*)(cocos2d::CCLabelBMFont*, char const*);
	static auto func = wrapFunction(base::get() + 0x5e2130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setString(char const* p0, bool p1) -> decltype(setString(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, bool>::func(&cocos2d::CCLabelBMFont::setString), this);
	using FunctionType = decltype(setString(p0, p1))(*)(cocos2d::CCLabelBMFont*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x5e2180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLabelBMFont::getString() -> decltype(getString()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getString), this);
	using FunctionType = decltype(getString())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e23d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setCString(char const* p0) -> decltype(setCString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCLabelBMFont::setCString), this);
	using FunctionType = decltype(setCString(p0))(*)(cocos2d::CCLabelBMFont*, char const*);
	static auto func = wrapFunction(base::get() + 0x5e2420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::updateLabel() -> decltype(updateLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::updateLabel), this);
	using FunctionType = decltype(updateLabel())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e2c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setAlignment(cocos2d::CCTextAlignment p0) -> decltype(setAlignment(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextAlignment>::func(&cocos2d::CCLabelBMFont::setAlignment), this);
	using FunctionType = decltype(setAlignment(p0))(*)(cocos2d::CCLabelBMFont*, cocos2d::CCTextAlignment);
	static auto func = wrapFunction(base::get() + 0x5e45b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setWidth(float p0) -> decltype(setWidth(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCLabelBMFont::setWidth), this);
	using FunctionType = decltype(setWidth(p0))(*)(cocos2d::CCLabelBMFont*, float);
	static auto func = wrapFunction(base::get() + 0x5e45d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setLineBreakWithoutSpace(bool p0) -> decltype(setLineBreakWithoutSpace(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLabelBMFont::setLineBreakWithoutSpace), this);
	using FunctionType = decltype(setLineBreakWithoutSpace(p0))(*)(cocos2d::CCLabelBMFont*, bool);
	static auto func = wrapFunction(base::get() + 0x5e45f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setString(unsigned short* p0, bool p1) -> decltype(setString(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned short*, bool>::func(&cocos2d::CCLabelBMFont::setString), this);
	using FunctionType = decltype(setString(p0, p1))(*)(cocos2d::CCLabelBMFont*, unsigned short*, bool);
	static auto func = wrapFunction(base::get() + 0x5e2200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLabelBMFont::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLabelBMFont::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCLabelBMFont*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5e2480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::getColor() -> decltype(getColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getColor), this);
	using FunctionType = decltype(getColor())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e2440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::getDisplayedColor() -> decltype(getDisplayedColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getDisplayedColor), this);
	using FunctionType = decltype(getDisplayedColor())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e2460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::getDisplayedOpacity() -> decltype(getDisplayedOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getDisplayedOpacity), this);
	using FunctionType = decltype(getDisplayedOpacity())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e2610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e25f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLabelBMFont::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCLabelBMFont*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x5e2630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLabelBMFont::setOpacityModifyRGB), this);
	using FunctionType = decltype(setOpacityModifyRGB(p0))(*)(cocos2d::CCLabelBMFont*, bool);
	static auto func = wrapFunction(base::get() + 0x5e2770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::isOpacityModifyRGB), this);
	using FunctionType = decltype(isOpacityModifyRGB())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e28f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::isCascadeColorEnabled() -> decltype(isCascadeColorEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::isCascadeColorEnabled), this);
	using FunctionType = decltype(isCascadeColorEnabled())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e2bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setCascadeColorEnabled(bool p0) -> decltype(setCascadeColorEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLabelBMFont::setCascadeColorEnabled), this);
	using FunctionType = decltype(setCascadeColorEnabled(p0))(*)(cocos2d::CCLabelBMFont*, bool);
	static auto func = wrapFunction(base::get() + 0x5e2bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLabelBMFont::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(p0))(*)(cocos2d::CCLabelBMFont*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5e2a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::isCascadeOpacityEnabled() -> decltype(isCascadeOpacityEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::isCascadeOpacityEnabled), this);
	using FunctionType = decltype(isCascadeOpacityEnabled())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x5e2c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setCascadeOpacityEnabled(bool p0) -> decltype(setCascadeOpacityEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLabelBMFont::setCascadeOpacityEnabled), this);
	using FunctionType = decltype(setCascadeOpacityEnabled(p0))(*)(cocos2d::CCLabelBMFont*, bool);
	static auto func = wrapFunction(base::get() + 0x5e2c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLabelBMFont::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(p0))(*)(cocos2d::CCLabelBMFont*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x5e2910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCActionManager::addAction(cocos2d::CCAction* p0, cocos2d::CCNode* p1, bool p2) -> decltype(addAction(p0, p1, p2)) {
	using FunctionType = decltype(addAction(p0, p1, p2))(*)(cocos2d::CCActionManager*, cocos2d::CCAction*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x22f4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCActionManager::pauseTarget(cocos2d::CCObject* p0) -> decltype(pauseTarget(p0)) {
	using FunctionType = decltype(pauseTarget(p0))(*)(cocos2d::CCActionManager*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22f210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCActionManager::resumeTarget(cocos2d::CCObject* p0) -> decltype(resumeTarget(p0)) {
	using FunctionType = decltype(resumeTarget(p0))(*)(cocos2d::CCActionManager*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22f2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCApplication::sharedApplication() -> decltype(sharedApplication()) {
	using FunctionType = decltype(sharedApplication())(*)();
	static auto func = wrapFunction(base::get() + 0x328170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCApplication::run() -> decltype(run()) {
	throw std::runtime_error("cocos2d::CCApplication::run not implemented");
}

auto cocos2d::CCApplication::openURL(char const* p0) -> decltype(openURL(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCApplication::openURL), this);
	using FunctionType = decltype(openURL(p0))(*)(cocos2d::CCApplication*, char const*);
	static auto func = wrapFunction(base::get() + 0x328f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCArray::initWithCapacity(unsigned int p0) -> decltype(initWithCapacity(p0)) {
	using FunctionType = decltype(initWithCapacity(p0))(*)(cocos2d::CCArray*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x72cbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x30f260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCDictionary::createWithContentsOfFile(char const* p0) -> decltype(createWithContentsOfFile(p0)) {
	using FunctionType = decltype(createWithContentsOfFile(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x30f3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCDictionary::createWithContentsOfFileThreadSafe(char const* p0) -> decltype(createWithContentsOfFileThreadSafe(p0)) {
	using FunctionType = decltype(createWithContentsOfFileThreadSafe(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x30f2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCDictionary::setObject(cocos2d::CCObject* p0, gd::string const& p1) -> decltype(setObject(p0, p1)) {
	using FunctionType = decltype(setObject(p0, p1))(*)(cocos2d::CCDictionary*, cocos2d::CCObject*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x30d960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCDictionary::count() -> decltype(count()) {
	using FunctionType = decltype(count())(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x30d090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDictionary::objectForKey(gd::string const& p0) -> decltype(objectForKey(p0)) {
	using FunctionType = decltype(objectForKey(p0))(*)(cocos2d::CCDictionary*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x30d7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::removeAllObjects() -> decltype(removeAllObjects()) {
	using FunctionType = decltype(removeAllObjects())(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x30ceb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDictionary::removeObjectForKey(gd::string const& p0) -> decltype(removeObjectForKey(p0)) {
	using FunctionType = decltype(removeObjectForKey(p0))(*)(cocos2d::CCDictionary*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x30ed00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCDictionary::copyWithZone not implemented");
}

auto cocos2d::CCDictionary::acceptVisitor(cocos2d::CCDataVisitor& p0) -> decltype(acceptVisitor(p0)) {
	throw std::runtime_error("cocos2d::CCDictionary::acceptVisitor not implemented");
}

auto cocos2d::CCRenderTexture::draw() -> decltype(draw()) {
	throw std::runtime_error("cocos2d::CCRenderTexture::draw not implemented");
}

auto cocos2d::CCRenderTexture::visit() -> decltype(visit()) {
	throw std::runtime_error("cocos2d::CCRenderTexture::visit not implemented");
}

auto cocos2d::CCRenderTexture::getSprite() -> decltype(getSprite()) {
	throw std::runtime_error("cocos2d::CCRenderTexture::getSprite not implemented");
}

auto cocos2d::CCRenderTexture::setSprite(cocos2d::CCSprite* p0) -> decltype(setSprite(p0)) {
	throw std::runtime_error("cocos2d::CCRenderTexture::setSprite not implemented");
}

auto cocos2d::CCRepeat::create(cocos2d::CCFiniteTimeAction* p0, unsigned int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCFiniteTimeAction*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x3b9530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCRepeat::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCRepeat::copyWithZone not implemented");
}

auto cocos2d::CCRepeat::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCRepeat::update not implemented");
}

auto cocos2d::CCRepeat::isDone() -> decltype(isDone()) {
	throw std::runtime_error("cocos2d::CCRepeat::isDone not implemented");
}

auto cocos2d::CCRepeat::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCRepeat::startWithTarget not implemented");
}

auto cocos2d::CCRepeat::stop() -> decltype(stop()) {
	throw std::runtime_error("cocos2d::CCRepeat::stop not implemented");
}

auto cocos2d::CCRepeat::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCRepeat::reverse not implemented");
}

auto cocos2d::CCRepeatForever::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x3b9b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCRepeatForever::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCRepeatForever::copyWithZone not implemented");
}

auto cocos2d::CCRepeatForever::isDone() -> decltype(isDone()) {
	throw std::runtime_error("cocos2d::CCRepeatForever::isDone not implemented");
}

auto cocos2d::CCRepeatForever::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCRepeatForever::startWithTarget not implemented");
}

auto cocos2d::CCRepeatForever::step(float p0) -> decltype(step(p0)) {
	throw std::runtime_error("cocos2d::CCRepeatForever::step not implemented");
}

auto cocos2d::CCRepeatForever::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCRepeatForever::reverse not implemented");
}

auto cocos2d::CCTransitionFade::create(float p0, cocos2d::CCScene* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0xdc990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCTransitionFade::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionFade::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCTransitionFade*);
	static auto func = wrapFunction(base::get() + 0xdca80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionFade::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionFade::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCTransitionFade*);
	static auto func = wrapFunction(base::get() + 0xdcbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionFade::initWithDuration(float p0, cocos2d::CCScene* p1) -> decltype(initWithDuration(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, cocos2d::CCScene*>::func(&cocos2d::CCTransitionFade::initWithDuration), this);
	using FunctionType = decltype(initWithDuration(p0, p1))(*)(cocos2d::CCTransitionFade*, float, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0xdca60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTransitionFade::initWithDuration(float p0, cocos2d::CCScene* p1, cocos2d::_ccColor3B const& p2) -> decltype(initWithDuration(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<float, cocos2d::CCScene*, cocos2d::_ccColor3B const&>::func(&cocos2d::CCTransitionFade::initWithDuration), this);
	using FunctionType = decltype(initWithDuration(p0, p1, p2))(*)(cocos2d::CCTransitionFade*, float, cocos2d::CCScene*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0xdca10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCTransitionRotoZoom::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionRotoZoom::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCTransitionRotoZoom*);
	static auto func = wrapFunction(base::get() + 0xd8fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

cocos2d::CCTransitionScene::~CCTransitionScene() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd8700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCTransitionScene(geode::CutoffConstructor, sizeof(cocos2d::CCTransitionScene));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCTransitionScene::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd8b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionScene::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd8b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionScene::cleanup() -> decltype(cleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::cleanup), this);
	using FunctionType = decltype(cleanup())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd8bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionScene::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd88f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionScene::initWithDuration(float p0, cocos2d::CCScene* p1) -> decltype(initWithDuration(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, cocos2d::CCScene*>::func(&cocos2d::CCTransitionScene::initWithDuration), this);
	using FunctionType = decltype(initWithDuration(p0, p1))(*)(cocos2d::CCTransitionScene*, float, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0xd8820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTransitionScene::sceneOrder() -> decltype(sceneOrder()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::sceneOrder), this);
	using FunctionType = decltype(sceneOrder())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd88e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCBlink::create(float p0, unsigned int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, unsigned int);
	static auto func = wrapFunction(base::get() + 0x3bda90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCBlink::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCBlink::copyWithZone not implemented");
}

auto cocos2d::CCBlink::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCBlink::update not implemented");
}

auto cocos2d::CCBlink::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCBlink::startWithTarget not implemented");
}

auto cocos2d::CCBlink::stop() -> decltype(stop()) {
	throw std::runtime_error("cocos2d::CCBlink::stop not implemented");
}

auto cocos2d::CCBlink::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCBlink::reverse not implemented");
}

auto cocos2d::CCCallFunc::create(cocos2d::CCObject* p0, cocos2d::SEL_CallFunc p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCObject*, cocos2d::SEL_CallFunc);
	static auto func = wrapFunction(base::get() + 0x7b8f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCClippingNode::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x72c380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCClippingNode::create(cocos2d::CCNode* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x72c410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCClippingNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x72c4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::init(cocos2d::CCNode* p0) -> decltype(init(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCClippingNode::init), this);
	using FunctionType = decltype(init(p0))(*)(cocos2d::CCClippingNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x72c4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCClippingNode::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x72c550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x72c580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x72c5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::onExitTransitionDidStart() -> decltype(onExitTransitionDidStart()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::onExitTransitionDidStart), this);
	using FunctionType = decltype(onExitTransitionDidStart())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x72c5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::visit), this);
	using FunctionType = decltype(visit())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x72c610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::getStencil() const  -> decltype(getStencil()) {
	using FunctionType = decltype(getStencil())(*)(cocos2d::CCClippingNode const *);
	static auto func = wrapFunction(base::get() + 0x72c970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCClippingNode::setStencil(cocos2d::CCNode* p0) -> decltype(setStencil(p0)) {
	using FunctionType = decltype(setStencil(p0))(*)(cocos2d::CCClippingNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x72c980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCClippingNode::getAlphaThreshold() const  -> decltype(getAlphaThreshold()) {
	using FunctionType = decltype(getAlphaThreshold())(*)(cocos2d::CCClippingNode const *);
	static auto func = wrapFunction(base::get() + 0x72c9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCClippingNode::setAlphaThreshold(float p0) -> decltype(setAlphaThreshold(p0)) {
	using FunctionType = decltype(setAlphaThreshold(p0))(*)(cocos2d::CCClippingNode*, float);
	static auto func = wrapFunction(base::get() + 0x72c9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCClippingNode::isInverted() const  -> decltype(isInverted()) {
	using FunctionType = decltype(isInverted())(*)(cocos2d::CCClippingNode const *);
	static auto func = wrapFunction(base::get() + 0x72c9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCClippingNode::setInverted(bool p0) -> decltype(setInverted(p0)) {
	using FunctionType = decltype(setInverted(p0))(*)(cocos2d::CCClippingNode*, bool);
	static auto func = wrapFunction(base::get() + 0x72c9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDrawNode::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x61c020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCDrawNode::getBlendFunc() const  -> decltype(getBlendFunc()) {
	using FunctionType = decltype(getBlendFunc())(*)(cocos2d::CCDrawNode const *);
	static auto func = wrapFunction(base::get() + 0x61dd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDrawNode::setBlendFunc(cocos2d::_ccBlendFunc const& p0) -> decltype(setBlendFunc(p0)) {
	using FunctionType = decltype(setBlendFunc(p0))(*)(cocos2d::CCDrawNode*, cocos2d::_ccBlendFunc const&);
	static auto func = wrapFunction(base::get() + 0x61dd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCDrawNode::CCDrawNode() {
	using FunctionType = void(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x61bd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCDrawNode::~CCDrawNode() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x61bef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCDrawNode(geode::CutoffConstructor, sizeof(cocos2d::CCDrawNode));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCDrawNode::clear() -> decltype(clear()) {
	using FunctionType = decltype(clear())(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x61dd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDrawNode::drawCircle(cocos2d::CCPoint const& p0, float p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4, unsigned int p5) -> decltype(drawCircle(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(drawCircle(p0, p1, p2, p3, p4, p5))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&, unsigned int);
	static auto func = wrapFunction(base::get() + 0x61db70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto cocos2d::CCDrawNode::drawCubicBezier(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, cocos2d::CCPoint const& p2, cocos2d::CCPoint const& p3, unsigned int p4, cocos2d::_ccColor4F const& p5) -> decltype(drawCubicBezier(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(drawCubicBezier(p0, p1, p2, p3, p4, p5))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, cocos2d::CCPoint const&, cocos2d::CCPoint const&, cocos2d::CCPoint const&, unsigned int, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x61c9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto cocos2d::CCDrawNode::drawDot(cocos2d::CCPoint const& p0, float p1, cocos2d::_ccColor4F const& p2) -> decltype(drawDot(p0, p1, p2)) {
	using FunctionType = decltype(drawDot(p0, p1, p2))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x61c4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCDrawNode::drawLines(cocos2d::CCPoint* p0, unsigned int p1, float p2, cocos2d::_ccColor4F const& p3) -> decltype(drawLines(p0, p1, p2, p3)) {
	using FunctionType = decltype(drawLines(p0, p1, p2, p3))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint*, unsigned int, float, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x61daf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto cocos2d::CCDrawNode::drawPolygon(cocos2d::CCPoint * verts, unsigned int count, const cocos2d::ccColor4F & fillColor, float borderWidth, const cocos2d::ccColor4F & borderColor) -> decltype(drawPolygon(verts, count, fillColor, borderWidth, borderColor)) {
	using FunctionType = decltype(drawPolygon(verts, count, fillColor, borderWidth, borderColor))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint *, unsigned int, const cocos2d::ccColor4F &, float, const cocos2d::ccColor4F &);
	static auto func = wrapFunction(base::get() + 0x61cbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, verts, count, fillColor, borderWidth, borderColor);
}

auto cocos2d::CCDrawNode::drawPreciseCubicBezier(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, cocos2d::CCPoint const& p2, cocos2d::CCPoint const& p3, unsigned int p4, cocos2d::_ccColor4F const& p5) -> decltype(drawPreciseCubicBezier(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(drawPreciseCubicBezier(p0, p1, p2, p3, p4, p5))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, cocos2d::CCPoint const&, cocos2d::CCPoint const&, cocos2d::CCPoint const&, unsigned int, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x61c6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto cocos2d::CCDrawNode::drawRect(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4) -> decltype(drawRect(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(drawRect(p0, p1, p2, p3, p4))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, cocos2d::CCPoint const&, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x61d9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCDrawNode::drawSegment(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, float p2, cocos2d::_ccColor4F const& p3) -> decltype(drawSegment(p0, p1, p2, p3)) {
	using FunctionType = decltype(drawSegment(p0, p1, p2, p3))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x61d370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto cocos2d::CCDrawNode::ensureCapacity(unsigned int p0) -> decltype(ensureCapacity(p0)) {
	using FunctionType = decltype(ensureCapacity(p0))(*)(cocos2d::CCDrawNode*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x61c0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDrawNode::listenBackToForeground(cocos2d::CCObject* p0) -> decltype(listenBackToForeground(p0)) {
	using FunctionType = decltype(listenBackToForeground(p0))(*)(cocos2d::CCDrawNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x61dd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDrawNode::render() -> decltype(render()) {
	using FunctionType = decltype(render())(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x61c290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDrawNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCDrawNode::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x61c130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCDrawNode::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCDrawNode::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x61c320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::initWithTexture(cocos2d::CCTexture2D* p0, unsigned int p1) -> decltype(initWithTexture(p0, p1)) {
	using FunctionType = decltype(initWithTexture(p0, p1))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCTexture2D*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x171670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

cocos2d::CCSpriteBatchNode::CCSpriteBatchNode() {
	using FunctionType = void(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x171940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCSpriteBatchNode::~CCSpriteBatchNode() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x1719f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCSpriteBatchNode(geode::CutoffConstructor, sizeof(cocos2d::CCSpriteBatchNode));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCSpriteBatchNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x1718f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::addChild(cocos2d::CCNode* p0) -> decltype(addChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCSpriteBatchNode::addChild), this);
	using FunctionType = decltype(addChild(p0))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x171dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteBatchNode::addChild(cocos2d::CCNode* p0, int p1) -> decltype(addChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCSpriteBatchNode::addChild), this);
	using FunctionType = decltype(addChild(p0, p1))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x171dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSpriteBatchNode::addChild(cocos2d::CCNode* p0, int p1, int p2) -> decltype(addChild(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int, int>::func(&cocos2d::CCSpriteBatchNode::addChild), this);
	using FunctionType = decltype(addChild(p0, p1, p2))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x171b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCSpriteBatchNode::removeChild(cocos2d::CCNode* p0, bool p1) -> decltype(removeChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, bool>::func(&cocos2d::CCSpriteBatchNode::removeChild), this);
	using FunctionType = decltype(removeChild(p0, p1))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x171e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSpriteBatchNode::removeAllChildrenWithCleanup(bool p0) -> decltype(removeAllChildrenWithCleanup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSpriteBatchNode::removeAllChildrenWithCleanup), this);
	using FunctionType = decltype(removeAllChildrenWithCleanup(p0))(*)(cocos2d::CCSpriteBatchNode*, bool);
	static auto func = wrapFunction(base::get() + 0x172120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteBatchNode::reorderChild(cocos2d::CCNode* p0, int p1) -> decltype(reorderChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCSpriteBatchNode::reorderChild), this);
	using FunctionType = decltype(reorderChild(p0, p1))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x171de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSpriteBatchNode::sortAllChildren() -> decltype(sortAllChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::sortAllChildren), this);
	using FunctionType = decltype(sortAllChildren())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x1721d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x1729c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::visit), this);
	using FunctionType = decltype(visit())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x171ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccBlendFunc>::func(&cocos2d::CCSpriteBatchNode::setBlendFunc), this);
	using FunctionType = decltype(setBlendFunc(p0))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::_ccBlendFunc);
	static auto func = wrapFunction(base::get() + 0x173220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteBatchNode::getBlendFunc() -> decltype(getBlendFunc()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::getBlendFunc), this);
	using FunctionType = decltype(getBlendFunc())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x173240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::getTexture() -> decltype(getTexture()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::getTexture), this);
	using FunctionType = decltype(getTexture())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x173260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&cocos2d::CCSpriteBatchNode::setTexture), this);
	using FunctionType = decltype(setTexture(p0))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x173290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteFrame::create(char const* p0, cocos2d::CCRect const& p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x358210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCSpriteFrame::create(char const* p0, cocos2d::CCRect const& p1, bool p2, cocos2d::CCPoint const& p3, cocos2d::CCSize const& p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(char const*, cocos2d::CCRect const&, bool, cocos2d::CCPoint const&, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x358930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto cocos2d::CCSpriteFrame::createWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(createWithTexture(p0, p1)) {
	using FunctionType = decltype(createWithTexture(p0, p1))(*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x358410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCSpriteFrame::createWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2, cocos2d::CCPoint const& p3, cocos2d::CCSize const& p4) -> decltype(createWithTexture(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(createWithTexture(p0, p1, p2, p3, p4))(*)(cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool, cocos2d::CCPoint const&, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x358610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto cocos2d::CCSpriteFrame::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(initWithTexture(p0, p1)) {
	using FunctionType = decltype(initWithTexture(p0, p1))(*)(cocos2d::CCSpriteFrame*, cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x358520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCSpriteFrame::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2, cocos2d::CCPoint const& p3, cocos2d::CCSize const& p4) -> decltype(initWithTexture(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithTexture(p0, p1, p2, p3, p4))(*)(cocos2d::CCSpriteFrame*, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool, cocos2d::CCPoint const&, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x358740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCSpriteFrame::initWithTextureFilename(char const* p0, cocos2d::CCRect const& p1) -> decltype(initWithTextureFilename(p0, p1)) {
	using FunctionType = decltype(initWithTextureFilename(p0, p1))(*)(cocos2d::CCSpriteFrame*, char const*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x358320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCSpriteFrame::initWithTextureFilename(char const* p0, cocos2d::CCRect const& p1, bool p2, cocos2d::CCPoint const& p3, cocos2d::CCSize const& p4) -> decltype(initWithTextureFilename(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithTextureFilename(p0, p1, p2, p3, p4))(*)(cocos2d::CCSpriteFrame*, char const*, cocos2d::CCRect const&, bool, cocos2d::CCPoint const&, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x358a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCSpriteFrame::getOffset() -> decltype(getOffset()) {
	using FunctionType = decltype(getOffset())(*)(cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x359100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSpriteFrame::getOffsetInPixels() -> decltype(getOffsetInPixels()) {
	using FunctionType = decltype(getOffsetInPixels())(*)(cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x3591a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSpriteFrame::getTexture() -> decltype(getTexture()) {
	using FunctionType = decltype(getTexture())(*)(cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x359240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSpriteFrame::setOffset(cocos2d::CCPoint const& p0) -> decltype(setOffset(p0)) {
	using FunctionType = decltype(setOffset(p0))(*)(cocos2d::CCSpriteFrame*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x359110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrame::setOffsetInPixels(cocos2d::CCPoint const& p0) -> decltype(setOffsetInPixels(p0)) {
	using FunctionType = decltype(setOffsetInPixels(p0))(*)(cocos2d::CCSpriteFrame*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3591b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrame::setRect(cocos2d::CCRect const& p0) -> decltype(setRect(p0)) {
	using FunctionType = decltype(setRect(p0))(*)(cocos2d::CCSpriteFrame*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x358f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrame::setRectInPixels(cocos2d::CCRect const& p0) -> decltype(setRectInPixels(p0)) {
	using FunctionType = decltype(setRectInPixels(p0))(*)(cocos2d::CCSpriteFrame*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x359020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrame::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	using FunctionType = decltype(setTexture(p0))(*)(cocos2d::CCSpriteFrame*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x358f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrame::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCZone*>::func(&cocos2d::CCSpriteFrame::copyWithZone), this);
	using FunctionType = decltype(copyWithZone(p0))(*)(cocos2d::CCSpriteFrame*, cocos2d::CCZone*);
	static auto func = wrapFunction(base::get() + 0x358db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache() -> decltype(sharedSpriteFrameCache()) {
	using FunctionType = decltype(sharedSpriteFrameCache())(*)();
	static auto func = wrapFunction(base::get() + 0x31a9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCSpriteFrameCache::addSpriteFramesWithDictionary(cocos2d::CCDictionary* p0, cocos2d::CCTexture2D* p1) -> decltype(addSpriteFramesWithDictionary(p0, p1)) {
	using FunctionType = decltype(addSpriteFramesWithDictionary(p0, p1))(*)(cocos2d::CCSpriteFrameCache*, cocos2d::CCDictionary*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x31acd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCSpriteFrameCache::addSpriteFramesWithFile(char const* p0) -> decltype(addSpriteFramesWithFile(p0)) {
	using FunctionType = decltype(addSpriteFramesWithFile(p0))(*)(cocos2d::CCSpriteFrameCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x31b8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrameCache::spriteFrameByName(char const* p0) -> decltype(spriteFrameByName(p0)) {
	using FunctionType = decltype(spriteFrameByName(p0))(*)(cocos2d::CCSpriteFrameCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x31c720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCString::createWithData(unsigned char const* p0, unsigned long p1) -> decltype(createWithData(p0, p1)) {
	using FunctionType = decltype(createWithData(p0, p1))(*)(unsigned char const*, unsigned long);
	static auto func = wrapFunction(base::get() + 0x7b7370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCString::getCString() const  -> decltype(getCString()) {
	using FunctionType = decltype(getCString())(*)(cocos2d::CCString const *);
	static auto func = wrapFunction(base::get() + 0x7b6cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCMenuItem::~CCMenuItem() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x3c1fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCMenuItem(geode::CutoffConstructor, sizeof(cocos2d::CCMenuItem));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCMenuItem::initWithTarget(cocos2d::CCObject* p0, cocos2d::SEL_MenuHandler p1) -> decltype(initWithTarget(p0, p1)) {
	using FunctionType = decltype(initWithTarget(p0, p1))(*)(cocos2d::CCMenuItem*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x3c1ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCMenuItem::setTarget(cocos2d::CCObject* rec, cocos2d::SEL_MenuHandler selector) -> decltype(setTarget(rec, selector)) {
	using FunctionType = decltype(setTarget(rec, selector))(*)(cocos2d::CCMenuItem*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x3c2210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, rec, selector);
}

auto cocos2d::CCMenuItem::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::activate), this);
	using FunctionType = decltype(activate())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x3c2120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::selected), this);
	using FunctionType = decltype(selected())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x3c2090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::unselected), this);
	using FunctionType = decltype(unselected())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x3c20a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::registerScriptTapHandler(int p0) -> decltype(registerScriptTapHandler(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCMenuItem::registerScriptTapHandler), this);
	using FunctionType = decltype(registerScriptTapHandler(p0))(*)(cocos2d::CCMenuItem*, int);
	static auto func = wrapFunction(base::get() + 0x3c20b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItem::unregisterScriptTapHandler() -> decltype(unregisterScriptTapHandler()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::unregisterScriptTapHandler), this);
	using FunctionType = decltype(unregisterScriptTapHandler())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x3c20e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::isEnabled() -> decltype(isEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::isEnabled), this);
	using FunctionType = decltype(isEnabled())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x3c21a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::setEnabled(bool p0) -> decltype(setEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCMenuItem::setEnabled), this);
	using FunctionType = decltype(setEnabled(p0))(*)(cocos2d::CCMenuItem*, bool);
	static auto func = wrapFunction(base::get() + 0x3c2190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItem::isSelected() -> decltype(isSelected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::isSelected), this);
	using FunctionType = decltype(isSelected())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x3c2200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::initWithNormalSprite(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCNode* p2, cocos2d::CCObject* p3, cocos2d::SEL_MenuHandler p4) -> decltype(initWithNormalSprite(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithNormalSprite(p0, p1, p2, p3, p4))(*)(cocos2d::CCMenuItemSprite*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x3c3650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCMenuItemSprite::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::selected), this);
	using FunctionType = decltype(selected())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x3c3740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::unselected), this);
	using FunctionType = decltype(unselected())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x3c37e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::setEnabled(bool p0) -> decltype(setEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCMenuItemSprite::setEnabled), this);
	using FunctionType = decltype(setEnabled(p0))(*)(cocos2d::CCMenuItemSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x3c3860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItemSprite::getNormalImage() -> decltype(getNormalImage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::getNormalImage), this);
	using FunctionType = decltype(getNormalImage())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x3c3290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::setNormalImage(cocos2d::CCNode* p0) -> decltype(setNormalImage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCMenuItemSprite::setNormalImage), this);
	using FunctionType = decltype(setNormalImage(p0))(*)(cocos2d::CCMenuItemSprite*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x3c32a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItemSprite::getSelectedImage() -> decltype(getSelectedImage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::getSelectedImage), this);
	using FunctionType = decltype(getSelectedImage())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x3c3360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::setSelectedImage(cocos2d::CCNode* p0) -> decltype(setSelectedImage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCMenuItemSprite::setSelectedImage), this);
	using FunctionType = decltype(setSelectedImage(p0))(*)(cocos2d::CCMenuItemSprite*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x3c3370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItemSprite::getDisabledImage() -> decltype(getDisabledImage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::getDisabledImage), this);
	using FunctionType = decltype(getDisabledImage())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x3c3400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::setDisabledImage(cocos2d::CCNode* p0) -> decltype(setDisabledImage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCMenuItemSprite::setDisabledImage), this);
	using FunctionType = decltype(setDisabledImage(p0))(*)(cocos2d::CCMenuItemSprite*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x3c3410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItemSprite::updateImagesVisibility() -> decltype(updateImagesVisibility()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::updateImagesVisibility), this);
	using FunctionType = decltype(updateImagesVisibility())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x3c3880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenu::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x79e7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCMenu::createWithItem(cocos2d::CCMenuItem* p0) -> decltype(createWithItem(p0)) {
	using FunctionType = decltype(createWithItem(p0))(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x79ebf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCMenu::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenu::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCMenu*);
	static auto func = wrapFunction(base::get() + 0x79ec00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenu::addChild(cocos2d::CCNode* p0) -> decltype(addChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCMenu::addChild), this);
	using FunctionType = decltype(addChild(p0))(*)(cocos2d::CCMenu*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x79ec10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenu::addChild(cocos2d::CCNode* p0, int p1) -> decltype(addChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCMenu::addChild), this);
	using FunctionType = decltype(addChild(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x79ec20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::addChild(cocos2d::CCNode* p0, int p1, int p2) -> decltype(addChild(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int, int>::func(&cocos2d::CCMenu::addChild), this);
	using FunctionType = decltype(addChild(p0, p1, p2))(*)(cocos2d::CCMenu*, cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x79ec30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCMenu::removeChild(cocos2d::CCNode* p0, bool p1) -> decltype(removeChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, bool>::func(&cocos2d::CCMenu::removeChild), this);
	using FunctionType = decltype(removeChild(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x79ecd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenu::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCMenu*);
	static auto func = wrapFunction(base::get() + 0x79ec80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenu::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("cocos2d::CCMenu::registerWithTouchDispatcher not implemented");
}

auto cocos2d::CCMenu::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCMenu::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x79edd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCMenu::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x79f080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCMenu::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x79efa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCMenu::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x79f020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCRotateBy::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x3baf60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCRotateBy::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCRotateBy::copyWithZone not implemented");
}

auto cocos2d::CCRotateBy::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCRotateBy::update not implemented");
}

auto cocos2d::CCRotateBy::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCRotateBy::startWithTarget not implemented");
}

auto cocos2d::CCRotateBy::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCRotateBy::reverse not implemented");
}

auto cocos2d::CCDelayTime::create(float p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(float);
	static auto func = wrapFunction(base::get() + 0x3ba690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCDelayTime::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCDelayTime::copyWithZone not implemented");
}

auto cocos2d::CCDelayTime::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCDelayTime::update not implemented");
}

auto cocos2d::CCDelayTime::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCDelayTime::reverse not implemented");
}

auto cocos2d::CCTextFieldTTF::draw() -> decltype(draw()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::draw not implemented");
}

auto cocos2d::CCTextFieldTTF::getColorSpaceHolder() -> decltype(getColorSpaceHolder()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::getColorSpaceHolder not implemented");
}

auto cocos2d::CCTextFieldTTF::setColorSpaceHolder(const cocos2d::ccColor3B& color) -> decltype(setColorSpaceHolder(color)) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::setColorSpaceHolder not implemented");
}

auto cocos2d::CCTextFieldTTF::getPlaceHolder() -> decltype(getPlaceHolder()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::getPlaceHolder not implemented");
}

auto cocos2d::CCTextFieldTTF::setPlaceHolder(const char* text) -> decltype(setPlaceHolder(text)) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::setPlaceHolder not implemented");
}

auto cocos2d::CCTextFieldTTF::setSecureTextEntry(bool value) -> decltype(setSecureTextEntry(value)) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::setSecureTextEntry not implemented");
}

auto cocos2d::CCTextFieldTTF::isSecureTextEntry() -> decltype(isSecureTextEntry()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::isSecureTextEntry not implemented");
}

auto cocos2d::CCTextFieldTTF::setString(const char* text) -> decltype(setString(text)) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::setString not implemented");
}

auto cocos2d::CCTextFieldTTF::getString() -> decltype(getString()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::getString not implemented");
}

auto cocos2d::CCTextFieldTTF::attachWithIME() -> decltype(attachWithIME()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::attachWithIME not implemented");
}

auto cocos2d::CCTextFieldTTF::detachWithIME() -> decltype(detachWithIME()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::detachWithIME not implemented");
}

auto cocos2d::CCTextFieldTTF::canAttachWithIME() -> decltype(canAttachWithIME()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::canAttachWithIME not implemented");
}

auto cocos2d::CCTextFieldTTF::canDetachWithIME() -> decltype(canDetachWithIME()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::canDetachWithIME not implemented");
}

auto cocos2d::CCTextFieldTTF::insertText(const char* text, int len, cocos2d::enumKeyCodes keyCode) -> decltype(insertText(text, len, keyCode)) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::insertText not implemented");
}

auto cocos2d::CCTextFieldTTF::deleteBackward() -> decltype(deleteBackward()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::deleteBackward not implemented");
}

auto cocos2d::CCTextFieldTTF::getContentText() -> decltype(getContentText()) {
	throw std::runtime_error("cocos2d::CCTextFieldTTF::getContentText not implemented");
}

auto cocos2d::FNTConfigLoadFile(char const* p0) -> decltype(FNTConfigLoadFile(p0)) {
	using FunctionType = decltype(FNTConfigLoadFile(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x5dd4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::__CCPointApplyAffineTransform(cocos2d::CCPoint const& p0, cocos2d::CCAffineTransform const& p1) -> decltype(__CCPointApplyAffineTransform(p0, p1)) {
	using FunctionType = decltype(__CCPointApplyAffineTransform(p0, p1))(*)(cocos2d::CCPoint const&, cocos2d::CCAffineTransform const&);
	static auto func = wrapFunction(base::get() + 0x23b660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::ccDrawColor4B(unsigned char p0, unsigned char p1, unsigned char p2, unsigned char p3) -> decltype(ccDrawColor4B(p0, p1, p2, p3)) {
	using FunctionType = decltype(ccDrawColor4B(p0, p1, p2, p3))(*)(unsigned char, unsigned char, unsigned char, unsigned char);
	static auto func = wrapFunction(base::get() + 0x204480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto cocos2d::ccDrawLine(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1) -> decltype(ccDrawLine(p0, p1)) {
	using FunctionType = decltype(ccDrawLine(p0, p1))(*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x202c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::ccDrawSolidPoly(cocos2d::CCPoint const* p0, unsigned int p1, cocos2d::_ccColor4F p2) -> decltype(ccDrawSolidPoly(p0, p1, p2)) {
	using FunctionType = decltype(ccDrawSolidPoly(p0, p1, p2))(*)(cocos2d::CCPoint const*, unsigned int, cocos2d::_ccColor4F);
	static auto func = wrapFunction(base::get() + 0x202f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::ccDrawSolidRect(cocos2d::CCPoint origin, cocos2d::CCPoint destination, cocos2d::_ccColor4F color) -> decltype(ccDrawSolidRect(origin, destination, color)) {
	using FunctionType = decltype(ccDrawSolidRect(origin, destination, color))(*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor4F);
	static auto func = wrapFunction(base::get() + 0x202e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(origin, destination, color);
}

auto cocos2d::ccGLBindTexture2D(unsigned int p0) -> decltype(ccGLBindTexture2D(p0)) {
	using FunctionType = decltype(ccGLBindTexture2D(p0))(*)(unsigned int);
	static auto func = wrapFunction(base::get() + 0x35c2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ccGLBindTexture2DN(unsigned int p0, unsigned int p1) -> decltype(ccGLBindTexture2DN(p0, p1)) {
	using FunctionType = decltype(ccGLBindTexture2DN(p0, p1))(*)(unsigned int, unsigned int);
	static auto func = wrapFunction(base::get() + 0x35c2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::ccGLBlendFunc(unsigned int p0, unsigned int p1) -> decltype(ccGLBlendFunc(p0, p1)) {
	using FunctionType = decltype(ccGLBlendFunc(p0, p1))(*)(unsigned int, unsigned int);
	static auto func = wrapFunction(base::get() + 0x35c1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::ccGLBlendResetToCache() -> decltype(ccGLBlendResetToCache()) {
	using FunctionType = decltype(ccGLBlendResetToCache())(*)();
	static auto func = wrapFunction(base::get() + 0x35c250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::ccGLEnableVertexAttribs(unsigned int p0) -> decltype(ccGLEnableVertexAttribs(p0)) {
	using FunctionType = decltype(ccGLEnableVertexAttribs(p0))(*)(unsigned int);
	static auto func = wrapFunction(base::get() + 0x35c3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ccGLUseProgram(unsigned int p0) -> decltype(ccGLUseProgram(p0)) {
	using FunctionType = decltype(ccGLUseProgram(p0))(*)(unsigned int);
	static auto func = wrapFunction(base::get() + 0x35c1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ccpDistance(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1) -> decltype(ccpDistance(p0, p1)) {
	using FunctionType = decltype(ccpDistance(p0, p1))(*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x356d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::extension::CCControlColourPicker::colourPicker() -> decltype(colourPicker()) {
	using FunctionType = decltype(colourPicker())(*)();
	static auto func = wrapFunction(base::get() + 0x356900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::extension::CCScale9Sprite::createWithSpriteFrameName(char const* spriteFrameName) -> decltype(createWithSpriteFrameName(spriteFrameName)) {
	using FunctionType = decltype(createWithSpriteFrameName(spriteFrameName))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3fe8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(spriteFrameName);
}

auto cocos2d::extension::CCScale9Sprite::createWithSpriteFrameName(char const* spriteFrameName, cocos2d::CCRect capInsets) -> decltype(createWithSpriteFrameName(spriteFrameName, capInsets)) {
	using FunctionType = decltype(createWithSpriteFrameName(spriteFrameName, capInsets))(*)(char const*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3fe810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(spriteFrameName, capInsets);
}

auto cocos2d::extension::CCScale9Sprite::create(char const* pszname) -> decltype(create(pszname)) {
	using FunctionType = decltype(create(pszname))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3fe560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(pszname);
}

auto cocos2d::extension::CCScale9Sprite::create(char const* p0, cocos2d::CCRect p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3fe390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

cocos2d::extension::CCScale9Sprite::CCScale9Sprite() {
	using FunctionType = void(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3fc930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::extension::CCScale9Sprite::~CCScale9Sprite() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3fcb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::extension::CCScale9Sprite(geode::CutoffConstructor, sizeof(cocos2d::extension::CCScale9Sprite));
	CCDestructor::lock(this) = true;
}

auto cocos2d::extension::CCScale9Sprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3fcb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setContentSize(const cocos2d::CCSize& size) -> decltype(setContentSize(size)) {
	auto self = addresser::thunkAdjust(Resolve<const cocos2d::CCSize&>::func(&cocos2d::extension::CCScale9Sprite::setContentSize), this);
	using FunctionType = decltype(setContentSize(size))(*)(cocos2d::extension::CCScale9Sprite*, const cocos2d::CCSize&);
	static auto func = wrapFunction(base::get() + 0x3fdcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, size);
}

auto cocos2d::extension::CCScale9Sprite::visit() -> decltype(visit()) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::visit not implemented");
}

auto cocos2d::extension::CCScale9Sprite::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3ff3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setOpacity(GLubyte opacity) -> decltype(setOpacity(opacity)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::setOpacity not implemented");
}

auto cocos2d::extension::CCScale9Sprite::updateDisplayedOpacity(GLubyte parentOpacity) -> decltype(updateDisplayedOpacity(parentOpacity)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::updateDisplayedOpacity not implemented");
}

auto cocos2d::extension::CCScale9Sprite::getColor() -> decltype(getColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getColor), this);
	using FunctionType = decltype(getColor())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3ff210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setColor(const cocos2d::ccColor3B& color) -> decltype(setColor(color)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::setColor not implemented");
}

auto cocos2d::extension::CCScale9Sprite::updateDisplayedColor(const cocos2d::ccColor3B& parentColor) -> decltype(updateDisplayedColor(parentColor)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::updateDisplayedColor not implemented");
}

auto cocos2d::extension::CCScale9Sprite::setOpacityModifyRGB(bool bValue) -> decltype(setOpacityModifyRGB(bValue)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::setOpacityModifyRGB not implemented");
}

auto cocos2d::extension::CCScale9Sprite::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::isOpacityModifyRGB not implemented");
}

auto cocos2d::extension::CCScale9Sprite::getPreferredSize() -> decltype(getPreferredSize()) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::getPreferredSize not implemented");
}

auto cocos2d::extension::CCScale9Sprite::setPreferredSize(cocos2d::CCSize p0) -> decltype(setPreferredSize(p0)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::setPreferredSize not implemented");
}

auto cocos2d::extension::CCScale9Sprite::getCapInsets() -> decltype(getCapInsets()) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::getCapInsets not implemented");
}

auto cocos2d::extension::CCScale9Sprite::setCapInsets(cocos2d::CCRect p0) -> decltype(setCapInsets(p0)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::setCapInsets not implemented");
}

auto cocos2d::extension::CCScale9Sprite::getInsetLeft() -> decltype(getInsetLeft()) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::getInsetLeft not implemented");
}

auto cocos2d::extension::CCScale9Sprite::setInsetLeft(float p0) -> decltype(setInsetLeft(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::extension::CCScale9Sprite::setInsetLeft), this);
	using FunctionType = decltype(setInsetLeft(p0))(*)(cocos2d::extension::CCScale9Sprite*, float);
	static auto func = wrapFunction(base::get() + 0x3fefe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::getInsetTop() -> decltype(getInsetTop()) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::getInsetTop not implemented");
}

auto cocos2d::extension::CCScale9Sprite::setInsetTop(float p0) -> decltype(setInsetTop(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::extension::CCScale9Sprite::setInsetTop), this);
	using FunctionType = decltype(setInsetTop(p0))(*)(cocos2d::extension::CCScale9Sprite*, float);
	static auto func = wrapFunction(base::get() + 0x3ff000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::getInsetRight() -> decltype(getInsetRight()) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::getInsetRight not implemented");
}

auto cocos2d::extension::CCScale9Sprite::setInsetRight(float p0) -> decltype(setInsetRight(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::extension::CCScale9Sprite::setInsetRight), this);
	using FunctionType = decltype(setInsetRight(p0))(*)(cocos2d::extension::CCScale9Sprite*, float);
	static auto func = wrapFunction(base::get() + 0x3ff020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::getInsetBottom() -> decltype(getInsetBottom()) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::getInsetBottom not implemented");
}

auto cocos2d::extension::CCScale9Sprite::setInsetBottom(float p0) -> decltype(setInsetBottom(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::extension::CCScale9Sprite::setInsetBottom), this);
	using FunctionType = decltype(setInsetBottom(p0))(*)(cocos2d::extension::CCScale9Sprite*, float);
	static auto func = wrapFunction(base::get() + 0x3ff040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::initWithBatchNode(cocos2d::CCSpriteBatchNode* p0, cocos2d::CCRect p1, bool p2, cocos2d::CCRect p3) -> decltype(initWithBatchNode(p0, p1, p2, p3)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithBatchNode not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithBatchNode(cocos2d::CCSpriteBatchNode* p0, cocos2d::CCRect p1, cocos2d::CCRect p2) -> decltype(initWithBatchNode(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithBatchNode not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithFile(const char* p0, cocos2d::CCRect p1, cocos2d::CCRect p2) -> decltype(initWithFile(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithFile not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithFile(const char* p0, cocos2d::CCRect p1) -> decltype(initWithFile(p0, p1)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithFile not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithFile(cocos2d::CCRect p0, const char* p1) -> decltype(initWithFile(p0, p1)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithFile not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithFile(const char* p0) -> decltype(initWithFile(p0)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithFile not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0, cocos2d::CCRect p1) -> decltype(initWithSpriteFrame(p0, p1)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithSpriteFrame not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(initWithSpriteFrame(p0)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithSpriteFrame not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithSpriteFrameName(const char* p0, cocos2d::CCRect p1) -> decltype(initWithSpriteFrameName(p0, p1)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithSpriteFrameName not implemented");
}

auto cocos2d::extension::CCScale9Sprite::initWithSpriteFrameName(const char* p0) -> decltype(initWithSpriteFrameName(p0)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::initWithSpriteFrameName not implemented");
}

auto cocos2d::extension::CCScale9Sprite::updateWithBatchNode(cocos2d::CCSpriteBatchNode* p0, cocos2d::CCRect p1, bool p2, cocos2d::CCRect p3) -> decltype(updateWithBatchNode(p0, p1, p2, p3)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::updateWithBatchNode not implemented");
}

auto cocos2d::extension::CCScale9Sprite::setSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(setSpriteFrame(p0)) {
	throw std::runtime_error("cocos2d::extension::CCScale9Sprite::setSpriteFrame not implemented");
}

auto cocos2d::extension::CCHttpClient::getInstance() -> decltype(getInstance()) {
	using FunctionType = decltype(getInstance())(*)();
	static auto func = wrapFunction(base::get() + 0x441e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::extension::CCHttpClient::destroyInstance() -> decltype(destroyInstance()) {
	using FunctionType = decltype(destroyInstance())(*)();
	static auto func = wrapFunction(base::get() + 0x441e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::extension::CCHttpClient::send(cocos2d::extension::CCHttpRequest* request) -> decltype(send(request)) {
	using FunctionType = decltype(send(request))(*)(cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpRequest*);
	static auto func = wrapFunction(base::get() + 0x442d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, request);
}

auto cocos2d::extension::CCHttpClient::lazyInitThreadSemphore() -> decltype(lazyInitThreadSemphore()) {
	using FunctionType = decltype(lazyInitThreadSemphore())(*)(cocos2d::extension::CCHttpClient*);
	static auto func = wrapFunction(base::get() + 0x442160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::extension::CCHttpClient::dispatchResponseCallbacks(float p0) -> decltype(dispatchResponseCallbacks(p0)) {
	using FunctionType = decltype(dispatchResponseCallbacks(p0))(*)(cocos2d::extension::CCHttpClient*, float);
	static auto func = wrapFunction(base::get() + 0x441ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJDropDownLayer::init(char const* p0, float p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(GJDropDownLayer*, char const*, float, bool);
	static auto func = wrapFunction(base::get() + 0x5f18a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJDropDownLayer::init(char const* title) -> decltype(init(title)) {
	using FunctionType = decltype(init(title))(*)(GJDropDownLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x5f1cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, title);
}

auto GJDropDownLayer::create(const char* title, float height, bool p2) -> decltype(create(title, height, p2)) {
	using FunctionType = decltype(create(title, height, p2))(*)(const char*, float, bool);
	static auto func = wrapFunction(base::get() + 0x5f1770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(title, height, p2);
}

auto GJDropDownLayer::create(const char* title) -> decltype(create(title)) {
	using FunctionType = decltype(create(title))(*)(const char*);
	static auto func = wrapFunction(base::get() + 0x5f1cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(title);
}

auto GJDropDownLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::draw), this);
	using FunctionType = decltype(draw())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5f20b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJDropDownLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJDropDownLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x5f20e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void GJDropDownLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void GJDropDownLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void GJDropDownLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto GJDropDownLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5f1d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5f1db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GJDropDownLayer::customSetup() {}

auto GJDropDownLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5f1d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJDropDownLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(GJDropDownLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f1df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJDropDownLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(GJDropDownLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5f1e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJDropDownLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(GJDropDownLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5f1f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5f2050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5f2070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GJDropDownLayer::enterAnimFinished() {}

auto GJDropDownLayer::disableUI() -> decltype(disableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::disableUI), this);
	using FunctionType = decltype(disableUI())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5f1d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::enableUI() -> decltype(enableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enableUI), this);
	using FunctionType = decltype(enableUI())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5f1d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountDelegate::accountStatusChanged() -> decltype(accountStatusChanged()) {
	throw std::runtime_error("GJAccountDelegate::accountStatusChanged not implemented");
}

void FLAlertLayerProtocol::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto AccountHelpLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0xd1910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0xd2740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::accountStatusChanged() -> decltype(accountStatusChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::accountStatusChanged), this);
	using FunctionType = decltype(accountStatusChanged())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0xd2600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountHelpLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountHelpLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xd2630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJAccountBackupDelegate::backupAccountFinished() -> decltype(backupAccountFinished()) {
	throw std::runtime_error("GJAccountBackupDelegate::backupAccountFinished not implemented");
}

auto GJAccountBackupDelegate::backupAccountFailed(BackupAccountError p0, int p1) -> decltype(backupAccountFailed(p0, p1)) {
	throw std::runtime_error("GJAccountBackupDelegate::backupAccountFailed not implemented");
}

auto GJAccountSyncDelegate::syncAccountFinished() -> decltype(syncAccountFinished()) {
	throw std::runtime_error("GJAccountSyncDelegate::syncAccountFinished not implemented");
}

auto GJAccountSyncDelegate::syncAccountFailed(BackupAccountError p0, int p1) -> decltype(syncAccountFailed(p0, p1)) {
	throw std::runtime_error("GJAccountSyncDelegate::syncAccountFailed not implemented");
}

auto AccountLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xcf0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xd12e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::backupAccountFinished() -> decltype(backupAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::backupAccountFinished), this);
	using FunctionType = decltype(backupAccountFinished())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xd0830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::backupAccountFailed(BackupAccountError p0, int p1) -> decltype(backupAccountFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BackupAccountError, int>::func(&AccountLayer::backupAccountFailed), this);
	using FunctionType = decltype(backupAccountFailed(p0, p1))(*)(AccountLayer*, BackupAccountError, int);
	static auto func = wrapFunction(base::get() + 0xd09f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLayer::syncAccountFinished() -> decltype(syncAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::syncAccountFinished), this);
	using FunctionType = decltype(syncAccountFinished())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xd0da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::syncAccountFailed(BackupAccountError p0, int p1) -> decltype(syncAccountFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BackupAccountError, int>::func(&AccountLayer::syncAccountFailed), this);
	using FunctionType = decltype(syncAccountFailed(p0, p1))(*)(AccountLayer*, BackupAccountError, int);
	static auto func = wrapFunction(base::get() + 0xd0f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLayer::accountStatusChanged() -> decltype(accountStatusChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::accountStatusChanged), this);
	using FunctionType = decltype(accountStatusChanged())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xd0800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xd11c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

FLAlertLayer::~FLAlertLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x4a49c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) FLAlertLayer(geode::CutoffConstructor, sizeof(FLAlertLayer));
	CCDestructor::lock(this) = true;
}

FLAlertLayer::FLAlertLayer() { // ios 0xa7ec : this seems too small?
		m_buttonMenu = nullptr;
		m_controlConnected = -1;
		m_mainLayer = nullptr;
		m_ZOrder = 0;
		m_noElasticity = false;
		m_reverseKeyBack = false;
		m_scene = nullptr;
		m_alertProtocol = nullptr;
		m_scrollingLayer = nullptr;
		m_button2 = nullptr;
		m_button1 = nullptr;
		m_joystickConnected = -1;
		m_containsBorder = 0;
		m_forcePrioRegistered = false;
	}

auto FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width, bool scroll, float height, float textScale) -> decltype(create(delegate, title, desc, btn1, btn2, width, scroll, height, textScale)) {
	using FunctionType = decltype(create(delegate, title, desc, btn1, btn2, width, scroll, height, textScale))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x4a4da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, title, desc, btn1, btn2, width, scroll, height, textScale);
}

auto FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width) -> decltype(create(delegate, title, desc, btn1, btn2, width)) {
	using FunctionType = decltype(create(delegate, title, desc, btn1, btn2, width))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x4a4fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, title, desc, btn1, btn2, width);
}

auto FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2) -> decltype(create(delegate, title, desc, btn1, btn2)) {
	using FunctionType = decltype(create(delegate, title, desc, btn1, btn2))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x4a4c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, title, desc, btn1, btn2);
}

FLAlertLayer* FLAlertLayer::create(char const* title, const gd::string& desc, char const* btn) {
		return FLAlertLayer::create(nullptr, title, desc, btn, nullptr, 300.0);
	}

auto FLAlertLayer::init(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7, float p8) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(FLAlertLayer*, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x4a50e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto FLAlertLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FLAlertLayer*, int);
	static auto func = wrapFunction(base::get() + 0x4a5c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FLAlertLayer::onBtn1(cocos2d::CCObject* sender) -> decltype(onBtn1(sender)) {
	using FunctionType = decltype(onBtn1(sender))(*)(FLAlertLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4a5d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FLAlertLayer::onBtn2(cocos2d::CCObject* sender) -> decltype(onBtn2(sender)) {
	using FunctionType = decltype(onBtn2(sender))(*)(FLAlertLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4a5dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FLAlertLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a5ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a6230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a6110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a61b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x4a6460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x4a5ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&FLAlertLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(FLAlertLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4a5e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FLAlertLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::show), this);
	using FunctionType = decltype(show())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x4a62b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void TextInputDelegate::textChanged(CCTextInputNode* p0) {}

void TextInputDelegate::textInputOpened(CCTextInputNode* p0) {}

void TextInputDelegate::textInputClosed(CCTextInputNode* p0) {}

void TextInputDelegate::textInputShouldOffset(CCTextInputNode* p0, float p1) {}

void TextInputDelegate::textInputReturn(CCTextInputNode* p0) {}

bool TextInputDelegate::allowTextInput(CCTextInputNode* p0) { return true; }

void TextInputDelegate::enterPressed(CCTextInputNode* p0) {}

auto GJAccountLoginDelegate::loginAccountFinished(int p0, int p1) -> decltype(loginAccountFinished(p0, p1)) {
	throw std::runtime_error("GJAccountLoginDelegate::loginAccountFinished not implemented");
}

auto GJAccountLoginDelegate::loginAccountFailed(AccountError p0) -> decltype(loginAccountFailed(p0)) {
	throw std::runtime_error("GJAccountLoginDelegate::loginAccountFailed not implemented");
}

auto AccountLoginLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLoginLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(AccountLoginLayer*);
	static auto func = wrapFunction(base::get() + 0x4a46b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLoginLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLoginLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(AccountLoginLayer*);
	static auto func = wrapFunction(base::get() + 0x4a4570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLoginLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountLoginLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountLoginLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4a43b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void AccountLoginLayer::textInputOpened(CCTextInputNode* p0) {}

auto AccountLoginLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountLoginLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(AccountLoginLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4a46f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void AccountLoginLayer::textChanged(CCTextInputNode* p0) {}

auto AccountLoginLayer::loginAccountFinished(int p0, int p1) -> decltype(loginAccountFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&AccountLoginLayer::loginAccountFinished), this);
	using FunctionType = decltype(loginAccountFinished(p0, p1))(*)(AccountLoginLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x4a3c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLoginLayer::loginAccountFailed(AccountError p0) -> decltype(loginAccountFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AccountError>::func(&AccountLoginLayer::loginAccountFailed), this);
	using FunctionType = decltype(loginAccountFailed(p0))(*)(AccountLoginLayer*, AccountError);
	static auto func = wrapFunction(base::get() + 0x4a4080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJAccountRegisterDelegate::registerAccountFinished() -> decltype(registerAccountFinished()) {
	throw std::runtime_error("GJAccountRegisterDelegate::registerAccountFinished not implemented");
}

auto GJAccountRegisterDelegate::registerAccountFailed(AccountError p0) -> decltype(registerAccountFailed(p0)) {
	throw std::runtime_error("GJAccountRegisterDelegate::registerAccountFailed not implemented");
}

auto AccountRegisterLayer::resetLabel(int p0) -> decltype(resetLabel(p0)) {
	using FunctionType = decltype(resetLabel(p0))(*)(AccountRegisterLayer*, int);
	static auto func = wrapFunction(base::get() + 0x4a0f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AccountRegisterLayer::resetLabels() -> decltype(resetLabels()) {
	using FunctionType = decltype(resetLabels())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x4a0e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AccountRegisterLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::init), this);
	using FunctionType = decltype(init())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x49e910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x4a1690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x4a14c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountRegisterLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountRegisterLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4a1010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void AccountRegisterLayer::textInputOpened(CCTextInputNode* p0) {}

auto AccountRegisterLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4a16d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void AccountRegisterLayer::textChanged(CCTextInputNode* p0) {}

auto AccountRegisterLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&AccountRegisterLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(AccountRegisterLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x4a21d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountRegisterLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4a2290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::allowTextInput(CCTextInputNode* p0) -> decltype(allowTextInput(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::allowTextInput), this);
	using FunctionType = decltype(allowTextInput(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4a2340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::registerAccountFinished() -> decltype(registerAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::registerAccountFinished), this);
	using FunctionType = decltype(registerAccountFinished())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x4a0870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::registerAccountFailed(AccountError p0) -> decltype(registerAccountFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AccountError>::func(&AccountRegisterLayer::registerAccountFailed), this);
	using FunctionType = decltype(registerAccountFailed(p0))(*)(AccountRegisterLayer*, AccountError);
	static auto func = wrapFunction(base::get() + 0x4a0a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AchievementBar::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&AchievementBar::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(AchievementBar*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x6258a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

CCIndexPath::CCIndexPath() {}

TableViewCell::TableViewCell(char const* p0, float p1, float p2) : TableViewCell(geode::CutoffConstructor, sizeof(TableViewCell)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	TableViewCell::~TableViewCell();
	using FunctionType = void(*)(TableViewCell*, char const*, float, float);
	static auto func = wrapFunction(base::get() + 0x633d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto AchievementCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementCell::init), this);
	using FunctionType = decltype(init())(*)(AchievementCell*);
	static auto func = wrapFunction(base::get() + 0x24a370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementCell::draw), this);
	using FunctionType = decltype(draw())(*)(AchievementCell*);
	static auto func = wrapFunction(base::get() + 0x24a3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementManager::isAchievementEarned(char const* ach) -> decltype(isAchievementEarned(ach)) {
	using FunctionType = decltype(isAchievementEarned(ach))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x790ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, ach);
}

auto AchievementManager::percentForAchievement(char const* p0) -> decltype(percentForAchievement(p0)) {
	using FunctionType = decltype(percentForAchievement(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x790af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementManager::init), this);
	using FunctionType = decltype(init())(*)(AchievementManager*);
	static auto func = wrapFunction(base::get() + 0x739060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementNotifier::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x7cf810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AchievementNotifier::willSwitchToScene(cocos2d::CCScene* scene) -> decltype(willSwitchToScene(scene)) {
	using FunctionType = decltype(willSwitchToScene(scene))(*)(AchievementNotifier*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x7cfa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, scene);
}

auto AchievementNotifier::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementNotifier::init), this);
	using FunctionType = decltype(init())(*)(AchievementNotifier*);
	static auto func = wrapFunction(base::get() + 0x7cf8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementsLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&AchievementsLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(AchievementsLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x375020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AchievementsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AchievementsLayer*);
	static auto func = wrapFunction(base::get() + 0x374b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpritePlus::setScaleX(float fScaleX) -> decltype(setScaleX(fScaleX)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScaleX), this);
	using FunctionType = decltype(setScaleX(fScaleX))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x48ae40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fScaleX);
}

auto CCSpritePlus::setScaleY(float fScaleY) -> decltype(setScaleY(fScaleY)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScaleY), this);
	using FunctionType = decltype(setScaleY(fScaleY))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x48aec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fScaleY);
}

auto CCSpritePlus::setScale(float fScale) -> decltype(setScale(fScale)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScale), this);
	using FunctionType = decltype(setScale(fScale))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x48af40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fScale);
}

auto CCSpritePlus::setPosition(cocos2d::CCPoint const& pos) -> decltype(setPosition(pos)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCSpritePlus::setPosition), this);
	using FunctionType = decltype(setPosition(pos))(*)(CCSpritePlus*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x48aaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, pos);
}

auto CCSpritePlus::setRotation(float fRotation) -> decltype(setRotation(fRotation)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotation), this);
	using FunctionType = decltype(setRotation(fRotation))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x48ab20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fRotation);
}

auto CCSpritePlus::setRotationX(float fRotationX) -> decltype(setRotationX(fRotationX)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotationX), this);
	using FunctionType = decltype(setRotationX(fRotationX))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x48aba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fRotationX);
}

auto CCSpritePlus::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x48ac20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::initWithTexture(cocos2d::CCTexture2D* texture) -> decltype(initWithTexture(texture)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&CCSpritePlus::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(texture))(*)(CCSpritePlus*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x48aa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, texture);
}

auto CCSpritePlus::initWithSpriteFrameName(char const* p0) -> decltype(initWithSpriteFrameName(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CCSpritePlus::initWithSpriteFrameName), this);
	using FunctionType = decltype(initWithSpriteFrameName(p0))(*)(CCSpritePlus*, char const*);
	static auto func = wrapFunction(base::get() + 0x48aa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setFlipX(bool flipX) -> decltype(setFlipX(flipX)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePlus::setFlipX), this);
	using FunctionType = decltype(setFlipX(flipX))(*)(CCSpritePlus*, bool);
	static auto func = wrapFunction(base::get() + 0x48aca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, flipX);
}

auto CCSpritePlus::setFlipY(bool flipY) -> decltype(setFlipY(flipY)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePlus::setFlipY), this);
	using FunctionType = decltype(setFlipY(flipY))(*)(CCSpritePlus*, bool);
	static auto func = wrapFunction(base::get() + 0x48ad70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, flipY);
}

auto GameObject::addColorSprite(gd::string p0) -> decltype(addColorSprite(p0)) {
	using FunctionType = decltype(addColorSprite(p0))(*)(GameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x5ad230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::addToCustomScaleX(float p0) -> decltype(addToCustomScaleX(p0)) {
	using FunctionType = decltype(addToCustomScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::addToCustomScaleY(float p0) -> decltype(addToCustomScaleY(p0)) {
	using FunctionType = decltype(addToCustomScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::commonSetup() -> decltype(commonSetup()) {
	using FunctionType = decltype(commonSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5aa930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::copyGroups(GameObject* p0) -> decltype(copyGroups(p0)) {
	using FunctionType = decltype(copyGroups(p0))(*)(GameObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c70a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::createSpriteColor(int p0) -> decltype(createSpriteColor(p0)) {
	using FunctionType = decltype(createSpriteColor(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x5aaaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::createWithFrame(char const* name) -> decltype(createWithFrame(name)) {
	using FunctionType = decltype(createWithFrame(name))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x5aa890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(name);
}

auto GameObject::determineSlopeDirection() -> decltype(determineSlopeDirection()) {
	using FunctionType = decltype(determineSlopeDirection())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c6ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::getGroupID(int p0) -> decltype(getGroupID(p0)) {
	using FunctionType = decltype(getGroupID(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x5c7080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::getLastPosition() -> decltype(getLastPosition()) {
	using FunctionType = decltype(getLastPosition())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d3a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::groupOpacityMod() -> decltype(groupOpacityMod()) {
	using FunctionType = decltype(groupOpacityMod())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c7ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::init(char const* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x5aa900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::isFacingDown() -> decltype(isFacingDown()) {
	using FunctionType = decltype(isFacingDown())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d2840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isFacingLeft() -> decltype(isFacingLeft()) {
	using FunctionType = decltype(isFacingLeft())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d28e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isSettingsObject() -> decltype(isSettingsObject()) {
	using FunctionType = decltype(isSettingsObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d45e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::makeInvisible() -> decltype(makeInvisible()) {
	using FunctionType = decltype(makeInvisible())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c59f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::objectFromVector(gd::vector<gd::string>& p0, gd::vector<void*>& p1, GJBaseGameLayer* p2, bool p3) -> decltype(objectFromVector(p0, p1, p2, p3)) {
	using FunctionType = decltype(objectFromVector(p0, p1, p2, p3))(*)(gd::vector<gd::string>&, gd::vector<void*>&, GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5c8800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GameObject::playShineEffect() -> decltype(playShineEffect()) {
	using FunctionType = decltype(playShineEffect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c5a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::setLastPosition(cocos2d::CCPoint const& p0) -> decltype(setLastPosition(p0)) {
	using FunctionType = decltype(setLastPosition(p0))(*)(GameObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x5d3a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateCustomScaleX(float p0) -> decltype(updateCustomScaleX(p0)) {
	using FunctionType = decltype(updateCustomScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5b24b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateCustomScaleY(float p0) -> decltype(updateCustomScaleY(p0)) {
	using FunctionType = decltype(updateCustomScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5b2530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateIsOriented() -> decltype(updateIsOriented()) {
	using FunctionType = decltype(updateIsOriented())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d2660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::update), this);
	using FunctionType = decltype(update(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5b2ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&GameObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(GameObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x5c43f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5c51b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c47f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x5c4e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&GameObject::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(GameObject*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x5aaac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5d19c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5c48d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setFlipY), this);
	using FunctionType = decltype(setFlipY(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5c4920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::firstSetup() -> decltype(firstSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::firstSetup), this);
	using FunctionType = decltype(firstSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1b64a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5b2cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string>::func(&GameObject::setupCustomSprites), this);
	using FunctionType = decltype(setupCustomSprites(p0))(*)(GameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x44d950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::addMainSpriteToParent), this);
	using FunctionType = decltype(addMainSpriteToParent(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5c67e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5b2160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&GameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(GameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1b6120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GameObject::activateObject() -> decltype(activateObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::activateObject), this);
	using FunctionType = decltype(activateObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5b2780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5b2af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::transferObjectRect(cocos2d::CCRect& p0) -> decltype(transferObjectRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect&>::func(&GameObject::transferObjectRect), this);
	using FunctionType = decltype(transferObjectRect(p0))(*)(GameObject*, cocos2d::CCRect&);
	static auto func = wrapFunction(base::get() + 0x5c3ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getObjectRect() -> decltype(getObjectRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRect), this);
	using FunctionType = decltype(getObjectRect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c3d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRect(float p0, float p1) -> decltype(getObjectRect(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&GameObject::getObjectRect), this);
	using FunctionType = decltype(getObjectRect(p0, p1))(*)(GameObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x5c3d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getObjectRect2(float p0, float p1) -> decltype(getObjectRect2(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&GameObject::getObjectRect2), this);
	using FunctionType = decltype(getObjectRect2(p0, p1))(*)(GameObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x5c3fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getObjectTextureRect() -> decltype(getObjectTextureRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectTextureRect), this);
	using FunctionType = decltype(getObjectTextureRect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c4090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getRealPosition() -> decltype(getRealPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRealPosition), this);
	using FunctionType = decltype(getRealPosition())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c4330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setStartPos(cocos2d::CCPoint p0) -> decltype(setStartPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&GameObject::setStartPos), this);
	using FunctionType = decltype(setStartPos(p0))(*)(GameObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x5b2050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateStartValues() -> decltype(updateStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::updateStartValues), this);
	using FunctionType = decltype(updateStartValues())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5b25b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&GameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(GameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x39fd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&GameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(GameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x5ca7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::claimParticle() -> decltype(claimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::claimParticle), this);
	using FunctionType = decltype(claimParticle())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c5310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::unclaimParticle() -> decltype(unclaimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::unclaimParticle), this);
	using FunctionType = decltype(unclaimParticle())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c5910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::particleWasActivated() -> decltype(particleWasActivated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::particleWasActivated), this);
	using FunctionType = decltype(particleWasActivated())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c5980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::isFlipX() -> decltype(isFlipX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isFlipX), this);
	using FunctionType = decltype(isFlipX())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c48b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::isFlipY() -> decltype(isFlipY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isFlipY), this);
	using FunctionType = decltype(isFlipY())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c48c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setRScaleX(float p0) -> decltype(setRScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScaleX), this);
	using FunctionType = decltype(setRScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRScaleY(float p0) -> decltype(setRScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScaleY), this);
	using FunctionType = decltype(setRScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRScale(float p0) -> decltype(setRScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScale), this);
	using FunctionType = decltype(setRScale(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c4bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getRScaleX() -> decltype(getRScaleX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRScaleX), this);
	using FunctionType = decltype(getRScaleX())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c4c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getRScaleY() -> decltype(getRScaleY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRScaleY), this);
	using FunctionType = decltype(getRScaleY())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c4c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setRRotation(float p0) -> decltype(setRRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRRotation), this);
	using FunctionType = decltype(setRRotation(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5c45e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1ed230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5d16e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setGlowColor(cocos2d::ccColor3B const& p0) -> decltype(setGlowColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::setGlowColor), this);
	using FunctionType = decltype(setGlowColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5d1970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5c59c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::animationTriggered() -> decltype(animationTriggered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::animationTriggered), this);
	using FunctionType = decltype(animationTriggered())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::selectObject(cocos2d::ccColor3B p0) -> decltype(selectObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B>::func(&GameObject::selectObject), this);
	using FunctionType = decltype(selectObject(p0))(*)(GameObject*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x5d1a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::activatedByPlayer(PlayerObject* p0) -> decltype(activatedByPlayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&GameObject::activatedByPlayer), this);
	using FunctionType = decltype(activatedByPlayer(p0))(*)(GameObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x1ed250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::hasBeenActivatedByPlayer(PlayerObject* p0) -> decltype(hasBeenActivatedByPlayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&GameObject::hasBeenActivatedByPlayer), this);
	using FunctionType = decltype(hasBeenActivatedByPlayer(p0))(*)(GameObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x1ed260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::hasBeenActivated() -> decltype(hasBeenActivated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::hasBeenActivated), this);
	using FunctionType = decltype(hasBeenActivated())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getOrientedBox() -> decltype(getOrientedBox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getOrientedBox), this);
	using FunctionType = decltype(getOrientedBox())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d2440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::updateOrientedBox() -> decltype(updateOrientedBox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::updateOrientedBox), this);
	using FunctionType = decltype(updateOrientedBox())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d24c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRotation() -> decltype(getObjectRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRotation), this);
	using FunctionType = decltype(getObjectRotation())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5dac70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::updateMainColor(cocos2d::ccColor3B const& p0) -> decltype(updateMainColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::updateMainColor), this);
	using FunctionType = decltype(updateMainColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5d30c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateSecondaryColor(cocos2d::ccColor3B const& p0) -> decltype(updateSecondaryColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::updateSecondaryColor), this);
	using FunctionType = decltype(updateSecondaryColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5d35d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::addToGroup(int p0) -> decltype(addToGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x5c6f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::removeFromGroup(int p0) -> decltype(removeFromGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x5c6ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::saveActiveColors() -> decltype(saveActiveColors()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::saveActiveColors), this);
	using FunctionType = decltype(saveActiveColors())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d1520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::spawnXPosition() -> decltype(spawnXPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::spawnXPosition), this);
	using FunctionType = decltype(spawnXPosition())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::canAllowMultiActivate() -> decltype(canAllowMultiActivate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::canAllowMultiActivate), this);
	using FunctionType = decltype(canAllowMultiActivate())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::blendModeChanged() -> decltype(blendModeChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::blendModeChanged), this);
	using FunctionType = decltype(blendModeChanged())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::updateParticleColor(cocos2d::ccColor3B const& p0) -> decltype(updateParticleColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::updateParticleColor), this);
	using FunctionType = decltype(updateParticleColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5d18b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateParticleOpacity(unsigned char p0) -> decltype(updateParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::updateParticleOpacity), this);
	using FunctionType = decltype(updateParticleOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x5c5130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateMainParticleOpacity(unsigned char p0) -> decltype(updateMainParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::updateMainParticleOpacity), this);
	using FunctionType = decltype(updateMainParticleOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1ed2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateSecondaryParticleOpacity(unsigned char p0) -> decltype(updateSecondaryParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::updateSecondaryParticleOpacity), this);
	using FunctionType = decltype(updateSecondaryParticleOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1ed2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::canReverse() -> decltype(canReverse()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::canReverse), this);
	using FunctionType = decltype(canReverse())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::isSpecialSpawnObject() -> decltype(isSpecialSpawnObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isSpecialSpawnObject), this);
	using FunctionType = decltype(isSpecialSpawnObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::canBeOrdered() -> decltype(canBeOrdered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::canBeOrdered), this);
	using FunctionType = decltype(canBeOrdered())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectLabel() -> decltype(getObjectLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectLabel), this);
	using FunctionType = decltype(getObjectLabel())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setObjectLabel(cocos2d::CCLabelBMFont* p0) -> decltype(setObjectLabel(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCLabelBMFont*>::func(&GameObject::setObjectLabel), this);
	using FunctionType = decltype(setObjectLabel(p0))(*)(GameObject*, cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x1ed320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::shouldDrawEditorHitbox() -> decltype(shouldDrawEditorHitbox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::shouldDrawEditorHitbox), this);
	using FunctionType = decltype(shouldDrawEditorHitbox())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5d4710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getHasSyncedAnimation() -> decltype(getHasSyncedAnimation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getHasSyncedAnimation), this);
	using FunctionType = decltype(getHasSyncedAnimation())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getHasRotateAction() -> decltype(getHasRotateAction()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getHasRotateAction), this);
	using FunctionType = decltype(getHasRotateAction())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::canMultiActivate(bool p0) -> decltype(canMultiActivate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::canMultiActivate), this);
	using FunctionType = decltype(canMultiActivate(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1ed350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::updateTextKerning), this);
	using FunctionType = decltype(updateTextKerning(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x1ed360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getTextKerning() -> decltype(getTextKerning()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getTextKerning), this);
	using FunctionType = decltype(getTextKerning())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRectDirty() -> decltype(getObjectRectDirty()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRectDirty), this);
	using FunctionType = decltype(getObjectRectDirty())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setObjectRectDirty(bool p0) -> decltype(setObjectRectDirty(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setObjectRectDirty), this);
	using FunctionType = decltype(setObjectRectDirty(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1ed390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getOrientedRectDirty() -> decltype(getOrientedRectDirty()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getOrientedRectDirty), this);
	using FunctionType = decltype(getOrientedRectDirty())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setOrientedRectDirty(bool p0) -> decltype(setOrientedRectDirty(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setOrientedRectDirty), this);
	using FunctionType = decltype(setOrientedRectDirty(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1ed3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getType() -> decltype(getType()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getType), this);
	using FunctionType = decltype(getType())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setType(GameObjectType p0) -> decltype(setType(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObjectType>::func(&GameObject::setType), this);
	using FunctionType = decltype(setType(p0))(*)(GameObject*, GameObjectType);
	static auto func = wrapFunction(base::get() + 0x1ed3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getStartPos(cocos2d::CCPoint* p0) -> decltype(getStartPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint*>::func(&GameObject::getStartPos), this);
	using FunctionType = decltype(getStartPos(p0))(*)(GameObject*, cocos2d::CCPoint*);
	static auto func = wrapFunction(base::get() + 0x1ed3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5d5220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5d4a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EnhancedGameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(EnhancedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5d80e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EnhancedGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EnhancedGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x5d4d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EnhancedGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnhancedGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EnhancedGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x5d8140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EnhancedGameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(EnhancedGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5d4bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5d4b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::animationTriggered() -> decltype(animationTriggered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::animationTriggered), this);
	using FunctionType = decltype(animationTriggered())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5d4ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::activatedByPlayer(PlayerObject* p0) -> decltype(activatedByPlayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&EnhancedGameObject::activatedByPlayer), this);
	using FunctionType = decltype(activatedByPlayer(p0))(*)(EnhancedGameObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x5d4be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::hasBeenActivatedByPlayer(PlayerObject* p0) -> decltype(hasBeenActivatedByPlayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&EnhancedGameObject::hasBeenActivatedByPlayer), this);
	using FunctionType = decltype(hasBeenActivatedByPlayer(p0))(*)(EnhancedGameObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x5d4c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::hasBeenActivated() -> decltype(hasBeenActivated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::hasBeenActivated), this);
	using FunctionType = decltype(hasBeenActivated())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5d4c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::saveActiveColors() -> decltype(saveActiveColors()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::saveActiveColors), this);
	using FunctionType = decltype(saveActiveColors())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5d4cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::canAllowMultiActivate() -> decltype(canAllowMultiActivate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::canAllowMultiActivate), this);
	using FunctionType = decltype(canAllowMultiActivate())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5d4760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::getHasSyncedAnimation() -> decltype(getHasSyncedAnimation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::getHasSyncedAnimation), this);
	using FunctionType = decltype(getHasSyncedAnimation())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::getHasRotateAction() -> decltype(getHasRotateAction()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::getHasRotateAction), this);
	using FunctionType = decltype(getHasRotateAction())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::canMultiActivate(bool p0) -> decltype(canMultiActivate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EnhancedGameObject::canMultiActivate), this);
	using FunctionType = decltype(canMultiActivate(p0))(*)(EnhancedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5d4bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::powerOnObject(int p0) -> decltype(powerOnObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&EnhancedGameObject::powerOnObject), this);
	using FunctionType = decltype(powerOnObject(p0))(*)(EnhancedGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x5d4b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::powerOffObject() -> decltype(powerOffObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::powerOffObject), this);
	using FunctionType = decltype(powerOffObject())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5d4b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::stateSensitiveOff(GJBaseGameLayer* p0) -> decltype(stateSensitiveOff(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnhancedGameObject::stateSensitiveOff), this);
	using FunctionType = decltype(stateSensitiveOff(p0))(*)(EnhancedGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b61c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&EnhancedGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(EnhancedGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x2577a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EnhancedGameObject::updateAnimateOnTrigger(bool p0) -> decltype(updateAnimateOnTrigger(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EnhancedGameObject::updateAnimateOnTrigger), this);
	using FunctionType = decltype(updateAnimateOnTrigger(p0))(*)(EnhancedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2596c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&EffectGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(EffectGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1b46e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::firstSetup() -> decltype(firstSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::firstSetup), this);
	using FunctionType = decltype(firstSetup())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b6480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x192590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&EffectGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EffectGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1b4760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto EffectGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EffectGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EffectGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x193820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EffectGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EffectGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EffectGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x188160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::setRScaleX(float p0) -> decltype(setRScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EffectGameObject::setRScaleX), this);
	using FunctionType = decltype(setRScaleX(p0))(*)(EffectGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1b4370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::setRScaleY(float p0) -> decltype(setRScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EffectGameObject::setRScaleY), this);
	using FunctionType = decltype(setRScaleY(p0))(*)(EffectGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1b4390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EffectGameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(EffectGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1b6410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b61d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::spawnXPosition() -> decltype(spawnXPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::spawnXPosition), this);
	using FunctionType = decltype(spawnXPosition())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b63d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::canReverse() -> decltype(canReverse()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::canReverse), this);
	using FunctionType = decltype(canReverse())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b6570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::isSpecialSpawnObject() -> decltype(isSpecialSpawnObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::isSpecialSpawnObject), this);
	using FunctionType = decltype(isSpecialSpawnObject())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b65e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::canBeOrdered() -> decltype(canBeOrdered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::canBeOrdered), this);
	using FunctionType = decltype(canBeOrdered())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b65f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::getObjectLabel() -> decltype(getObjectLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::getObjectLabel), this);
	using FunctionType = decltype(getObjectLabel())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::setObjectLabel(cocos2d::CCLabelBMFont* p0) -> decltype(setObjectLabel(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCLabelBMFont*>::func(&EffectGameObject::setObjectLabel), this);
	using FunctionType = decltype(setObjectLabel(p0))(*)(EffectGameObject*, cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x1ed560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::stateSensitiveOff(GJBaseGameLayer* p0) -> decltype(stateSensitiveOff(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EffectGameObject::stateSensitiveOff), this);
	using FunctionType = decltype(stateSensitiveOff(p0))(*)(EffectGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b6130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AdvancedFollowTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&AdvancedFollowTriggerObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(AdvancedFollowTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1a75e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AdvancedFollowTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&AdvancedFollowTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(AdvancedFollowTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19e340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AdvancedFollowEditObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&AdvancedFollowEditObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(AdvancedFollowEditObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1a9880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AdvancedFollowEditObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&AdvancedFollowEditObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(AdvancedFollowEditObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a88b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedSpriteDelegate::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	throw std::runtime_error("AnimatedSpriteDelegate::animationFinished not implemented");
}

auto SpritePartDelegate::displayFrameChanged(cocos2d::CCObject* p0, gd::string p1) -> decltype(displayFrameChanged(p0, p1)) {
	throw std::runtime_error("SpritePartDelegate::displayFrameChanged not implemented");
}

auto AnimatedGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&AnimatedGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(AnimatedGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1b2620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&AnimatedGameObject::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(AnimatedGameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1b4260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AnimatedGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(AnimatedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b41f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AnimatedGameObject::activateObject() -> decltype(activateObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AnimatedGameObject::activateObject), this);
	using FunctionType = decltype(activateObject())(*)(AnimatedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b24a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AnimatedGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&AnimatedGameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(AnimatedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1b24e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&AnimatedGameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(AnimatedGameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1b2700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&AnimatedGameObject::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(AnimatedGameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x1b2730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::displayFrameChanged(cocos2d::CCObject* p0, gd::string p1) -> decltype(displayFrameChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*, gd::string>::func(&AnimatedGameObject::displayFrameChanged), this);
	using FunctionType = decltype(displayFrameChanged(p0, p1))(*)(AnimatedGameObject*, cocos2d::CCObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1b3a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCAnimatedSprite::cleanupSprite() -> decltype(cleanupSprite()) {
	using FunctionType = decltype(cleanupSprite())(*)(CCAnimatedSprite*);
	static auto func = wrapFunction(base::get() + 0x3509d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCAnimatedSprite::createWithType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(createWithType(p0, p1, p2)) {
	using FunctionType = decltype(createWithType(p0, p1, p2))(*)(char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x34ffe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto CCAnimatedSprite::initWithType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(initWithType(p0, p1, p2)) {
	using FunctionType = decltype(initWithType(p0, p1, p2))(*)(CCAnimatedSprite*, char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x3500c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCAnimatedSprite::loadType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(loadType(p0, p1, p2)) {
	using FunctionType = decltype(loadType(p0, p1, p2))(*)(CCAnimatedSprite*, char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x3502a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCAnimatedSprite::runAnimation(gd::string p0) -> decltype(runAnimation(p0)) {
	using FunctionType = decltype(runAnimation(p0))(*)(CCAnimatedSprite*, gd::string);
	static auto func = wrapFunction(base::get() + 0x350b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::runAnimationForced(gd::string p0) -> decltype(runAnimationForced(p0)) {
	using FunctionType = decltype(runAnimationForced(p0))(*)(CCAnimatedSprite*, gd::string);
	static auto func = wrapFunction(base::get() + 0x350c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::stopTween() -> decltype(stopTween()) {
	using FunctionType = decltype(stopTween())(*)(CCAnimatedSprite*);
	static auto func = wrapFunction(base::get() + 0x351190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCAnimatedSprite::switchToMode(spriteMode p0) -> decltype(switchToMode(p0)) {
	using FunctionType = decltype(switchToMode(p0))(*)(CCAnimatedSprite*, spriteMode);
	static auto func = wrapFunction(base::get() + 0x350a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::tweenToAnimation(gd::string p0, float p1) -> decltype(tweenToAnimation(p0, p1)) {
	using FunctionType = decltype(tweenToAnimation(p0, p1))(*)(CCAnimatedSprite*, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x350d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCAnimatedSprite::tweenToAnimationFinished() -> decltype(tweenToAnimationFinished()) {
	using FunctionType = decltype(tweenToAnimationFinished())(*)(CCAnimatedSprite*);
	static auto func = wrapFunction(base::get() + 0x3510a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCAnimatedSprite::willPlayAnimation() -> decltype(willPlayAnimation()) {
	using FunctionType = decltype(willPlayAnimation())(*)(CCAnimatedSprite*);
	static auto func = wrapFunction(base::get() + 0x350d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCAnimatedSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCAnimatedSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCAnimatedSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x351220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&CCAnimatedSprite::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(CCAnimatedSprite*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x3512d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CCAnimatedSprite::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(CCAnimatedSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x351200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::animationFinishedO(cocos2d::CCObject* p0) -> decltype(animationFinishedO(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CCAnimatedSprite::animationFinishedO), this);
	using FunctionType = decltype(animationFinishedO(p0))(*)(CCAnimatedSprite*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3511d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedShopKeeper::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&AnimatedShopKeeper::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(AnimatedShopKeeper*, char const*);
	static auto func = wrapFunction(base::get() + 0x3273d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AppDelegate::get() -> decltype(get()) {
	using FunctionType = decltype(get())(*)();
	static auto func = wrapFunction(base::get() + 0x669430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AppDelegate::applicationDidFinishLaunching() -> decltype(applicationDidFinishLaunching()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationDidFinishLaunching), this);
	using FunctionType = decltype(applicationDidFinishLaunching())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x6692b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationDidEnterBackground() -> decltype(applicationDidEnterBackground()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationDidEnterBackground), this);
	using FunctionType = decltype(applicationDidEnterBackground())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x669550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillEnterForeground() -> decltype(applicationWillEnterForeground()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillEnterForeground), this);
	using FunctionType = decltype(applicationWillEnterForeground())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x669690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillBecomeActive() -> decltype(applicationWillBecomeActive()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillBecomeActive), this);
	using FunctionType = decltype(applicationWillBecomeActive())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x669450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillResignActive() -> decltype(applicationWillResignActive()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillResignActive), this);
	using FunctionType = decltype(applicationWillResignActive())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x669470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::trySaveGame(bool p0) -> decltype(trySaveGame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&AppDelegate::trySaveGame), this);
	using FunctionType = decltype(trySaveGame(p0))(*)(AppDelegate*, bool);
	static auto func = wrapFunction(base::get() + 0x669920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AppDelegate::willSwitchToScene(cocos2d::CCScene* p0) -> decltype(willSwitchToScene(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCScene*>::func(&AppDelegate::willSwitchToScene), this);
	using FunctionType = decltype(willSwitchToScene(p0))(*)(AppDelegate*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x669a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ArtistCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ArtistCell::init), this);
	using FunctionType = decltype(init())(*)(ArtistCell*);
	static auto func = wrapFunction(base::get() + 0x250270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ArtistCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ArtistCell::draw), this);
	using FunctionType = decltype(draw())(*)(ArtistCell*);
	static auto func = wrapFunction(base::get() + 0x2504f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioAssetsBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AudioAssetsBrowser::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(AudioAssetsBrowser*);
	static auto func = wrapFunction(base::get() + 0x7c14e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioAssetsBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AudioAssetsBrowser::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(AudioAssetsBrowser*);
	static auto func = wrapFunction(base::get() + 0x7c1470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioAssetsBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&AudioAssetsBrowser::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(AudioAssetsBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x7c1390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AudioAssetsBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&AudioAssetsBrowser::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(AudioAssetsBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x7c13c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AudioAssetsBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&AudioAssetsBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(AudioAssetsBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x7c1400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto AudioAssetsBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AudioAssetsBrowser::getSelectedCellIdx), this);
	using FunctionType = decltype(getSelectedCellIdx())(*)(AudioAssetsBrowser*);
	static auto func = wrapFunction(base::get() + 0x7c1420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioAssetsBrowser::getCellDelegateType() -> decltype(getCellDelegateType()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AudioAssetsBrowser::getCellDelegateType), this);
	using FunctionType = decltype(getCellDelegateType())(*)(AudioAssetsBrowser*);
	static auto func = wrapFunction(base::get() + 0x7c1440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ArtTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&ArtTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(ArtTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1e6ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto ArtTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&ArtTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ArtTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1e6e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ArtTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ArtTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ArtTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1e6960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void AudioEffectsLayer::draw() {}

auto AudioEffectsLayer::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&AudioEffectsLayer::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(AudioEffectsLayer*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x4b9b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AudioLineGuideGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AudioLineGuideGameObject::init), this);
	using FunctionType = decltype(init())(*)(AudioLineGuideGameObject*);
	static auto func = wrapFunction(base::get() + 0x1e4460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioLineGuideGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&AudioLineGuideGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(AudioLineGuideGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1e51c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AudioLineGuideGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&AudioLineGuideGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(AudioLineGuideGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1e44b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto BitmapFontCache::fontWithConfigFile(char const* p0, float p1) -> decltype(fontWithConfigFile(p0, p1)) {
	using FunctionType = decltype(fontWithConfigFile(p0, p1))(*)(BitmapFontCache*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x21a7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void TableViewDelegate::willTweenToIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::didEndTweenToIndexPath(CCIndexPath& p0, TableView* p1) {}

void TableViewDelegate::TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::TableViewDidDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

float TableViewDelegate::cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) { return 0; }

void TableViewDelegate::didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {}

int TableViewDataSource::numberOfRowsInSection(unsigned int p0, TableView* p1) { return 0; }

unsigned int TableViewDataSource::numberOfSectionsInTableView(TableView* p0) { return 0; }

void TableViewDataSource::TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {}

TableViewCell* TableViewDataSource::cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) { return nullptr; }

BoomListView::BoomListView() {}

BoomListView::~BoomListView() {
		CC_SAFE_RELEASE(m_entries);
	}

auto BoomListView::create(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0x30ba20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto BoomListView::init(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(BoomListView*, cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0x30bb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto BoomListView::lockList(bool p0) -> decltype(lockList(p0)) {
	using FunctionType = decltype(lockList(p0))(*)(BoomListView*, bool);
	static auto func = wrapFunction(base::get() + 0x30bd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool BoomListView::init(cocos2d::CCArray* entries, BoomListType type, float width, float height) {
		return this->init(entries, nullptr, height, width, 0, type, 0.0f);
	}

void BoomListView::draw() {}

auto BoomListView::setupList(float p0) -> decltype(setupList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&BoomListView::setupList), this);
	using FunctionType = decltype(setupList(p0))(*)(BoomListView*, float);
	static auto func = wrapFunction(base::get() + 0x30bd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void BoomListView::TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

auto BoomListView::cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) -> decltype(cellHeightForRowAtIndexPath(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCIndexPath&, TableView*>::func(&BoomListView::cellHeightForRowAtIndexPath), this);
	using FunctionType = decltype(cellHeightForRowAtIndexPath(p0, p1))(*)(BoomListView*, CCIndexPath&, TableView*);
	static auto func = wrapFunction(base::get() + 0x30be60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void BoomListView::didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {}

auto BoomListView::numberOfRowsInSection(unsigned p0, TableView* p1) -> decltype(numberOfRowsInSection(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned, TableView*>::func(&BoomListView::numberOfRowsInSection), this);
	using FunctionType = decltype(numberOfRowsInSection(p0, p1))(*)(BoomListView*, unsigned, TableView*);
	static auto func = wrapFunction(base::get() + 0x30bea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

unsigned int BoomListView::numberOfSectionsInTableView(TableView* p0) { return 1; }

auto BoomListView::cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) -> decltype(cellForRowAtIndexPath(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCIndexPath&, TableView*>::func(&BoomListView::cellForRowAtIndexPath), this);
	using FunctionType = decltype(cellForRowAtIndexPath(p0, p1))(*)(BoomListView*, CCIndexPath&, TableView*);
	static auto func = wrapFunction(base::get() + 0x30bef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {}

void BoomListView::TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

auto BoomListView::getListCell(char const* p0) -> decltype(getListCell(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&BoomListView::getListCell), this);
	using FunctionType = decltype(getListCell(p0))(*)(BoomListView*, char const*);
	static auto func = wrapFunction(base::get() + 0x30c000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto BoomListView::loadCell(TableViewCell* p0, int p1) -> decltype(loadCell(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int>::func(&BoomListView::loadCell), this);
	using FunctionType = decltype(loadCell(p0, p1))(*)(BoomListView*, TableViewCell*, int);
	static auto func = wrapFunction(base::get() + 0x30c240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::create(cocos2d::CCArray* pages, int unk1, bool unk2, cocos2d::CCArray* unk3, DynamicScrollDelegate* delegate) -> decltype(create(pages, unk1, unk2, unk3, delegate)) {
	using FunctionType = decltype(create(pages, unk1, unk2, unk3, delegate))(*)(cocos2d::CCArray*, int, bool, cocos2d::CCArray*, DynamicScrollDelegate*);
	static auto func = wrapFunction(base::get() + 0x3a7d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(pages, unk1, unk2, unk3, delegate);
}

auto BoomScrollLayer::create(cocos2d::CCArray* pages, int unk1, bool unk2) -> decltype(create(pages, unk1, unk2)) {
	using FunctionType = decltype(create(pages, unk1, unk2))(*)(cocos2d::CCArray*, int, bool);
	static auto func = wrapFunction(base::get() + 0x3a8120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(pages, unk1, unk2);
}

auto BoomScrollLayer::init(cocos2d::CCArray* p0, int p1, bool p2, cocos2d::CCArray* p3, DynamicScrollDelegate* p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(BoomScrollLayer*, cocos2d::CCArray*, int, bool, cocos2d::CCArray*, DynamicScrollDelegate*);
	static auto func = wrapFunction(base::get() + 0x3a7dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto BoomScrollLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&BoomScrollLayer::visit), this);
	using FunctionType = decltype(visit())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x3a9570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto BoomScrollLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3aa0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3aa190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3aa4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3a9ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&BoomScrollLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x3a9d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto BoomScrollLayerDelegate::scrollLayerScrollingStarted(BoomScrollLayer* p0) -> decltype(scrollLayerScrollingStarted(p0)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerScrollingStarted not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerScrolledToPage not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerMoved not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerWillScrollToPage not implemented");
}

auto BrowseSmartTemplateLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&BrowseSmartTemplateLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(BrowseSmartTemplateLayer*);
	static auto func = wrapFunction(base::get() + 0x4f5220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto BrowseSmartTemplateLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&BrowseSmartTemplateLayer::onBack), this);
	using FunctionType = decltype(onBack(sender))(*)(BrowseSmartTemplateLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4f5260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto BrowseSmartKeyLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&BrowseSmartKeyLayer::onBack), this);
	using FunctionType = decltype(onBack(sender))(*)(BrowseSmartKeyLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4f6c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

ButtonSprite* ButtonSprite::create(cocos2d::CCSprite* topSprite, int width, bool absolute, float height, const char* texture, float scale) {
		return create(topSprite, width, 0, height, scale, absolute, texture, true);
	}

ButtonSprite* ButtonSprite::create(const char* caption, int width, bool absolute, const char* font, const char* texture, float height, float scale) {
		return create(caption, width, 0, scale, absolute, font, texture, height);
	}

ButtonSprite* ButtonSprite::create(char const* caption) {
		return ButtonSprite::create(caption, 0, 0, "goldFont.fnt", "GJ_button_01.png", .0f, 1.f);
	}

ButtonSprite* ButtonSprite::create(char const* caption, const char* font, const char* texture) {
		return ButtonSprite::create(caption, 0, 0, font, texture, .0f, 1.f);
	}

ButtonSprite* ButtonSprite::create(char const* caption, const char* font, const char* texture, float scale) {
		return ButtonSprite::create(caption, 0, 0, font, texture, .0f, scale);
	}

auto ButtonSprite::create(char const* a, int b, int c, float d, bool e, char const* f, char const* g, float h) -> decltype(create(a, b, c, d, e, f, g, h)) {
	using FunctionType = decltype(create(a, b, c, d, e, f, g, h))(*)(char const*, int, int, float, bool, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x92140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(a, b, c, d, e, f, g, h);
}

auto ButtonSprite::create(char const* p0, int p1, int p2, float p3, bool p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(char const*, int, int, float, bool);
	static auto func = wrapFunction(base::get() + 0x920f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto ButtonSprite::create(cocos2d::CCSprite* topSprite, int width, int unused, float height, float a, bool b, char const* bgSprite, bool noScaleSpriteForBG) -> decltype(create(topSprite, width, unused, height, a, b, bgSprite, noScaleSpriteForBG)) {
	using FunctionType = decltype(create(topSprite, width, unused, height, a, b, bgSprite, noScaleSpriteForBG))(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x918c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(topSprite, width, unused, height, a, b, bgSprite, noScaleSpriteForBG);
}

void ButtonSprite::setColor(cocos2d::_ccColor3B const& color) {
		// i love inlined funcs
		m_label->setColor(color);
  		m_subSprite->setColor(color);
  		m_subBGSprite->setColor(color);
  		m_BGSprite->setColor(color);
	}

auto ButtonSprite::setString(char const* p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(ButtonSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x92530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::updateBGImage(char const* p0) -> decltype(updateBGImage(p0)) {
	using FunctionType = decltype(updateBGImage(p0))(*)(ButtonSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x92920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CameraTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&CameraTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CameraTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1d7b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CameraTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&CameraTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(CameraTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1dbe80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CameraTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&CameraTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(CameraTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1d7d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAlertCircle::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCAlertCircle::init), this);
	using FunctionType = decltype(init())(*)(CCAlertCircle*);
	static auto func = wrapFunction(base::get() + 0x1742b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCAlertCircle::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCAlertCircle::draw), this);
	using FunctionType = decltype(draw())(*)(CCAlertCircle*);
	static auto func = wrapFunction(base::get() + 0x174340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

CCBlockLayer::CCBlockLayer() {
		m_unknown = nullptr;
	}

auto CCBlockLayer::init() -> decltype(init()) {
	throw std::runtime_error("CCBlockLayer::init not implemented");
}

auto CCBlockLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::draw), this);
	using FunctionType = decltype(draw())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x520b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCBlockLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCBlockLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x520bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void CCBlockLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCBlockLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCBlockLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto CCBlockLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x520a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x520a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCBlockLayer::customSetup() {}

auto CCBlockLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x520a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::exitLayer() -> decltype(exitLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x520ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCBlockLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(CCBlockLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x520af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCBlockLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCBlockLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(CCBlockLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x520b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCBlockLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x520b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x520b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCBlockLayer::enterAnimFinished() {}

void CCBlockLayer::disableUI() {}

void CCBlockLayer::enableUI() {}

auto CCCircleWave::create(float startRadius, float endRadius, float duration, bool fadeIn, bool easeOut) -> decltype(create(startRadius, endRadius, duration, fadeIn, easeOut)) {
	using FunctionType = decltype(create(startRadius, endRadius, duration, fadeIn, easeOut))(*)(float, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x173740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(startRadius, endRadius, duration, fadeIn, easeOut);
}

auto CCCircleWave::create(float startRadius, float endRadius, float duration, bool fadeIn) -> decltype(create(startRadius, endRadius, duration, fadeIn)) {
	using FunctionType = decltype(create(startRadius, endRadius, duration, fadeIn))(*)(float, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x173730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(startRadius, endRadius, duration, fadeIn);
}

auto CCCircleWave::followObject(cocos2d::CCNode* p0, bool p1) -> decltype(followObject(p0, p1)) {
	using FunctionType = decltype(followObject(p0, p1))(*)(CCCircleWave*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x173af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCCircleWave::init(float startRadius, float endRadius, float duration, bool fadeIn, bool easeOut) -> decltype(init(startRadius, endRadius, duration, fadeIn, easeOut)) {
	using FunctionType = decltype(init(startRadius, endRadius, duration, fadeIn, easeOut))(*)(CCCircleWave*, float, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x173820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, startRadius, endRadius, duration, fadeIn, easeOut);
}

auto CCCircleWave::updatePosition(float p0) -> decltype(updatePosition(p0)) {
	using FunctionType = decltype(updatePosition(p0))(*)(CCCircleWave*, float);
	static auto func = wrapFunction(base::get() + 0x173ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCCircleWave::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCCircleWave::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCCircleWave*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x173a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCCircleWave::removeMeAndCleanup() -> decltype(removeMeAndCleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCCircleWave::removeMeAndCleanup), this);
	using FunctionType = decltype(removeMeAndCleanup())(*)(CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0x173f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCircleWave::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCCircleWave::draw), this);
	using FunctionType = decltype(draw())(*)(CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0x173dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCircleWave::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&CCCircleWave::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(CCCircleWave*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x173b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void CCCircleWaveDelegate::circleWaveWillBeRemoved(CCCircleWave* p0) {}

CCContentLayer::~CCContentLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(CCContentLayer*);
	static auto func = wrapFunction(base::get() + 0x4bc530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) CCContentLayer(geode::CutoffConstructor, sizeof(CCContentLayer));
	CCDestructor::lock(this) = true;
}

auto CCContentLayer::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCContentLayer::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCContentLayer*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x7cf6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCCountdown::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCCountdown::init), this);
	using FunctionType = decltype(init())(*)(CCCountdown*);
	static auto func = wrapFunction(base::get() + 0x7d32c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCountdown::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCCountdown::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCCountdown*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x7d3690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCLightFlash::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCLightFlash::init), this);
	using FunctionType = decltype(init())(*)(CCLightFlash*);
	static auto func = wrapFunction(base::get() + 0x50e550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCLightStrip::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCLightStrip::draw), this);
	using FunctionType = decltype(draw())(*)(CCLightStrip*);
	static auto func = wrapFunction(base::get() + 0x50f020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCLightStrip::updateTweenAction(float value, char const* keyword) -> decltype(updateTweenAction(value, keyword)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&CCLightStrip::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(value, keyword))(*)(CCLightStrip*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x50f1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, value, keyword);
}

CCMenuItemSpriteExtra::~CCMenuItemSpriteExtra() {}

CCMenuItemSpriteExtra::CCMenuItemSpriteExtra() {
		m_scaleMultiplier = 1.0f;
		m_baseScale = 1.0f;
		m_animationEnabled = true;
		m_colorEnabled = false;
		m_unknown1 = 0.0f;
		m_colorDip = 0.0f;
		m_animationType = MenuAnimationType::Scale;
		m_unknown4 = 0;
	}

auto CCMenuItemSpriteExtra::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x272d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

CCMenuItemSpriteExtra* CCMenuItemSpriteExtra::create(cocos2d::CCNode* sprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) {
		return CCMenuItemSpriteExtra::create(sprite, nullptr, target, callback);
	}

auto CCMenuItemSpriteExtra::init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(CCMenuItemSpriteExtra*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x272d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

void CCMenuItemSpriteExtra::setSizeMult(float mult) {
		//inlined on windows, member is in CCMenuItemSprite
		m_fSizeMult = mult;
	}

auto CCMenuItemSpriteExtra::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::activate), this);
	using FunctionType = decltype(activate())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x272f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::selected), this);
	using FunctionType = decltype(selected())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x273090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::unselected), this);
	using FunctionType = decltype(unselected())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x273300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCMenuItemSpriteExtra::setSprite(cocos2d::CCSprite* sprite) {
		this->setNormalImage(sprite);
		this->updateSprite();
	}

void CCMenuItemSpriteExtra::updateSprite() {
		auto sprite = this->getNormalImage();
		auto size = sprite->getScaledContentSize();
		sprite->setPosition(size / 2);
		sprite->setAnchorPoint({ .5f, .5f });
		this->setContentSize(size);
	}

CCMenuItemToggler::CCMenuItemToggler() {}

auto CCMenuItemToggler::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x5a6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

CCMenuItemToggler* CCMenuItemToggler::createWithSize(const char* spr1, const char* spr2, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
		auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName(spr1);
		auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName(spr2);

		sprOff->setScale(scale);
		sprOn->setScale(scale);

		return create(sprOff, sprOn, target, callback);
	}

CCMenuItemToggler* CCMenuItemToggler::createWithStandardSprites(cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
		auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
		auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");

		float maxWidth = (std::max)(sprOff->getContentSize().width, sprOn->getContentSize().width);
		float maxHeight = (std::max)(sprOff->getContentSize().height, sprOn->getContentSize().height);

		sprOff->setScale(scale);
		sprOn->setScale(scale);

		auto ret = create(sprOff, sprOn, target, callback);

		ret->setContentSize({maxWidth, maxHeight});

		ret->m_offButton->setContentSize({maxWidth, maxHeight});
		ret->m_onButton->setContentSize({maxWidth, maxHeight});

 		ret->m_offButton->setPosition({maxWidth/2, maxHeight/2});
		ret->m_onButton->setPosition({maxWidth/2, maxHeight/2});

		sprOff->setPosition({maxWidth/2, maxHeight/2});
		sprOn->setPosition({maxWidth/2, maxHeight/2});

		return ret;
	}

auto CCMenuItemToggler::init(cocos2d::CCNode* off, cocos2d::CCNode* on, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) -> decltype(init(off, on, target, callback)) {
	using FunctionType = decltype(init(off, on, target, callback))(*)(CCMenuItemToggler*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x5a780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, off, on, target, callback);
}

auto CCMenuItemToggler::setSizeMult(float mult) -> decltype(setSizeMult(mult)) {
	using FunctionType = decltype(setSizeMult(mult))(*)(CCMenuItemToggler*, float);
	static auto func = wrapFunction(base::get() + 0x5ac30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, mult);
}

auto CCMenuItemToggler::toggle(bool p0) -> decltype(toggle(p0)) {
	using FunctionType = decltype(toggle(p0))(*)(CCMenuItemToggler*, bool);
	static auto func = wrapFunction(base::get() + 0x5ab60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool CCMenuItemToggler::isToggled() {
		return m_toggled;
	}

bool CCMenuItemToggler::isOn() {
		return m_toggled;
	}

void CCMenuItemToggler::setClickable(bool on) {
		m_notClickable = !on;
	}

void CCMenuItemToggler::toggleWithCallback(bool on) {
		this->activate();
		this->toggle(on);
	}

auto CCMenuItemToggler::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::activate), this);
	using FunctionType = decltype(activate())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x5ad70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::selected), this);
	using FunctionType = decltype(selected())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x5ad40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::unselected), this);
	using FunctionType = decltype(unselected())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x5ada0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::setEnabled(bool p0) -> decltype(setEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCMenuItemToggler::setEnabled), this);
	using FunctionType = decltype(setEnabled(p0))(*)(CCMenuItemToggler*, bool);
	static auto func = wrapFunction(base::get() + 0x5add0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void CCMenuItemToggler::updateSprite() {
		m_offButton->updateSprite();
		m_onButton->updateSprite();
		auto size = m_offButton->getScaledContentSize();
		m_offButton->setPosition(size / 2);
		m_offButton->setAnchorPoint({ .5f, .5f });
		m_onButton->setPosition(size / 2);
		m_onButton->setAnchorPoint({ .5f, .5f });
		this->setContentSize(size);
	}

auto CCNodeContainer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCNodeContainer::init), this);
	using FunctionType = decltype(init())(*)(CCNodeContainer*);
	static auto func = wrapFunction(base::get() + 0x159cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCNodeContainer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCNodeContainer::visit), this);
	using FunctionType = decltype(visit())(*)(CCNodeContainer*);
	static auto func = wrapFunction(base::get() + 0x159cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCPartAnimSprite::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCPartAnimSprite::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(CCPartAnimSprite*, float);
	static auto func = wrapFunction(base::get() + 0x376d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCPartAnimSprite::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(CCPartAnimSprite*, float);
	static auto func = wrapFunction(base::get() + 0x376db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCPartAnimSprite::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(CCPartAnimSprite*, float);
	static auto func = wrapFunction(base::get() + 0x376d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCPartAnimSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCPartAnimSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x377020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccBlendFunc>::func(&CCPartAnimSprite::setBlendFunc), this);
	using FunctionType = decltype(setBlendFunc(p0))(*)(CCPartAnimSprite*, cocos2d::_ccBlendFunc);
	static auto func = wrapFunction(base::get() + 0x376dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setDisplayFrame(cocos2d::CCSpriteFrame* p0) -> decltype(setDisplayFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&CCPartAnimSprite::setDisplayFrame), this);
	using FunctionType = decltype(setDisplayFrame(p0))(*)(CCPartAnimSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x376940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::isFrameDisplayed(cocos2d::CCSpriteFrame* p0) -> decltype(isFrameDisplayed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&CCPartAnimSprite::isFrameDisplayed), this);
	using FunctionType = decltype(isFrameDisplayed(p0))(*)(CCPartAnimSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x376ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::displayFrame() -> decltype(displayFrame()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCPartAnimSprite::displayFrame), this);
	using FunctionType = decltype(displayFrame())(*)(CCPartAnimSprite*);
	static auto func = wrapFunction(base::get() + 0x376ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

CCScrollLayerExt::CCScrollLayerExt(cocos2d::CCRect p0) : CCScrollLayerExt(geode::CutoffConstructor, sizeof(CCScrollLayerExt)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	CCScrollLayerExt::~CCScrollLayerExt();
	using FunctionType = void(*)(CCScrollLayerExt*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x437b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::moveToTop() -> decltype(moveToTop()) {
	using FunctionType = decltype(moveToTop())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x438240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCScrollLayerExt::moveToTopWithOffset(float p0) -> decltype(moveToTopWithOffset(p0)) {
	using FunctionType = decltype(moveToTopWithOffset(p0))(*)(CCScrollLayerExt*, float);
	static auto func = wrapFunction(base::get() + 0x4381a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::scrollLayer(float offset) -> decltype(scrollLayer(offset)) {
	using FunctionType = decltype(scrollLayer(offset))(*)(CCScrollLayerExt*, float);
	static auto func = wrapFunction(base::get() + 0x438e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, offset);
}

auto CCScrollLayerExt::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::visit), this);
	using FunctionType = decltype(visit())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x438ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x438850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x438c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x438980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x438c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x438810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::preVisitWithClippingRect(cocos2d::CCRect p0) -> decltype(preVisitWithClippingRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect>::func(&CCScrollLayerExt::preVisitWithClippingRect), this);
	using FunctionType = decltype(preVisitWithClippingRect(p0))(*)(CCScrollLayerExt*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x438fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCScrollLayerExt::postVisit() -> decltype(postVisit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::postVisit), this);
	using FunctionType = decltype(postVisit())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x439040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCScrollLayerExtDelegate::scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewDidEndDecelerating(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchMoving(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewDidEndMoving(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchBegin(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchEnd(CCScrollLayerExt* p0) {}

auto CCSpriteCOpacity::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCSpriteCOpacity::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCSpriteCOpacity*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x48b250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpriteWithHue::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::draw), this);
	using FunctionType = decltype(draw())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x5fb200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x5faad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(initWithTexture(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x5fab40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) -> decltype(initWithTexture(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1, p2))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool);
	static auto func = wrapFunction(base::get() + 0x5fa890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CCSpriteWithHue::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(initWithSpriteFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&CCSpriteWithHue::initWithSpriteFrame), this);
	using FunctionType = decltype(initWithSpriteFrame(p0))(*)(CCSpriteWithHue*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x5fab60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpriteWithHue::getShaderName() -> decltype(getShaderName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::getShaderName), this);
	using FunctionType = decltype(getShaderName())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x5fa3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::shaderBody() -> decltype(shaderBody()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::shaderBody), this);
	using FunctionType = decltype(shaderBody())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x5faca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::updateColor() -> decltype(updateColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::updateColor), this);
	using FunctionType = decltype(updateColor())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x5facc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteGrayscale::getShaderName() -> decltype(getShaderName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteGrayscale::getShaderName), this);
	using FunctionType = decltype(getShaderName())(*)(CCSpriteGrayscale*);
	static auto func = wrapFunction(base::get() + 0x5fb5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteGrayscale::shaderBody() -> decltype(shaderBody()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteGrayscale::shaderBody), this);
	using FunctionType = decltype(shaderBody())(*)(CCSpriteGrayscale*);
	static auto func = wrapFunction(base::get() + 0x5fb3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpritePart::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePart::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(CCSpritePart*, bool);
	static auto func = wrapFunction(base::get() + 0x377410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

CCTextInputNode::CCTextInputNode() {
		m_numberInput = false;
		m_caption = "";
		m_unknown1 = 0;
		m_selected = false;
		m_unknown2 = false;
		m_fontValue1 = -0.5f;
		m_fontValue2 = 8.0f;
		m_isChatFont = false;
		m_allowedChars = "";
		m_maxLabelWidth = 0.0f;
		m_maxLabelScale = 0.0f;
		m_placeholderScale = 0.0f;
		m_placeholderColor = cocos2d::ccc3(0, 0, 0);
		m_textColor = cocos2d::ccc3(0, 0, 0);
		m_cursor = nullptr;
		m_textField = nullptr;
		m_delegate = nullptr;
		m_maxLabelLength = 0;
		m_placeholderLabel = nullptr;
		m_filterSwearWords = false;
		m_usePasswordChar = false;
		m_forceOffset = false;
		m_textArea = nullptr;
	}

auto CCTextInputNode::create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(float, float, char const*, char const*, int, char const*);
	static auto func = wrapFunction(base::get() + 0x9d950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

CCTextInputNode* CCTextInputNode::create(float width, float height, char const* placeholder, char const* fontPath) {
		return CCTextInputNode::create(width, height, placeholder, 0x18, fontPath);
	}

CCTextInputNode* CCTextInputNode::create(float width, float height, char const* placeholder, int fontSize, char const* fontPath) {
		return CCTextInputNode::create(width, height, placeholder, "Thonburi", fontSize, fontPath);
	}

void CCTextInputNode::setDelegate(TextInputDelegate* delegate) {
		m_delegate = delegate;
	}

auto CCTextInputNode::setMaxLabelScale(float v) -> decltype(setMaxLabelScale(v)) {
	using FunctionType = decltype(setMaxLabelScale(v))(*)(CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x9e840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, v);
}

auto CCTextInputNode::setMaxLabelWidth(float v) -> decltype(setMaxLabelWidth(v)) {
	using FunctionType = decltype(setMaxLabelWidth(v))(*)(CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x9e860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, v);
}

void CCTextInputNode::setMaxLabelLength(int v) {
		m_maxLabelLength = v;
		this->refreshLabel();
	}

auto CCTextInputNode::setLabelPlaceholderScale(float v) -> decltype(setLabelPlaceholderScale(v)) {
	using FunctionType = decltype(setLabelPlaceholderScale(v))(*)(CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x9e880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, v);
}

auto CCTextInputNode::setLabelPlaceholderColor(cocos2d::ccColor3B color) -> decltype(setLabelPlaceholderColor(color)) {
	using FunctionType = decltype(setLabelPlaceholderColor(color))(*)(CCTextInputNode*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x9e8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, color);
}

void CCTextInputNode::setAllowedChars(gd::string filter) {
		m_allowedChars = filter;
	}

cocos2d::CCLabelBMFont* CCTextInputNode::getPlaceholderLabel() {
		return m_placeholderLabel;
	}

auto CCTextInputNode::addTextArea(TextArea* p0) -> decltype(addTextArea(p0)) {
	using FunctionType = decltype(addTextArea(p0))(*)(CCTextInputNode*, TextArea*);
	static auto func = wrapFunction(base::get() + 0x9de60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::forceOffset() -> decltype(forceOffset()) {
	using FunctionType = decltype(forceOffset())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0xa02c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

gd::string CCTextInputNode::getString() {
		return m_textField->getString();
	}

auto CCTextInputNode::init(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(CCTextInputNode*, float, float, char const*, char const*, int, char const*);
	static auto func = wrapFunction(base::get() + 0x9db00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto CCTextInputNode::refreshLabel() -> decltype(refreshLabel()) {
	using FunctionType = decltype(refreshLabel())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x9e600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCTextInputNode::setLabelNormalColor(cocos2d::ccColor3B color) -> decltype(setLabelNormalColor(color)) {
	using FunctionType = decltype(setLabelNormalColor(color))(*)(CCTextInputNode*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x9e8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, color);
}

auto CCTextInputNode::setString(gd::string p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x9e450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::updateBlinkLabelToChar(int p0) -> decltype(updateBlinkLabelToChar(p0)) {
	using FunctionType = decltype(updateBlinkLabelToChar(p0))(*)(CCTextInputNode*, int);
	static auto func = wrapFunction(base::get() + 0x9e8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::updateCursorPosition(cocos2d::CCPoint p0, cocos2d::CCRect p1) -> decltype(updateCursorPosition(p0, p1)) {
	using FunctionType = decltype(updateCursorPosition(p0, p1))(*)(CCTextInputNode*, cocos2d::CCPoint, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0xa02d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCTextInputNode::updateLabel(gd::string p0) -> decltype(updateLabel(p0)) {
	using FunctionType = decltype(updateLabel(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x9e0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::visit), this);
	using FunctionType = decltype(visit())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x9e3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCTextInputNode::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0xa0840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void CCTextInputNode::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCTextInputNode::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCTextInputNode::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto CCTextInputNode::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0xa0a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::textChanged() -> decltype(textChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::textChanged), this);
	using FunctionType = decltype(textChanged())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x9efb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::onClickTrackNode(bool p0) -> decltype(onClickTrackNode(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCTextInputNode::onClickTrackNode), this);
	using FunctionType = decltype(onClickTrackNode(p0))(*)(CCTextInputNode*, bool);
	static auto func = wrapFunction(base::get() + 0x9ef90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) -> decltype(keyboardWillShow(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCIMEKeyboardNotificationInfo&>::func(&CCTextInputNode::keyboardWillShow), this);
	using FunctionType = decltype(keyboardWillShow(p0))(*)(CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
	static auto func = wrapFunction(base::get() + 0x9ed30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) -> decltype(keyboardWillHide(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCIMEKeyboardNotificationInfo&>::func(&CCTextInputNode::keyboardWillHide), this);
	using FunctionType = decltype(keyboardWillHide(p0))(*)(CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
	static auto func = wrapFunction(base::get() + 0x9ef10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::onTextFieldInsertText(cocos2d::CCTextFieldTTF* pSender, char const* text, int nLen, cocos2d::enumKeyCodes keyCodes) -> decltype(onTextFieldInsertText(pSender, text, nLen, keyCodes)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*, char const*, int, cocos2d::enumKeyCodes>::func(&CCTextInputNode::onTextFieldInsertText), this);
	using FunctionType = decltype(onTextFieldInsertText(pSender, text, nLen, keyCodes))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*, char const*, int, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x9f0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, pSender, text, nLen, keyCodes);
}

auto CCTextInputNode::onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* tField) -> decltype(onTextFieldAttachWithIME(tField)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*>::func(&CCTextInputNode::onTextFieldAttachWithIME), this);
	using FunctionType = decltype(onTextFieldAttachWithIME(tField))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*);
	static auto func = wrapFunction(base::get() + 0x9f820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, tField);
}

auto CCTextInputNode::onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* tField) -> decltype(onTextFieldDetachWithIME(tField)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*>::func(&CCTextInputNode::onTextFieldDetachWithIME), this);
	using FunctionType = decltype(onTextFieldDetachWithIME(tField))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*);
	static auto func = wrapFunction(base::get() + 0x9fb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, tField);
}

auto GJChallengeDelegate::challengeStatusFinished() -> decltype(challengeStatusFinished()) {
	throw std::runtime_error("GJChallengeDelegate::challengeStatusFinished not implemented");
}

auto GJChallengeDelegate::challengeStatusFailed() -> decltype(challengeStatusFailed()) {
	throw std::runtime_error("GJChallengeDelegate::challengeStatusFailed not implemented");
}

void CurrencyRewardDelegate::currencyWillExit(CurrencyRewardLayer* p0) {}

auto ChallengesPage::createChallengeNode(int number, bool skipAnimation, float animLength, bool isNew) -> decltype(createChallengeNode(number, skipAnimation, animLength, isNew)) {
	using FunctionType = decltype(createChallengeNode(number, skipAnimation, animLength, isNew))(*)(ChallengesPage*, int, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0x3a0dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, number, skipAnimation, animLength, isNew);
}

auto ChallengesPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::init), this);
	using FunctionType = decltype(init())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x3a0090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x3a17c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x3a1730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::show), this);
	using FunctionType = decltype(show())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x3a1590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void ChallengesPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto ChallengesPage::challengeStatusFinished() -> decltype(challengeStatusFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::challengeStatusFinished), this);
	using FunctionType = decltype(challengeStatusFinished())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x3a1090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::challengeStatusFailed() -> decltype(challengeStatusFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::challengeStatusFailed), this);
	using FunctionType = decltype(challengeStatusFailed())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x3a13a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CurrencyRewardLayer*>::func(&ChallengesPage::currencyWillExit), this);
	using FunctionType = decltype(currencyWillExit(p0))(*)(ChallengesPage*, CurrencyRewardLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJChallengeItem::encodeWithCoder(DS_Dictionary* dsdict) -> decltype(encodeWithCoder(dsdict)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJChallengeItem::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(dsdict))(*)(GJChallengeItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8ec40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, dsdict);
}

auto GJChallengeItem::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJChallengeItem::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJChallengeItem*);
	static auto func = wrapFunction(base::get() + 0x8ed10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengeNode::create(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) -> decltype(create(challengeItem, challengesPage, isNew)) {
	using FunctionType = decltype(create(challengeItem, challengesPage, isNew))(*)(GJChallengeItem*, ChallengesPage*, bool);
	static auto func = wrapFunction(base::get() + 0x3a1490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(challengeItem, challengesPage, isNew);
}

auto ChallengeNode::init(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) -> decltype(init(challengeItem, challengesPage, isNew)) {
	using FunctionType = decltype(init(challengeItem, challengesPage, isNew))(*)(ChallengeNode*, GJChallengeItem*, ChallengesPage*, bool);
	static auto func = wrapFunction(base::get() + 0x3a1a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, challengeItem, challengesPage, isNew);
}

auto CharacterColorDelegate::playerColorChanged() -> decltype(playerColorChanged()) {
	throw std::runtime_error("CharacterColorDelegate::playerColorChanged not implemented");
}

auto CharacterColorDelegate::showUnlockPopup(int p0, UnlockType p1) -> decltype(showUnlockPopup(p0, p1)) {
	throw std::runtime_error("CharacterColorDelegate::showUnlockPopup not implemented");
}

auto CharacterColorPage::createColorMenu() -> decltype(createColorMenu()) {
	using FunctionType = decltype(createColorMenu())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x66ae50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CharacterColorPage::onMode(cocos2d::CCObject* sender) -> decltype(onMode(sender)) {
	using FunctionType = decltype(onMode(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x66ab00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::onPlayerColor(cocos2d::CCObject* sender) -> decltype(onPlayerColor(sender)) {
	using FunctionType = decltype(onPlayerColor(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x66b7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::toggleGlow(cocos2d::CCObject* p0) -> decltype(toggleGlow(p0)) {
	using FunctionType = decltype(toggleGlow(p0))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x66b220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::toggleShip(cocos2d::CCObject* p0) -> decltype(toggleShip(p0)) {
	using FunctionType = decltype(toggleShip(p0))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x66aa50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::init), this);
	using FunctionType = decltype(init())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x669d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x66bd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x66bcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::show), this);
	using FunctionType = decltype(show())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x66bb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointGameObject::init), this);
	using FunctionType = decltype(init())(*)(CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x1cee10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointGameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string>::func(&CheckpointGameObject::setupCustomSprites), this);
	using FunctionType = decltype(setupCustomSprites(p0))(*)(CheckpointGameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1cf260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CheckpointGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d0870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&CheckpointGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CheckpointGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1cee70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CheckpointGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&CheckpointGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(CheckpointGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1d0730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CheckpointGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&CheckpointGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(CheckpointGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1cfc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CheckpointGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CheckpointGameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(CheckpointGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1cee90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CheckpointGameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointGameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d08e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&CheckpointGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(CheckpointGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x1cf840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EnterEffectInstance::updateTransitions(float p0, GJBaseGameLayer* p1) -> decltype(updateTransitions(p0, p1)) {
	using FunctionType = decltype(updateTransitions(p0, p1))(*)(EnterEffectInstance*, float, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x5dc680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CheckpointObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointObject::init), this);
	using FunctionType = decltype(init())(*)(CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0xbfd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CollisionBlockPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CollisionBlockPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CollisionBlockPopup*);
	static auto func = wrapFunction(base::get() + 0x283350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CollisionBlockPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CollisionBlockPopup::show), this);
	using FunctionType = decltype(show())(*)(CollisionBlockPopup*);
	static auto func = wrapFunction(base::get() + 0x2832f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CollisionBlockPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CollisionBlockPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CollisionBlockPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x283130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CollisionBlockPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CollisionBlockPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CollisionBlockPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x283170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CollisionBlockPopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&CollisionBlockPopup::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(CollisionBlockPopup*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x283380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CollisionBlockPopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CollisionBlockPopup::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(CollisionBlockPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x283440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void ColorAction::loadFromState(CAState& state) {
		m_fromColor = state.m_fromColor;
		m_toColor = state.m_toColor;
		m_color = state.m_color;
		m_property19 = state.m_property19;
		m_blending = state.m_blending;
		m_copyOpacity = state.m_copyOpacity;
		m_unknown = state.m_unknown;
		m_playerColor = state.m_playerColor;
		m_colorID = state.m_colorID;
		m_copyID = state.m_copyID;
		m_unknown2 = state.m_unknown2;
		m_duration = state.m_duration;
		m_fromOpacity = state.m_fromOpacity;
		m_toOpacity = state.m_toOpacity;
		m_deltaTime = state.m_deltaTime;
		m_copyHSV = state.m_copyHSV;
	}

void ColorAction::saveToState(CAState& state) {
		state.m_fromColor = m_fromColor;
		state.m_toColor = m_toColor;
		state.m_color = m_color;
		state.m_property19 = m_property19;
		state.m_blending = m_blending;
		state.m_copyOpacity = m_copyOpacity;
		state.m_unknown = m_unknown;
		state.m_playerColor = m_playerColor;
		state.m_colorID = m_colorID;
		state.m_copyID = m_copyID;
		state.m_unknown2 = m_unknown2;
		state.m_duration = m_duration;
		state.m_fromOpacity = m_fromOpacity;
		state.m_toOpacity = m_toOpacity;
		state.m_deltaTime = m_deltaTime;
		state.m_copyHSV = m_copyHSV;
	}

auto ColorActionSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorActionSprite::init), this);
	using FunctionType = decltype(init())(*)(ColorActionSprite*);
	static auto func = wrapFunction(base::get() + 0x2d4c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorChannelSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2d44d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ColorChannelSprite::updateOpacity(float p0) -> decltype(updateOpacity(p0)) {
	using FunctionType = decltype(updateOpacity(p0))(*)(ColorChannelSprite*, float);
	static auto func = wrapFunction(base::get() + 0x2d4750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::updateValues(ColorAction* p0) -> decltype(updateValues(p0)) {
	using FunctionType = decltype(updateValues(p0))(*)(ColorChannelSprite*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x2d49b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorChannelSprite::init), this);
	using FunctionType = decltype(init())(*)(ColorChannelSprite*);
	static auto func = wrapFunction(base::get() + 0x2d4570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectDelegate::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	throw std::runtime_error("ColorSelectDelegate::colorSelectClosed not implemented");
}

auto ColorSelectLiveOverlay::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectLiveOverlay::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ColorSelectLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x571bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectLiveOverlay::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectLiveOverlay::show), this);
	using FunctionType = decltype(show())(*)(ColorSelectLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x571c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ConfigureValuePopupDelegate::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("ConfigureValuePopupDelegate::valuePopupClosed not implemented");
}

void SliderDelegate::sliderBegan(Slider* p0) {}

auto SliderDelegate::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	throw std::runtime_error("SliderDelegate::sliderEnded not implemented");
}

auto SetupTriggerPopup::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SetupTriggerPopup::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(SetupTriggerPopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x23b510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x234a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::show), this);
	using FunctionType = decltype(show())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x234850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void SetupTriggerPopup::pageChanged() {}

auto SetupTriggerPopup::toggleGroup(int p0, bool p1) -> decltype(toggleGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupTriggerPopup::toggleGroup), this);
	using FunctionType = decltype(toggleGroup(p0, p1))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x231150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x232430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2348b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupTriggerPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTriggerPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2327b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2327f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&SetupTriggerPopup::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(SetupTriggerPopup*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x234a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTriggerPopup::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(SetupTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x234b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SetupTriggerPopup::updateInputValue(int p0, float& p1) {}

auto SetupTriggerPopup::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&SetupTriggerPopup::sliderBegan), this);
	using FunctionType = decltype(sliderBegan(p0))(*)(SetupTriggerPopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x234bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&SetupTriggerPopup::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(SetupTriggerPopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x234ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SetupTriggerPopup::onPlusButton(cocos2d::CCObject* sender) {}

void SetupTriggerPopup::onCustomButton(cocos2d::CCObject* sender) {}

auto SetupTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x237210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x239290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::updateToggleItem(int p0, bool p1) -> decltype(updateToggleItem(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupTriggerPopup::updateToggleItem), this);
	using FunctionType = decltype(updateToggleItem(p0, p1))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2394e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void SetupTriggerPopup::valueDidChange(int p0, float p1) {}

auto SetupTriggerPopup::getValue(int p0) -> decltype(getValue(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&SetupTriggerPopup::getValue), this);
	using FunctionType = decltype(getValue(p0))(*)(SetupTriggerPopup*, int);
	static auto func = wrapFunction(base::get() + 0x2395a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x2399a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x239a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void SetupTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) {}

auto SetupTriggerPopup::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupTriggerPopup::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupTriggerPopup*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x23a630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSpecialColorSelectDelegate::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	throw std::runtime_error("GJSpecialColorSelectDelegate::colorSelectClosed not implemented");
}

auto ColorSelectPopup::updateDurLabel() -> decltype(updateDurLabel()) {
	using FunctionType = decltype(updateDurLabel())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x734fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ColorSelectPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectPopup::show), this);
	using FunctionType = decltype(show())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x738340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x7360c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ColorSelectPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ColorSelectPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x738430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ColorSelectPopup::colorValueChanged(cocos2d::ccColor3B p0) -> decltype(colorValueChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B>::func(&ColorSelectPopup::colorValueChanged), this);
	using FunctionType = decltype(colorValueChanged(p0))(*)(ColorSelectPopup*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x7368b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ColorSelectPopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&ColorSelectPopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(ColorSelectPopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x7389d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ColorSetupDelegate::colorSetupClosed(int p0) -> decltype(colorSetupClosed(p0)) {
	throw std::runtime_error("ColorSetupDelegate::colorSetupClosed not implemented");
}

void LikeItemDelegate::likedItem(LikeItemType p0, int p1, bool p2) {}

auto CommentCell::loadFromComment(GJComment* p0) -> decltype(loadFromComment(p0)) {
	using FunctionType = decltype(loadFromComment(p0))(*)(CommentCell*, GJComment*);
	static auto func = wrapFunction(base::get() + 0x242fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CommentCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommentCell::init), this);
	using FunctionType = decltype(init())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0x250990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommentCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommentCell::draw), this);
	using FunctionType = decltype(draw())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0x250cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommentCell::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&CommentCell::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(CommentCell*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x250d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CommentCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CommentCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CommentCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x251120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CommentUploadDelegate::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	throw std::runtime_error("CommentUploadDelegate::commentUploadFinished not implemented");
}

auto CommentUploadDelegate::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	throw std::runtime_error("CommentUploadDelegate::commentUploadFailed not implemented");
}

void CommentUploadDelegate::commentDeleteFailed(int p0, int p1) {}

auto CommunityCreditsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::init), this);
	using FunctionType = decltype(init())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x31d3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommunityCreditsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x31f930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommunityCreditsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x31f8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommunityCreditsPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::show), this);
	using FunctionType = decltype(show())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x31f730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void ConfigureHSVWidget::textInputOpened(CCTextInputNode* p0) {}

auto ConfigureHSVWidget::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureHSVWidget::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(ConfigureHSVWidget*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x43afe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureHSVWidget::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureHSVWidget::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ConfigureHSVWidget*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x43b020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureValuePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ConfigureValuePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ConfigureValuePopup*);
	static auto func = wrapFunction(base::get() + 0x630b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ConfigureValuePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureValuePopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(ConfigureValuePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x6309e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureValuePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureValuePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ConfigureValuePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x630a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CountTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&CountTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CountTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1d0a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CountTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&CountTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(CountTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1d0cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CountTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&CountTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(CountTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1d10f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateGuidelinesLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CreateGuidelinesLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(CreateGuidelinesLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5151d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateGuidelinesLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x515440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void CreateGuidelinesLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto CreateGuidelinesLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x515550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x5155f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x515630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x5153a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&CreateGuidelinesLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(CreateGuidelinesLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x515670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateGuidelinesLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CreateGuidelinesLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CreateGuidelinesLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5152a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CreateGuidelinesLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x515370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

void CreateGuidelinesLayer::keyUp(cocos2d::enumKeyCodes p0) {}

auto CreateGuidelinesLayer::playMusic() -> decltype(playMusic()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::playMusic), this);
	using FunctionType = decltype(playMusic())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x514600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::registerTouch() -> decltype(registerTouch()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::registerTouch), this);
	using FunctionType = decltype(registerTouch())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x5153f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CreateGuidelinesLayer::onInfo), this);
	using FunctionType = decltype(onInfo(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5151f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto CreateGuidelinesLayer::onRecord(cocos2d::CCObject* sender) -> decltype(onRecord(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CreateGuidelinesLayer::onRecord), this);
	using FunctionType = decltype(onRecord(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5144f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto CreateGuidelinesLayer::recordingDidStop() -> decltype(recordingDidStop()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::recordingDidStop), this);
	using FunctionType = decltype(recordingDidStop())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x514690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateParticlePopup::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CreateParticlePopup::update), this);
	using FunctionType = decltype(update(p0))(*)(CreateParticlePopup*, float);
	static auto func = wrapFunction(base::get() + 0x480650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4811d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4812e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4816b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x481700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateParticlePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreateParticlePopup*);
	static auto func = wrapFunction(base::get() + 0x481030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateParticlePopup::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&CreateParticlePopup::sliderBegan), this);
	using FunctionType = decltype(sliderBegan(p0))(*)(CreateParticlePopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x480ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&CreateParticlePopup::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(CreateParticlePopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x480fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&CreateParticlePopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(CreateParticlePopup*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x4803c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&CreateParticlePopup::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(CreateParticlePopup*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x481060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CreateParticlePopup::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(CreateParticlePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x481120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CreateParticlePopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CreateParticlePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4807c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CreateParticlePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CreateParticlePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x480800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void DialogDelegate::dialogClosed(DialogLayer* p0) {}

auto CreatorLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::init), this);
	using FunctionType = decltype(init())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x2934c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x295bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::sceneWillResume() -> decltype(sceneWillResume()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::sceneWillResume), this);
	using FunctionType = decltype(sceneWillResume())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x295b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&CreatorLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(CreatorLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x295a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CurrencyRewardLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CurrencyRewardLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(CurrencyRewardLayer*, float);
	static auto func = wrapFunction(base::get() + 0x7b4aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void HSVWidgetDelegate::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) {}

void HSVWidgetDelegate::hsvChanged(ConfigureHSVWidget* p0) {}

auto CustomizeObjectLayer::init(GameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(CustomizeObjectLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1eef50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CustomizeObjectLayer::onSelectMode(cocos2d::CCObject* sender) -> decltype(onSelectMode(sender)) {
	using FunctionType = decltype(onSelectMode(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f13b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::toggleVisible() -> decltype(toggleVisible()) {
	using FunctionType = decltype(toggleVisible())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x1f3120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomizeObjectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x1f3620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomizeObjectLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f3280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f3390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f33d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::ccHSVValue>::func(&CustomizeObjectLayer::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(CustomizeObjectLayer*, HSVWidgetPopup*, cocos2d::ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x1f3030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomizeObjectLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&CustomizeObjectLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(CustomizeObjectLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x1f2dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::colorSetupClosed(int p0) -> decltype(colorSetupClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomizeObjectLayer::colorSetupClosed), this);
	using FunctionType = decltype(colorSetupClosed(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1f2960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectSettingsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CustomizeObjectSettingsPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(CustomizeObjectSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f3c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto CustomizeObjectSettingsPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CustomizeObjectSettingsPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(CustomizeObjectSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f3b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

CustomListView::~CustomListView() {}

auto CustomListView::create(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0x23bc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

CustomListView* CustomListView::create(cocos2d::CCArray* entries, BoomListType type, float width, float height) {
		return CustomListView::create(entries, nullptr, width, height, 0, type, 0.0f);
	}

auto CustomListView::setupList(float p0) -> decltype(setupList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CustomListView::setupList), this);
	using FunctionType = decltype(setupList(p0))(*)(CustomListView*, float);
	static auto func = wrapFunction(base::get() + 0x2491d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomListView::getListCell(char const* p0) -> decltype(getListCell(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CustomListView::getListCell), this);
	using FunctionType = decltype(getListCell(p0))(*)(CustomListView*, char const*);
	static auto func = wrapFunction(base::get() + 0x23bdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomListView::loadCell(TableViewCell* p0, int p1) -> decltype(loadCell(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int>::func(&CustomListView::loadCell), this);
	using FunctionType = decltype(loadCell(p0, p1))(*)(CustomListView*, TableViewCell*, int);
	static auto func = wrapFunction(base::get() + 0x23d950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongDelegate::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	throw std::runtime_error("CustomSongDelegate::songIDChanged not implemented");
}

auto CustomSongDelegate::getActiveSongID() -> decltype(getActiveSongID()) {
	throw std::runtime_error("CustomSongDelegate::getActiveSongID not implemented");
}

auto CustomSongDelegate::getSongFileName() -> decltype(getSongFileName()) {
	throw std::runtime_error("CustomSongDelegate::getSongFileName not implemented");
}

auto CustomSongDelegate::getLevelSettings() -> decltype(getLevelSettings()) {
	throw std::runtime_error("CustomSongDelegate::getLevelSettings not implemented");
}

auto CustomSongCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::init), this);
	using FunctionType = decltype(init())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x24f910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::draw), this);
	using FunctionType = decltype(draw())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x24fb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongCell::songIDChanged), this);
	using FunctionType = decltype(songIDChanged(p0))(*)(CustomSongCell*, int);
	static auto func = wrapFunction(base::get() + 0x24fa00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongCell::getActiveSongID() -> decltype(getActiveSongID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::getActiveSongID), this);
	using FunctionType = decltype(getActiveSongID())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x24fa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::getSongFileName() -> decltype(getSongFileName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::getSongFileName), this);
	using FunctionType = decltype(getSongFileName())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x24fae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::getLevelSettings() -> decltype(getLevelSettings()) {
	throw std::runtime_error("CustomSongCell::getLevelSettings not implemented");
}

auto CustomSFXDelegate::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	throw std::runtime_error("CustomSFXDelegate::sfxObjectSelected not implemented");
}

auto CustomSFXDelegate::getActiveSFXID() -> decltype(getActiveSFXID()) {
	throw std::runtime_error("CustomSFXDelegate::getActiveSFXID not implemented");
}

auto CustomSFXDelegate::overridePlaySFX(SFXInfoObject* p0) -> decltype(overridePlaySFX(p0)) {
	throw std::runtime_error("CustomSFXDelegate::overridePlaySFX not implemented");
}

auto CustomSFXCell::loadFromObject(SFXInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomSFXCell*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x23fca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::init), this);
	using FunctionType = decltype(init())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0x24fd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::draw), this);
	using FunctionType = decltype(draw())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0x24fe10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXCell::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXInfoObject*>::func(&CustomSFXCell::sfxObjectSelected), this);
	using FunctionType = decltype(sfxObjectSelected(p0))(*)(CustomSFXCell*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x24fd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSFXCell::getActiveSFXID() -> decltype(getActiveSFXID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::getActiveSFXID), this);
	using FunctionType = decltype(getActiveSFXID())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0x24fdb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void MusicDownloadDelegate::loadSongInfoFinished(SongInfoObject* p0) {}

void MusicDownloadDelegate::loadSongInfoFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::downloadSongFinished(int p0) {}

void MusicDownloadDelegate::downloadSongFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::songStateChanged() {}

void MusicDownloadDelegate::downloadSFXFinished(int p0) {}

void MusicDownloadDelegate::downloadSFXFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::musicActionFinished(GJMusicAction p0) {}

void MusicDownloadDelegate::musicActionFailed(GJMusicAction p0) {}

auto CustomSFXWidget::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSFXWidget::downloadSFXFinished), this);
	using FunctionType = decltype(downloadSFXFinished(p0))(*)(CustomSFXWidget*, int);
	static auto func = wrapFunction(base::get() + 0x5ee330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSFXWidget::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSFXWidget::downloadSFXFailed), this);
	using FunctionType = decltype(downloadSFXFailed(p0, p1))(*)(CustomSFXWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x5ee3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSFXWidget::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXWidget::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x5ee2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXWidget::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CustomSFXWidget::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CustomSFXWidget*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5ee5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void GJDropDownLayerDelegate::dropDownLayerWillClose(GJDropDownLayer* p0) {}

void MusicBrowserDelegate::musicBrowserClosed(MusicBrowser* p0) {}

auto CustomSongLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CustomSongLayer*);
	static auto func = wrapFunction(base::get() + 0x210f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongLayer::show), this);
	using FunctionType = decltype(show())(*)(CustomSongLayer*);
	static auto func = wrapFunction(base::get() + 0x211020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomSongLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CustomSongLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2109d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomSongLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(CustomSongLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x210970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomSongLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CustomSongLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x210910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&CustomSongLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(CustomSongLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x2109f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomSongLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(CustomSongLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x210ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJDropDownLayer*>::func(&CustomSongLayer::dropDownLayerWillClose), this);
	using FunctionType = decltype(dropDownLayerWillClose(p0))(*)(CustomSongLayer*, GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x210de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::musicBrowserClosed(MusicBrowser* p0) -> decltype(musicBrowserClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<MusicBrowser*>::func(&CustomSongLayer::musicBrowserClosed), this);
	using FunctionType = decltype(musicBrowserClosed(p0))(*)(CustomSongLayer*, MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x210e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void CustomSongLayerDelegate::customSongLayerClosed() {}

auto CustomSongWidget::init(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary, int unk) -> decltype(init(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk)) {
	using FunctionType = decltype(init(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk))(*)(CustomSongWidget*, SongInfoObject*, CustomSongDelegate*, bool, bool, bool, bool, bool, bool, int);
	static auto func = wrapFunction(base::get() + 0x625c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk);
}

auto CustomSongWidget::loadSongInfoFinished(SongInfoObject* p0) -> decltype(loadSongInfoFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SongInfoObject*>::func(&CustomSongWidget::loadSongInfoFinished), this);
	using FunctionType = decltype(loadSongInfoFinished(p0))(*)(CustomSongWidget*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x62bd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::loadSongInfoFailed(int p0, GJSongError p1) -> decltype(loadSongInfoFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::loadSongInfoFailed), this);
	using FunctionType = decltype(loadSongInfoFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x62bf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::downloadSongFinished(int p0) -> decltype(downloadSongFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongWidget::downloadSongFinished), this);
	using FunctionType = decltype(downloadSongFinished(p0))(*)(CustomSongWidget*, int);
	static auto func = wrapFunction(base::get() + 0x62c190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::downloadSongFailed(int p0, GJSongError p1) -> decltype(downloadSongFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::downloadSongFailed), this);
	using FunctionType = decltype(downloadSongFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x62c470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongWidget::downloadSFXFinished), this);
	using FunctionType = decltype(downloadSFXFinished(p0))(*)(CustomSongWidget*, int);
	static auto func = wrapFunction(base::get() + 0x62c600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::downloadSFXFailed), this);
	using FunctionType = decltype(downloadSFXFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x62c630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&CustomSongWidget::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(CustomSongWidget*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x62c930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&CustomSongWidget::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(CustomSongWidget*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x62c990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongWidget::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x62ad60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongWidget::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CustomSongWidget::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CustomSongWidget*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x62ca30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DailyLevelNode::init(GJGameLevel* p0, DailyLevelPage* p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(DailyLevelNode*, GJGameLevel*, DailyLevelPage*, bool);
	static auto func = wrapFunction(base::get() + 0x22e0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DailyLevelNode::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&DailyLevelNode::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(DailyLevelNode*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x22edd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJDailyLevelDelegate::dailyStatusFinished(GJTimedLevelType p0) -> decltype(dailyStatusFinished(p0)) {
	throw std::runtime_error("GJDailyLevelDelegate::dailyStatusFinished not implemented");
}

auto GJDailyLevelDelegate::dailyStatusFailed(GJTimedLevelType p0, GJErrorCode p1) -> decltype(dailyStatusFailed(p0, p1)) {
	throw std::runtime_error("GJDailyLevelDelegate::dailyStatusFailed not implemented");
}

void LevelDownloadDelegate::levelDownloadFinished(GJGameLevel* p0) {}

void LevelDownloadDelegate::levelDownloadFailed(int p0) {}

auto DailyLevelPage::init(GJTimedLevelType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(DailyLevelPage*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x22bbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DailyLevelPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x22dc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DailyLevelPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DailyLevelPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x22dbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DailyLevelPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DailyLevelPage::show), this);
	using FunctionType = decltype(show())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x22da30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void DailyLevelPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto DailyLevelPage::dailyStatusFinished(GJTimedLevelType p0) -> decltype(dailyStatusFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJTimedLevelType>::func(&DailyLevelPage::dailyStatusFinished), this);
	using FunctionType = decltype(dailyStatusFinished(p0))(*)(DailyLevelPage*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x22d0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DailyLevelPage::dailyStatusFailed(GJTimedLevelType p0, GJErrorCode p1) -> decltype(dailyStatusFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJTimedLevelType, GJErrorCode>::func(&DailyLevelPage::dailyStatusFailed), this);
	using FunctionType = decltype(dailyStatusFailed(p0, p1))(*)(DailyLevelPage*, GJTimedLevelType, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x22d510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DailyLevelPage::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&DailyLevelPage::levelDownloadFinished), this);
	using FunctionType = decltype(levelDownloadFinished(p0))(*)(DailyLevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x22d760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DailyLevelPage::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&DailyLevelPage::levelDownloadFailed), this);
	using FunctionType = decltype(levelDownloadFailed(p0))(*)(DailyLevelPage*, int);
	static auto func = wrapFunction(base::get() + 0x22d820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&RingObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(RingObject*, float);
	static auto func = wrapFunction(base::get() + 0x1af530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&RingObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(RingObject*, float);
	static auto func = wrapFunction(base::get() + 0x1af590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RingObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(RingObject*);
	static auto func = wrapFunction(base::get() + 0x1af510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RingObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&RingObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(RingObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1af5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RingObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&RingObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(RingObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1af710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::setRScale(float p0) -> decltype(setRScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&RingObject::setRScale), this);
	using FunctionType = decltype(setRScale(p0))(*)(RingObject*, float);
	static auto func = wrapFunction(base::get() + 0x1af560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&RingObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(RingObject*, float);
	static auto func = wrapFunction(base::get() + 0x1af3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::shouldDrawEditorHitbox() -> decltype(shouldDrawEditorHitbox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RingObject::shouldDrawEditorHitbox), this);
	using FunctionType = decltype(shouldDrawEditorHitbox())(*)(RingObject*);
	static auto func = wrapFunction(base::get() + 0x1af5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RingObject::powerOnObject(int p0) -> decltype(powerOnObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&RingObject::powerOnObject), this);
	using FunctionType = decltype(powerOnObject(p0))(*)(RingObject*, int);
	static auto func = wrapFunction(base::get() + 0x1af3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DashRingObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&DashRingObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(DashRingObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1b0340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DashRingObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&DashRingObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(DashRingObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b04b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DemonFilterDelegate::demonFilterSelectClosed(int p0) -> decltype(demonFilterSelectClosed(p0)) {
	throw std::runtime_error("DemonFilterDelegate::demonFilterSelectClosed not implemented");
}

auto DemonFilterSelectLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DemonFilterSelectLayer::init), this);
	using FunctionType = decltype(init())(*)(DemonFilterSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x63c460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DemonFilterSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DemonFilterSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DemonFilterSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x63ca50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DemonInfoPopup::create(int easyClassic, int mediumClassic, int hardClassic, int insaneClassic, int extremeClassic, int easyPlatformer, int mediumPlatformer, int hardPlatformer, int insanePlatformer, int extremePlatformer, int weekly, int gauntlet) -> decltype(create(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet)) {
	using FunctionType = decltype(create(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet))(*)(int, int, int, int, int, int, int, int, int, int, int, int);
	static auto func = wrapFunction(base::get() + 0x7cde90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet);
}

auto DemonInfoPopup::createFromString(gd::string p0) -> decltype(createFromString(p0)) {
	using FunctionType = decltype(createFromString(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x7cbb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto DemonInfoPopup::init(int easyClassic, int mediumClassic, int hardClassic, int insaneClassic, int extremeClassic, int easyPlatformer, int mediumPlatformer, int hardPlatformer, int insanePlatformer, int extremePlatformer, int weekly, int gauntlet) -> decltype(init(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet)) {
	using FunctionType = decltype(init(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet))(*)(DemonInfoPopup*, int, int, int, int, int, int, int, int, int, int, int, int);
	static auto func = wrapFunction(base::get() + 0x7ce020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet);
}

auto DemonInfoPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&DemonInfoPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(DemonInfoPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7ce980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto DemonInfoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DemonInfoPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DemonInfoPopup*);
	static auto func = wrapFunction(base::get() + 0x7ce9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TextAreaDelegate::fadeInTextFinished(TextArea* p0) -> decltype(fadeInTextFinished(p0)) {
	throw std::runtime_error("TextAreaDelegate::fadeInTextFinished not implemented");
}

auto DialogLayer::create(DialogObject* p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(DialogObject*, int);
	static auto func = wrapFunction(base::get() + 0x3cac60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto DialogLayer::createDialogLayer(DialogObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(createDialogLayer(p0, p1, p2)) {
	using FunctionType = decltype(createDialogLayer(p0, p1, p2))(*)(DialogObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x3cac70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto DialogLayer::createWithObjects(cocos2d::CCArray* p0, int p1) -> decltype(createWithObjects(p0, p1)) {
	using FunctionType = decltype(createWithObjects(p0, p1))(*)(cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x3cadb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto DialogLayer::init(DialogObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(DialogLayer*, DialogObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x3cadd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DialogLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DialogLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3cbe80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DialogLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3cbd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void DialogLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto DialogLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3cbd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3cbdf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DialogLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3cbe40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DialogLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DialogLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3cbc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DialogLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&DialogLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(DialogLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3cc220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DialogLayer::fadeInTextFinished(TextArea* p0) -> decltype(fadeInTextFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<TextArea*>::func(&DialogLayer::fadeInTextFinished), this);
	using FunctionType = decltype(fadeInTextFinished(p0))(*)(DialogLayer*, TextArea*);
	static auto func = wrapFunction(base::get() + 0x3cbe90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DownloadMessageDelegate::downloadMessageFinished(GJUserMessage* p0) -> decltype(downloadMessageFinished(p0)) {
	throw std::runtime_error("DownloadMessageDelegate::downloadMessageFinished not implemented");
}

auto DownloadMessageDelegate::downloadMessageFailed(int p0) -> decltype(downloadMessageFailed(p0)) {
	throw std::runtime_error("DownloadMessageDelegate::downloadMessageFailed not implemented");
}

auto DrawGridLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&DrawGridLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(DrawGridLayer*, float);
	static auto func = wrapFunction(base::get() + 0xf9a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DrawGridLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DrawGridLayer::draw), this);
	using FunctionType = decltype(draw())(*)(DrawGridLayer*);
	static auto func = wrapFunction(base::get() + 0xf9b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DungeonBarsSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DungeonBarsSprite::init), this);
	using FunctionType = decltype(init())(*)(DungeonBarsSprite*);
	static auto func = wrapFunction(base::get() + 0x4b2440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DungeonBarsSprite::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DungeonBarsSprite::visit), this);
	using FunctionType = decltype(visit())(*)(DungeonBarsSprite*);
	static auto func = wrapFunction(base::get() + 0x4b24c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void DynamicScrollDelegate::updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) {}

void UploadActionDelegate::uploadActionFinished(int p0, int p1) {}

void UploadActionDelegate::uploadActionFailed(int p0, int p1) {}

void UploadPopupDelegate::onClosePopup(UploadActionPopup* p0) {}

void SetIDPopupDelegate::setIDPopupClosed(SetIDPopup* p0, int p1) {}

EditLevelLayer::~EditLevelLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x1f42c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) EditLevelLayer(geode::CutoffConstructor, sizeof(EditLevelLayer));
	CCDestructor::lock(this) = true;
}

auto EditLevelLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditLevelLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1f4710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x1f8d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x1f8d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&EditLevelLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(EditLevelLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x1f8c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditLevelLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditLevelLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1f8800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f7e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f79e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f7f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&EditLevelLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(EditLevelLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x1f8e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&EditLevelLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(EditLevelLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x1f8fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&EditLevelLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(EditLevelLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x1f8dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void GJOptionsLayer::setupOptions() {}

auto GJOptionsLayer::didToggleGV(gd::string p0) -> decltype(didToggleGV(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string>::func(&GJOptionsLayer::didToggleGV), this);
	using FunctionType = decltype(didToggleGV(p0))(*)(GJOptionsLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x26e1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void GJOptionsLayer::didToggle(int p0) {}

auto EditorOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(EditorOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x299e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&EditorOptionsLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(EditorOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29a840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto EditorOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(EditorOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x299e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

EditorPauseLayer::EditorPauseLayer() {
		m_saved = false;
		m_guidelinesOffButton = nullptr;
		m_guidelinesOnButton = nullptr;
		m_editorLayer = nullptr;
	}

auto EditorPauseLayer::init(LevelEditorLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditorPauseLayer*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x28cf10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::onSaveAndPlay(cocos2d::CCObject* sender) -> decltype(onSaveAndPlay(sender)) {
	using FunctionType = decltype(onSaveAndPlay(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28f650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorPauseLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x290db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorPauseLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorPauseLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditorPauseLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x290ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorPauseLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorPauseLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x28d840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorPauseLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditorPauseLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditorPauseLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x290cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControlDelegate::angleChanged(float p0) -> decltype(angleChanged(p0)) {
	throw std::runtime_error("GJRotationControlDelegate::angleChanged not implemented");
}

auto GJRotationControlDelegate::angleChangeBegin() -> decltype(angleChangeBegin()) {
	throw std::runtime_error("GJRotationControlDelegate::angleChangeBegin not implemented");
}

auto GJRotationControlDelegate::angleChangeEnded() -> decltype(angleChangeEnded()) {
	throw std::runtime_error("GJRotationControlDelegate::angleChangeEnded not implemented");
}

auto GJScaleControlDelegate::scaleXChanged(float p0, bool p1) -> decltype(scaleXChanged(p0, p1)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleXChanged not implemented");
}

auto GJScaleControlDelegate::scaleYChanged(float p0, bool p1) -> decltype(scaleYChanged(p0, p1)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleYChanged not implemented");
}

auto GJScaleControlDelegate::scaleXYChanged(float p0, float p1, bool p2) -> decltype(scaleXYChanged(p0, p1, p2)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleXYChanged not implemented");
}

auto GJScaleControlDelegate::scaleChangeBegin() -> decltype(scaleChangeBegin()) {
	throw std::runtime_error("GJScaleControlDelegate::scaleChangeBegin not implemented");
}

auto GJScaleControlDelegate::scaleChangeEnded() -> decltype(scaleChangeEnded()) {
	throw std::runtime_error("GJScaleControlDelegate::scaleChangeEnded not implemented");
}

auto GJScaleControlDelegate::updateScaleControl() -> decltype(updateScaleControl()) {
	throw std::runtime_error("GJScaleControlDelegate::updateScaleControl not implemented");
}

auto GJScaleControlDelegate::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	throw std::runtime_error("GJScaleControlDelegate::anchorPointMoved not implemented");
}

auto GJTransformControlDelegate::transformScaleXChanged(float p0) -> decltype(transformScaleXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleXChanged not implemented");
}

auto GJTransformControlDelegate::transformScaleYChanged(float p0) -> decltype(transformScaleYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleYChanged not implemented");
}

auto GJTransformControlDelegate::transformScaleXYChanged(float p0, float p1) -> decltype(transformScaleXYChanged(p0, p1)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleXYChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationXChanged(float p0) -> decltype(transformRotationXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationXChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationYChanged(float p0) -> decltype(transformRotationYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationYChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationChanged(float p0) -> decltype(transformRotationChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationChanged not implemented");
}

auto GJTransformControlDelegate::transformResetRotation() -> decltype(transformResetRotation()) {
	throw std::runtime_error("GJTransformControlDelegate::transformResetRotation not implemented");
}

auto GJTransformControlDelegate::transformRestoreRotation() -> decltype(transformRestoreRotation()) {
	throw std::runtime_error("GJTransformControlDelegate::transformRestoreRotation not implemented");
}

auto GJTransformControlDelegate::transformSkewXChanged(float p0) -> decltype(transformSkewXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformSkewXChanged not implemented");
}

auto GJTransformControlDelegate::transformSkewYChanged(float p0) -> decltype(transformSkewYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformSkewYChanged not implemented");
}

auto GJTransformControlDelegate::transformChangeBegin() -> decltype(transformChangeBegin()) {
	throw std::runtime_error("GJTransformControlDelegate::transformChangeBegin not implemented");
}

auto GJTransformControlDelegate::transformChangeEnded() -> decltype(transformChangeEnded()) {
	throw std::runtime_error("GJTransformControlDelegate::transformChangeEnded not implemented");
}

auto GJTransformControlDelegate::updateTransformControl() -> decltype(updateTransformControl()) {
	throw std::runtime_error("GJTransformControlDelegate::updateTransformControl not implemented");
}

auto GJTransformControlDelegate::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::anchorPointMoved not implemented");
}

auto GJTransformControlDelegate::getTransformNode() -> decltype(getTransformNode()) {
	throw std::runtime_error("GJTransformControlDelegate::getTransformNode not implemented");
}

auto GJTransformControlDelegate::getUI() -> decltype(getUI()) {
	throw std::runtime_error("GJTransformControlDelegate::getUI not implemented");
}

auto EditorUI::create(LevelEditorLayer* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x9460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

EditorUI* EditorUI::get() {
        auto lel = LevelEditorLayer::get();
        if (!lel) return nullptr;
        return lel->m_editorUI;
	}

auto EditorUI::editGroup(cocos2d::CCObject* p0) -> decltype(editGroup(p0)) {
	using FunctionType = decltype(editGroup(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::init(LevelEditorLayer* editorLayer) -> decltype(init(editorLayer)) {
	using FunctionType = decltype(init(editorLayer))(*)(EditorUI*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x94c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, editorLayer);
}

auto EditorUI::onPlaytest(cocos2d::CCObject* sender) -> decltype(onPlaytest(sender)) {
	using FunctionType = decltype(onPlaytest(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xca00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::toggleLockUI(bool p0) -> decltype(toggleLockUI(p0)) {
	using FunctionType = decltype(toggleLockUI(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x2d5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateObjectInfoLabel() -> decltype(updateObjectInfoLabel()) {
	using FunctionType = decltype(updateObjectInfoLabel())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x2f660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::draw), this);
	using FunctionType = decltype(draw())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x4eba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4f660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4fc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x50240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x50b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x50bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x3f200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorUI::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditorUI*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x50bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::getUI() -> decltype(getUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::getUI), this);
	using FunctionType = decltype(getUI())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x54b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&EditorUI::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(EditorUI*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x335e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditorUI::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditorUI*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x33450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::updateTransformControl() -> decltype(updateTransformControl()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::updateTransformControl), this);
	using FunctionType = decltype(updateTransformControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x40c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformChangeBegin() -> decltype(transformChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformChangeBegin), this);
	using FunctionType = decltype(transformChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x41600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void EditorUI::transformChangeEnded() {}

auto EditorUI::getTransformNode() -> decltype(getTransformNode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::getTransformNode), this);
	using FunctionType = decltype(getTransformNode())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x54b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformScaleXChanged(float p0) -> decltype(transformScaleXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformScaleXChanged), this);
	using FunctionType = decltype(transformScaleXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4d3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformScaleYChanged(float p0) -> decltype(transformScaleYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformScaleYChanged), this);
	using FunctionType = decltype(transformScaleYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4d5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformScaleXYChanged(float p0, float p1) -> decltype(transformScaleXYChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::transformScaleXYChanged), this);
	using FunctionType = decltype(transformScaleXYChanged(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x4d740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::transformSkewXChanged(float p0) -> decltype(transformSkewXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformSkewXChanged), this);
	using FunctionType = decltype(transformSkewXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4d8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformSkewYChanged(float p0) -> decltype(transformSkewYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformSkewYChanged), this);
	using FunctionType = decltype(transformSkewYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4da10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationXChanged(float p0) -> decltype(transformRotationXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationXChanged), this);
	using FunctionType = decltype(transformRotationXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4db70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationYChanged(float p0) -> decltype(transformRotationYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationYChanged), this);
	using FunctionType = decltype(transformRotationYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4dcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationChanged(float p0) -> decltype(transformRotationChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationChanged), this);
	using FunctionType = decltype(transformRotationChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4de30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformResetRotation() -> decltype(transformResetRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformResetRotation), this);
	using FunctionType = decltype(transformResetRotation())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x4dfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformRestoreRotation() -> decltype(transformRestoreRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformRestoreRotation), this);
	using FunctionType = decltype(transformRestoreRotation())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x4e090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x3dec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&EditorUI::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(EditorUI*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x4a930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorUI::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(EditorUI*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x51cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x51d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::angleChangeBegin() -> decltype(angleChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::angleChangeBegin), this);
	using FunctionType = decltype(angleChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x4ec80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void EditorUI::angleChangeEnded() {}

auto EditorUI::angleChanged(float p0) -> decltype(angleChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::angleChanged), this);
	using FunctionType = decltype(angleChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4ece0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::updateScaleControl() -> decltype(updateScaleControl()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::updateScaleControl), this);
	using FunctionType = decltype(updateScaleControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x3f640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&EditorUI::anchorPointMoved), this);
	using FunctionType = decltype(anchorPointMoved(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x41700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scaleChangeBegin() -> decltype(scaleChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::scaleChangeBegin), this);
	using FunctionType = decltype(scaleChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x3fd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void EditorUI::scaleChangeEnded() {}

auto EditorUI::scaleXChanged(float p0, bool p1) -> decltype(scaleXChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, bool>::func(&EditorUI::scaleXChanged), this);
	using FunctionType = decltype(scaleXChanged(p0, p1))(*)(EditorUI*, float, bool);
	static auto func = wrapFunction(base::get() + 0x3fdd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::scaleYChanged(float p0, bool p1) -> decltype(scaleYChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, bool>::func(&EditorUI::scaleYChanged), this);
	using FunctionType = decltype(scaleYChanged(p0, p1))(*)(EditorUI*, float, bool);
	static auto func = wrapFunction(base::get() + 0x40540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::scaleXYChanged(float p0, float p1, bool p2) -> decltype(scaleXYChanged(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<float, float, bool>::func(&EditorUI::scaleXYChanged), this);
	using FunctionType = decltype(scaleXYChanged(p0, p1, p2))(*)(EditorUI*, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x40690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto EditTriggersPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditTriggersPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(EditTriggersPopup*);
	static auto func = wrapFunction(base::get() + 0x296f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditTriggersPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&EditTriggersPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(EditTriggersPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x296f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto EndLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x4ccf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EndLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EndLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4cd6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndLevelLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndLevelLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x4c9d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndLevelLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EndLevelLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(EndLevelLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4cc0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void EndLevelLayer::enterAnimFinished() {}

void EndLevelLayer::keyUp(cocos2d::enumKeyCodes p0) {}

auto EndPortalObject::getSpawnPos() -> decltype(getSpawnPos()) {
	using FunctionType = decltype(getSpawnPos())(*)(EndPortalObject*);
	static auto func = wrapFunction(base::get() + 0x39f810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndPortalObject::triggerObject(GJBaseGameLayer* p0) -> decltype(triggerObject(p0)) {
	using FunctionType = decltype(triggerObject(p0))(*)(EndPortalObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x39f780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndPortalObject::updateEndPos(bool p0) -> decltype(updateEndPos(p0)) {
	using FunctionType = decltype(updateEndPos(p0))(*)(EndPortalObject*, bool);
	static auto func = wrapFunction(base::get() + 0x39fa00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndPortalObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndPortalObject::init), this);
	using FunctionType = decltype(init())(*)(EndPortalObject*);
	static auto func = wrapFunction(base::get() + 0x39f390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndPortalObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&EndPortalObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(EndPortalObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x39f890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndPortalObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EndPortalObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(EndPortalObject*, bool);
	static auto func = wrapFunction(base::get() + 0x39f9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(EndTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d5880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&EndTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EndTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1d58d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto EndTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EndTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EndTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1d6690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EndTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EndTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EndTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1d59b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EnhancedTriggerObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EnhancedTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1b8570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EnhancedTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnhancedTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EnhancedTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b7a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnterEffectObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnterEffectObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EnterEffectObject*);
	static auto func = wrapFunction(base::get() + 0x192500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnterEffectObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EnterEffectObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EnterEffectObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x192840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EnterEffectObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnterEffectObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EnterEffectObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x180850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EventLinkTrigger::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EventLinkTrigger::init), this);
	using FunctionType = decltype(init())(*)(EventLinkTrigger*);
	static auto func = wrapFunction(base::get() + 0x1cb4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EventLinkTrigger::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&EventLinkTrigger::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EventLinkTrigger*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1cb4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto EventLinkTrigger::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EventLinkTrigger::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EventLinkTrigger*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1cc3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EventLinkTrigger::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EventLinkTrigger::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EventLinkTrigger*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1cb5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ExplodeItemNode::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ExplodeItemNode::update), this);
	using FunctionType = decltype(update(p0))(*)(ExplodeItemNode*, float);
	static auto func = wrapFunction(base::get() + 0x20f170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ExplodeItemSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ExplodeItemSprite::init), this);
	using FunctionType = decltype(init())(*)(ExplodeItemSprite*);
	static auto func = wrapFunction(base::get() + 0x20f4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ExtendedLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ExtendedLayer::init), this);
	using FunctionType = decltype(init())(*)(ExtendedLayer*);
	static auto func = wrapFunction(base::get() + 0x3aa760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ExtendedLayer::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&ExtendedLayer::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(ExtendedLayer*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3aa770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GManager::save() -> decltype(save()) {
	using FunctionType = decltype(save())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x4b61b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GManager::saveGMTo(gd::string p0) -> decltype(saveGMTo(p0)) {
	using FunctionType = decltype(saveGMTo(p0))(*)(GManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4b62b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::init), this);
	using FunctionType = decltype(init())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x4b5f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GManager::setup() -> decltype(setup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::setup), this);
	using FunctionType = decltype(setup())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x4b5f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(GManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x4b64d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(GManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x4b6b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x4b6b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FileSaveManager::init() -> decltype(init()) {
	throw std::runtime_error("FileSaveManager::init not implemented");
}

auto FileSaveManager::firstLoad() -> decltype(firstLoad()) {
	throw std::runtime_error("FileSaveManager::firstLoad not implemented");
}

auto FindBPMLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&FindBPMLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(FindBPMLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x515c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto FindBPMLayer::playMusic() -> decltype(playMusic()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::playMusic), this);
	using FunctionType = decltype(playMusic())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x515ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FindBPMLayer::registerTouch() -> decltype(registerTouch()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::registerTouch), this);
	using FunctionType = decltype(registerTouch())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x515b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void FindBPMLayer::onInfo(cocos2d::CCObject* sender) {}

auto FindBPMLayer::onRecord(cocos2d::CCObject* sender) -> decltype(onRecord(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&FindBPMLayer::onRecord), this);
	using FunctionType = decltype(onRecord(sender))(*)(FindBPMLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5159a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto FindBPMLayer::recordingDidStop() -> decltype(recordingDidStop()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::recordingDidStop), this);
	using FunctionType = decltype(recordingDidStop())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x5159e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::create(int current, int begin, int end, gd::string title, gd::string button, bool p5, int p6, float p7, bool p8, bool p9) -> decltype(create(current, begin, end, title, button, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(create(current, begin, end, title, button, p5, p6, p7, p8, p9))(*)(int, int, int, gd::string, gd::string, bool, int, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2a6f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(current, begin, end, title, button, p5, p6, p7, p8, p9);
}

auto SetIDPopup::init(int current, int begin, int end, gd::string title, gd::string button, bool p5, int p6, float p7, bool p8, bool p9) -> decltype(init(current, begin, end, title, button, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(init(current, begin, end, title, button, p5, p6, p7, p8, p9))(*)(SetIDPopup*, int, int, int, gd::string, gd::string, bool, int, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2a7270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, current, begin, end, title, button, p5, p6, p7, p8, p9);
}

auto SetIDPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetIDPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x2a7fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetIDPopup::show), this);
	using FunctionType = decltype(show())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x2a7f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetIDPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetIDPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2a7de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetIDPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetIDPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetIDPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2a7e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SetIDPopup::valueChanged() {}

auto FindObjectPopup::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindObjectPopup::init), this);
	using FunctionType = decltype(init())(*)(FindObjectPopup*);
	static auto func = wrapFunction(base::get() + 0x2a8eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FMODAudioEngine::sharedEngine() -> decltype(sharedEngine()) {
	using FunctionType = decltype(sharedEngine())(*)();
	static auto func = wrapFunction(base::get() + 0x3e0a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FMODAudioEngine::channelForChannelID(int p0) -> decltype(channelForChannelID(p0)) {
	using FunctionType = decltype(channelForChannelID(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x3e4320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::clearAllAudio() -> decltype(clearAllAudio()) {
	using FunctionType = decltype(clearAllAudio())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3e1f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void FMODAudioEngine::disableMetering() {
		this->m_metering = false;
	}

void FMODAudioEngine::enableMetering() {
		this->m_metering = true;
		this->m_pulse1 = 0.1f;
		this->m_pulse2 = 0.1f;
		this->m_pulse3 = 0.0f;
	}

auto FMODAudioEngine::fadeOutMusic(float p0, int p1) -> decltype(fadeOutMusic(p0, p1)) {
	using FunctionType = decltype(fadeOutMusic(p0, p1))(*)(FMODAudioEngine*, float, int);
	static auto func = wrapFunction(base::get() + 0x3ef250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::getActiveMusicChannel(int musicChannel) -> decltype(getActiveMusicChannel(musicChannel)) {
	using FunctionType = decltype(getActiveMusicChannel(musicChannel))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x3e5fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, musicChannel);
}

auto FMODAudioEngine::getEffectsVolume() -> decltype(getEffectsVolume()) {
	using FunctionType = decltype(getEffectsVolume())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3eba70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::getMeteringValue() -> decltype(getMeteringValue()) {
	using FunctionType = decltype(getMeteringValue())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3e7ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::isMusicPlaying(gd::string path, int p1) -> decltype(isMusicPlaying(path, p1)) {
	using FunctionType = decltype(isMusicPlaying(path, p1))(*)(FMODAudioEngine*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x3ebaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, p1);
}

auto FMODAudioEngine::playEffect(gd::string path, float speed, float p2, float volume) -> decltype(playEffect(path, speed, p2, volume)) {
	using FunctionType = decltype(playEffect(path, speed, p2, volume))(*)(FMODAudioEngine*, gd::string, float, float, float);
	static auto func = wrapFunction(base::get() + 0x3e8a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, speed, p2, volume);
}

auto FMODAudioEngine::playEffect(gd::string path) -> decltype(playEffect(path)) {
	using FunctionType = decltype(playEffect(path))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x3e8960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path);
}

auto FMODAudioEngine::playEffectAdvanced(gd::string path, float speed, float p2, float volume, float pitch, bool fastFourierTransform, bool reverb, int startMillis, int endMillis, int fadeIn, int fadeOut, bool loopEnabled, int p12, bool override, bool p14, int p15, int uniqueID, float minInterval, int sfxGroup) -> decltype(playEffectAdvanced(path, speed, p2, volume, pitch, fastFourierTransform, reverb, startMillis, endMillis, fadeIn, fadeOut, loopEnabled, p12, override, p14, p15, uniqueID, minInterval, sfxGroup)) {
	using FunctionType = decltype(playEffectAdvanced(path, speed, p2, volume, pitch, fastFourierTransform, reverb, startMillis, endMillis, fadeIn, fadeOut, loopEnabled, p12, override, p14, p15, uniqueID, minInterval, sfxGroup))(*)(FMODAudioEngine*, gd::string, float, float, float, float, bool, bool, int, int, int, int, bool, int, bool, bool, int, int, float, int);
	static auto func = wrapFunction(base::get() + 0x3e6190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, speed, p2, volume, pitch, fastFourierTransform, reverb, startMillis, endMillis, fadeIn, fadeOut, loopEnabled, p12, override, p14, p15, uniqueID, minInterval, sfxGroup);
}

auto FMODAudioEngine::resumeAllAudio() -> decltype(resumeAllAudio()) {
	using FunctionType = decltype(resumeAllAudio())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3e1f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::resumeAllMusic() -> decltype(resumeAllMusic()) {
	using FunctionType = decltype(resumeAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3ebb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::setup() -> decltype(setup()) {
	using FunctionType = decltype(setup())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3e0e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::stopAllEffects() -> decltype(stopAllEffects()) {
	using FunctionType = decltype(stopAllEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3e2040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::stopAllMusic() -> decltype(stopAllMusic()) {
	using FunctionType = decltype(stopAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3e2820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&FMODAudioEngine::update), this);
	using FunctionType = decltype(update(p0))(*)(FMODAudioEngine*, float);
	static auto func = wrapFunction(base::get() + 0x3e2ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FMODLevelVisualizer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2ac1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FMODLevelVisualizer::updateVisualizer(float p0, float p1, float p2) -> decltype(updateVisualizer(p0, p1, p2)) {
	using FunctionType = decltype(updateVisualizer(p0, p1, p2))(*)(FMODLevelVisualizer*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x2ac670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODLevelVisualizer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FMODLevelVisualizer::init), this);
	using FunctionType = decltype(init())(*)(FMODLevelVisualizer*);
	static auto func = wrapFunction(base::get() + 0x2ac230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameRateDelegate::updateRate() -> decltype(updateRate()) {
	throw std::runtime_error("GameRateDelegate::updateRate not implemented");
}

auto RewardedVideoDelegate::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("RewardedVideoDelegate::rewardedVideoFinished not implemented");
}

auto RewardedVideoDelegate::shouldOffsetRewardCurrency() -> decltype(shouldOffsetRewardCurrency()) {
	throw std::runtime_error("RewardedVideoDelegate::shouldOffsetRewardCurrency not implemented");
}

auto FollowRewardPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::init), this);
	using FunctionType = decltype(init())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x428540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x42a7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x42a780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::show), this);
	using FunctionType = decltype(show())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x42a550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FollowRewardPage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FollowRewardPage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x42a6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FollowRewardPage::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x42a530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::updateRate() -> decltype(updateRate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::updateRate), this);
	using FunctionType = decltype(updateRate())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x429e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ForceBlockGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&ForceBlockGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ForceBlockGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1e63c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ForceBlockGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ForceBlockGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ForceBlockGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1e5440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FriendRequestDelegate::loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadFRequestsFinished(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::loadFRequestsFinished not implemented");
}

auto FriendRequestDelegate::loadFRequestsFailed(char const* p0, GJErrorCode p1) -> decltype(loadFRequestsFailed(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::loadFRequestsFailed not implemented");
}

auto FriendRequestDelegate::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::setupPageInfo not implemented");
}

auto FriendRequestDelegate::forceReloadRequests(bool p0) -> decltype(forceReloadRequests(p0)) {
	throw std::runtime_error("FriendRequestDelegate::forceReloadRequests not implemented");
}

auto FRequestProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FRequestProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FRequestProfilePage*);
	static auto func = wrapFunction(base::get() + 0x79d050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FRequestProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FRequestProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FRequestProfilePage*);
	static auto func = wrapFunction(base::get() + 0x79d020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FRequestProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FRequestProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FRequestProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x79cf30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&FRequestProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(FRequestProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x79d090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FRequestProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FRequestProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(FRequestProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x79d100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FRequestProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(FRequestProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x79d2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadFRequestsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&FRequestProfilePage::loadFRequestsFinished), this);
	using FunctionType = decltype(loadFRequestsFinished(p0, p1))(*)(FRequestProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x79d660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::loadFRequestsFailed(char const* p0, GJErrorCode p1) -> decltype(loadFRequestsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, GJErrorCode>::func(&FRequestProfilePage::loadFRequestsFailed), this);
	using FunctionType = decltype(loadFRequestsFailed(p0, p1))(*)(FRequestProfilePage*, char const*, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x79d750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&FRequestProfilePage::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(FRequestProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x79d8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::forceReloadRequests(bool p0) -> decltype(forceReloadRequests(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&FRequestProfilePage::forceReloadRequests), this);
	using FunctionType = decltype(forceReloadRequests(p0))(*)(FRequestProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x79d860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FriendRequestPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FriendRequestPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FriendRequestPopup*);
	static auto func = wrapFunction(base::get() + 0x2a1410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendRequestPopup::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FriendRequestPopup::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(FriendRequestPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x2a1500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendRequestPopup::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FriendRequestPopup::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(FriendRequestPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x2a16d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendRequestPopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&FriendRequestPopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(FriendRequestPopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2a1820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FriendRequestPopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FriendRequestPopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FriendRequestPopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2a1990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UserListDelegate::getUserListFinished(cocos2d::CCArray* p0, UserListType p1) -> decltype(getUserListFinished(p0, p1)) {
	throw std::runtime_error("UserListDelegate::getUserListFinished not implemented");
}

auto UserListDelegate::getUserListFailed(UserListType p0, GJErrorCode p1) -> decltype(getUserListFailed(p0, p1)) {
	throw std::runtime_error("UserListDelegate::getUserListFailed not implemented");
}

auto UserListDelegate::userListChanged(cocos2d::CCArray* p0, UserListType p1) -> decltype(userListChanged(p0, p1)) {
	throw std::runtime_error("UserListDelegate::userListChanged not implemented");
}

auto UserListDelegate::forceReloadList(UserListType p0) -> decltype(forceReloadList(p0)) {
	throw std::runtime_error("UserListDelegate::forceReloadList not implemented");
}

auto FriendsProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FriendsProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FriendsProfilePage*);
	static auto func = wrapFunction(base::get() + 0x665540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendsProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FriendsProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FriendsProfilePage*);
	static auto func = wrapFunction(base::get() + 0x665510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendsProfilePage::getUserListFinished(cocos2d::CCArray* p0, UserListType p1) -> decltype(getUserListFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, UserListType>::func(&FriendsProfilePage::getUserListFinished), this);
	using FunctionType = decltype(getUserListFinished(p0, p1))(*)(FriendsProfilePage*, cocos2d::CCArray*, UserListType);
	static auto func = wrapFunction(base::get() + 0x665190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::getUserListFailed(UserListType p0, GJErrorCode p1) -> decltype(getUserListFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<UserListType, GJErrorCode>::func(&FriendsProfilePage::getUserListFailed), this);
	using FunctionType = decltype(getUserListFailed(p0, p1))(*)(FriendsProfilePage*, UserListType, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x6652d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::userListChanged(cocos2d::CCArray* p0, UserListType p1) -> decltype(userListChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, UserListType>::func(&FriendsProfilePage::userListChanged), this);
	using FunctionType = decltype(userListChanged(p0, p1))(*)(FriendsProfilePage*, cocos2d::CCArray*, UserListType);
	static auto func = wrapFunction(base::get() + 0x6653e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::forceReloadList(UserListType p0) -> decltype(forceReloadList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UserListType>::func(&FriendsProfilePage::forceReloadList), this);
	using FunctionType = decltype(forceReloadList(p0))(*)(FriendsProfilePage*, UserListType);
	static auto func = wrapFunction(base::get() + 0x665420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameCell::init), this);
	using FunctionType = decltype(init())(*)(GameCell*);
	static auto func = wrapFunction(base::get() + 0x30c840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameCell::draw), this);
	using FunctionType = decltype(draw())(*)(GameCell*);
	static auto func = wrapFunction(base::get() + 0x30c900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameLevelManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x5233f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

GameLevelManager* GameLevelManager::get() {
		return GameLevelManager::sharedState();
	}

auto GameLevelManager::deleteLevel(GJGameLevel* p0) -> decltype(deleteLevel(p0)) {
	using FunctionType = decltype(deleteLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x533f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteSentFriendRequest(int p0) -> decltype(deleteSentFriendRequest(p0)) {
	using FunctionType = decltype(deleteSentFriendRequest(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x55bc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteServerLevel(int p0) -> decltype(deleteServerLevel(p0)) {
	using FunctionType = decltype(deleteServerLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x54e760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteUserMessages(GJUserMessage* message, cocos2d::CCArray* messages, bool isSender) -> decltype(deleteUserMessages(message, messages, isSender)) {
	using FunctionType = decltype(deleteUserMessages(message, messages, isSender))(*)(GameLevelManager*, GJUserMessage*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x5566e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, message, messages, isSender);
}

auto GameLevelManager::downloadLevel(int p0, bool p1) -> decltype(downloadLevel(p0, p1)) {
	using FunctionType = decltype(downloadLevel(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x54b6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

char const* GameLevelManager::getAccountCommentKey(int p0, int p1) {
		return cocos2d::CCString::createWithFormat("%i_%i", p0, p1)->getCString();
	}

auto GameLevelManager::getActiveDailyID(GJTimedLevelType p0) -> decltype(getActiveDailyID(p0)) {
	using FunctionType = decltype(getActiveDailyID(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x560ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

gd::string GameLevelManager::getCommentKey(int ID, int page, int mode, CommentKeyType keytype) {
		return cocos2d::CCString::createWithFormat("comment_%i_%i_%i_%i", ID, page, mode, (int) keytype)->getCString();
	}

auto GameLevelManager::getDailyID(GJTimedLevelType p0) -> decltype(getDailyID(p0)) {
	using FunctionType = decltype(getDailyID(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x560e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getDailyTimer(GJTimedLevelType p0) -> decltype(getDailyTimer(p0)) {
	using FunctionType = decltype(getDailyTimer(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x560ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGJUserInfo(int p0) -> decltype(getGJUserInfo(p0)) {
	using FunctionType = decltype(getGJUserInfo(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5542e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getHighestLevelOrder() -> decltype(getHighestLevelOrder()) {
	using FunctionType = decltype(getHighestLevelOrder())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x53c1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getLevelComments(int ID, int page, int total, int mode, CommentKeyType keytype) -> decltype(getLevelComments(ID, page, total, mode, keytype)) {
	using FunctionType = decltype(getLevelComments(ID, page, total, mode, keytype))(*)(GameLevelManager*, int, int, int, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x557010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, ID, page, total, mode, keytype);
}

const char* GameLevelManager::getLevelDownloadKey(int levelID, bool isGauntlet) {
		return cocos2d::CCString::createWithFormat("%i_%i", levelID, isGauntlet)->getCString();
	}

const char* GameLevelManager::getLevelKey(int levelID) {
		return cocos2d::CCString::createWithFormat("%i", levelID)->getCString();
	}

auto GameLevelManager::getLevelSaveData() -> decltype(getLevelSaveData()) {
	using FunctionType = decltype(getLevelSaveData())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x548020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getLowestLevelOrder() -> decltype(getLowestLevelOrder()) {
	using FunctionType = decltype(getLowestLevelOrder())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x53c1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getMainLevel(int levelID, bool dontGetLevelString) -> decltype(getMainLevel(levelID, dontGetLevelString)) {
	using FunctionType = decltype(getMainLevel(levelID, dontGetLevelString))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x532cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, levelID, dontGetLevelString);
}

auto GameLevelManager::getOnlineLevels(GJSearchObject* p0) -> decltype(getOnlineLevels(p0)) {
	using FunctionType = decltype(getOnlineLevels(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x546bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedDailyLevel(int p0) -> decltype(getSavedDailyLevel(p0)) {
	using FunctionType = decltype(getSavedDailyLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x53e2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedDailyLevelFromLevelID(int p0) -> decltype(getSavedDailyLevelFromLevelID(p0)) {
	using FunctionType = decltype(getSavedDailyLevelFromLevelID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x53e5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedLevel(int p0) -> decltype(getSavedLevel(p0)) {
	using FunctionType = decltype(getSavedLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x53e4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getStoredOnlineLevels(char const* p0) -> decltype(getStoredOnlineLevels(p0)) {
	using FunctionType = decltype(getStoredOnlineLevels(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x53f3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

const char* GameLevelManager::getTopArtistsKey(int page) {
		return cocos2d::CCString::createWithFormat("topArtists_%i", page)->getCString();
	}

auto GameLevelManager::getUserList(UserListType p0) -> decltype(getUserList(p0)) {
	using FunctionType = decltype(getUserList(p0))(*)(GameLevelManager*, UserListType);
	static auto func = wrapFunction(base::get() + 0x55df10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getUsers(GJSearchObject* p0) -> decltype(getUsers(p0)) {
	using FunctionType = decltype(getUsers(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x553eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::hasDailyStateBeenLoaded(GJTimedLevelType p0) -> decltype(hasDailyStateBeenLoaded(p0)) {
	using FunctionType = decltype(hasDailyStateBeenLoaded(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x560e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::hasLikedAccountItem(LikeItemType p0, int p1, bool p2, int p3) -> decltype(hasLikedAccountItem(p0, p1, p2, p3)) {
	using FunctionType = decltype(hasLikedAccountItem(p0, p1, p2, p3))(*)(GameLevelManager*, LikeItemType, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x55fa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::hasLikedItem(LikeItemType p0, int p1, bool p2, int p3) -> decltype(hasLikedItem(p0, p1, p2, p3)) {
	using FunctionType = decltype(hasLikedItem(p0, p1, p2, p3))(*)(GameLevelManager*, LikeItemType, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x55f970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::hasLikedItemFullCheck(LikeItemType p0, int p1, int p2) -> decltype(hasLikedItemFullCheck(p0, p1, p2)) {
	using FunctionType = decltype(hasLikedItemFullCheck(p0, p1, p2))(*)(GameLevelManager*, LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x55f170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::hasRatedDemon(int p0) -> decltype(hasRatedDemon(p0)) {
	using FunctionType = decltype(hasRatedDemon(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x54e670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::hasRatedLevelStars(int p0) -> decltype(hasRatedLevelStars(p0)) {
	using FunctionType = decltype(hasRatedLevelStars(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x54e2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::isFollowingUser(int p0) -> decltype(isFollowingUser(p0)) {
	using FunctionType = decltype(isFollowingUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x541020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::isTimeValid(char const* p0, float p1) -> decltype(isTimeValid(p0, p1)) {
	using FunctionType = decltype(isTimeValid(p0, p1))(*)(GameLevelManager*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x53f4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::isUpdateValid(int id) -> decltype(isUpdateValid(id)) {
	using FunctionType = decltype(isUpdateValid(id))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x54d630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, id);
}

void GameLevelManager::resetAccountComments(int accountID) {
		for(int i = 0; i <= 1; i++) {
			auto key = getAccountCommentKey(accountID, i);
			if(getStoredOnlineLevels(key)) {
				m_storedLevels->removeObjectForKey(key);
			}
		}
	}

auto GameLevelManager::resetDailyLevelState(GJTimedLevelType p0) -> decltype(resetDailyLevelState(p0)) {
	using FunctionType = decltype(resetDailyLevelState(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x560e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::storeUserName(int userID, int accountID, gd::string userName) -> decltype(storeUserName(userID, accountID, userName)) {
	using FunctionType = decltype(storeUserName(userID, accountID, userName))(*)(GameLevelManager*, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x5350e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, userID, accountID, userName);
}

auto GameLevelManager::updateUserScore() -> decltype(updateUserScore()) {
	using FunctionType = decltype(updateUserScore())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x54f880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::uploadUserMessage(int p0, gd::string p1, gd::string p2) -> decltype(uploadUserMessage(p0, p1, p2)) {
	using FunctionType = decltype(uploadUserMessage(p0, p1, p2))(*)(GameLevelManager*, int, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x556070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameLevelManager::init), this);
	using FunctionType = decltype(init())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x532b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameLevelOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameLevelOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(GameLevelOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2ae150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameLevelOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameLevelOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(GameLevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2ae1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

GameManager::~GameManager() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x38ddc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) GameManager(geode::CutoffConstructor, sizeof(GameManager));
	CCDestructor::lock(this) = true;
}

GameManager* GameManager::get() {
		return GameManager::sharedState();
	}

auto GameManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x3785a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

PlayLayer* GameManager::getPlayLayer() {
		return m_playLayer;
	}

LevelEditorLayer* GameManager::getEditorLayer() {
		return m_levelEditorLayer;
	}

GJBaseGameLayer* GameManager::getGameLayer() {
		return m_gameLayer;
	}

int GameManager::getPlayerFrame() {
        return m_playerFrame;
    }

int GameManager::getPlayerShip() {
        return m_playerShip;
    }

int GameManager::getPlayerBall() {
        return m_playerBall;
    }

int GameManager::getPlayerBird() {
        return m_playerBird;
    }

int GameManager::getPlayerDart() {
        return m_playerDart;
    }

int GameManager::getPlayerRobot() {
        return m_playerRobot;
    }

int GameManager::getPlayerSpider() {
        return m_playerSpider;
    }

int GameManager::getPlayerSwing() {
        return m_playerSwing;
    }

int GameManager::getPlayerGlowColor() {
        return m_playerGlowColor;
    }

int GameManager::getPlayerStreak() {
        return m_playerStreak;
    }

int GameManager::getPlayerShipFire() {
		return m_playerShipFire;
	}

int GameManager::getPlayerDeathEffect() {
        return m_playerDeathEffect;
    }

int GameManager::getPlayerJetpack() {
		return m_playerJetpack;
	}

int GameManager::getPlayerColor() {
        return m_playerColor;
    }

int GameManager::getPlayerColor2() {
        return m_playerColor2;
    }

bool GameManager::getPlayerGlow() {
        return m_playerGlow;
    }

void GameManager::setPlayerFrame(int id) {
        m_playerFrame = id;
    }

void GameManager::setPlayerShip(int id) {
        m_playerShip = id;
    }

void GameManager::setPlayerBall(int id) {
        m_playerBall = id;
    }

void GameManager::setPlayerBird(int id) {
        m_playerBird = id;
    }

void GameManager::setPlayerDart(int id) {
        m_playerDart = id;
    }

void GameManager::setPlayerRobot(int id) {
        m_playerRobot = id;
    }

void GameManager::setPlayerSpider(int id) {
        m_playerSpider = id;
    }

void GameManager::setPlayerSwing(int id) {
		m_playerSwing = id;
	}

void GameManager::setPlayerColor3(int id) {
		m_playerGlowColor = id;
	}

void GameManager::setPlayerStreak(int id) {
        m_playerStreak = id;
    }

void GameManager::setPlayerShipStreak(int id) {
        m_playerShipFire = id;
    }

void GameManager::setPlayerDeathEffect(int id) {
        m_playerDeathEffect = id;
    }

void GameManager::setPlayerJetpack(int id) {
		m_playerJetpack = id;
	}

void GameManager::setPlayerColor(int id) {
        m_playerColor = id;
    }

void GameManager::setPlayerColor2(int id) {
        m_playerColor2 = id;
    }

void GameManager::setPlayerGlow(bool v) {
        m_playerGlow = v;
    }

bool GameManager::getGameVariableDefault(const char* key, bool defaultValue) {
		//helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->boolValue();
    }

int GameManager::getIntGameVariableDefault(const char* key, int defaultValue) {
		//helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->intValue();
    }

auto GameManager::activeIconForType(IconType p0) -> decltype(activeIconForType(p0)) {
	using FunctionType = decltype(activeIconForType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x382430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::colorForIdx(int p0) -> decltype(colorForIdx(p0)) {
	using FunctionType = decltype(colorForIdx(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x381490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::countForType(IconType p0) -> decltype(countForType(p0)) {
	using FunctionType = decltype(countForType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x3826a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::didExitPlayscene() -> decltype(didExitPlayscene()) {
	using FunctionType = decltype(didExitPlayscene())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x38ccf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::fadeInMenuMusic() -> decltype(fadeInMenuMusic()) {
	using FunctionType = decltype(fadeInMenuMusic())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x378e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getBGTexture(int id) -> decltype(getBGTexture(id)) {
	using FunctionType = decltype(getBGTexture(id))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x3853b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, id);
}

auto GameManager::getFontFile(int p0) -> decltype(getFontFile(p0)) {
	using FunctionType = decltype(getFontFile(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x384950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::getGameVariable(char const* p0) -> decltype(getGameVariable(p0)) {
	using FunctionType = decltype(getGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x378d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

int GameManager::getIconRequestID() {
		return m_iconRequestID++;
	}

auto GameManager::iconTypeToUnlockType(IconType p0) -> decltype(iconTypeToUnlockType(p0)) {
	using FunctionType = decltype(iconTypeToUnlockType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x379930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::isColorUnlocked(int p0, UnlockType p1) -> decltype(isColorUnlocked(p0, p1)) {
	using FunctionType = decltype(isColorUnlocked(p0, p1))(*)(GameManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x379ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::isIconUnlocked(int p0, IconType p1) -> decltype(isIconUnlocked(p0, p1)) {
	using FunctionType = decltype(isIconUnlocked(p0, p1))(*)(GameManager*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x379870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

int GameManager::keyForIcon(int iconIdx, int iconEnum) {
		return m_keyStartForIcon->at(iconEnum) + iconIdx - 1;
	}

auto GameManager::loadBackground(int p0) -> decltype(loadBackground(p0)) {
	using FunctionType = decltype(loadBackground(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x384b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadIcon(int p0, int p1, int p2) -> decltype(loadIcon(p0, p1, p2)) {
	using FunctionType = decltype(loadIcon(p0, p1, p2))(*)(GameManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x383830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::reloadAll(bool switchingModes, bool toFullscreen, bool borderless, bool unused) -> decltype(reloadAll(switchingModes, toFullscreen, borderless, unused)) {
	using FunctionType = decltype(reloadAll(switchingModes, toFullscreen, borderless, unused))(*)(GameManager*, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x38d750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, switchingModes, toFullscreen, borderless, unused);
}

void GameManager::reloadAll(bool switchingModes, bool toFullscreen, bool unused) {
		return this->reloadAll(switchingModes, toFullscreen, false, unused);
	}

auto GameManager::reloadAllStep2() -> decltype(reloadAllStep2()) {
	using FunctionType = decltype(reloadAllStep2())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x38d7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reloadAllStep5() -> decltype(reloadAllStep5()) {
	using FunctionType = decltype(reloadAllStep5())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x38d9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::returnToLastScene(GJGameLevel* p0) -> decltype(returnToLastScene(p0)) {
	using FunctionType = decltype(returnToLastScene(p0))(*)(GameManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x38d180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::safePopScene() -> decltype(safePopScene()) {
	using FunctionType = decltype(safePopScene())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x38d5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::setGameVariable(char const* p0, bool p1) -> decltype(setGameVariable(p0, p1)) {
	using FunctionType = decltype(setGameVariable(p0, p1))(*)(GameManager*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x3854a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::setIntGameVariable(char const* p0, int p1) -> decltype(setIntGameVariable(p0, p1)) {
	using FunctionType = decltype(setIntGameVariable(p0, p1))(*)(GameManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x385a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::sheetNameForIcon(int p0, int p1) -> decltype(sheetNameForIcon(p0, p1)) {
	using FunctionType = decltype(sheetNameForIcon(p0, p1))(*)(GameManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x382cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameManager::update), this);
	using FunctionType = decltype(update(p0))(*)(GameManager*, float);
	static auto func = wrapFunction(base::get() + 0x38cd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameManager::init), this);
	using FunctionType = decltype(init())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x378600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GameManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(GameManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x38c1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GameManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(GameManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x38a360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x38b8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(GameOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2acbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(GameOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2ada80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameOptionsTrigger::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&GameOptionsTrigger::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(GameOptionsTrigger*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1aba30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameOptionsTrigger::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&GameOptionsTrigger::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(GameOptionsTrigger*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a9b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameStatsManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x5aea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameStatsManager::getBaseDiamonds(int p0) -> decltype(getBaseDiamonds(p0)) {
	using FunctionType = decltype(getBaseDiamonds(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x709e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getGauntletRewardKey(int p0) -> decltype(getGauntletRewardKey(p0)) {
	using FunctionType = decltype(getGauntletRewardKey(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x78b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getItemKey(int p0, int p1) -> decltype(getItemKey(p0, p1)) {
	using FunctionType = decltype(getItemKey(p0, p1))(*)(GameStatsManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x65010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::getItemUnlockState(int itemID, UnlockType unlockType) -> decltype(getItemUnlockState(itemID, unlockType)) {
	using FunctionType = decltype(getItemUnlockState(itemID, unlockType))(*)(GameStatsManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x78400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, itemID, unlockType);
}

auto GameStatsManager::getStat(char const* p0) -> decltype(getStat(p0)) {
	using FunctionType = decltype(getStat(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x657a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasCompletedLevel(GJGameLevel* level) -> decltype(hasCompletedLevel(level)) {
	using FunctionType = decltype(hasCompletedLevel(level))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x6d1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level);
}

auto GameStatsManager::hasCompletedMainLevel(int levelID) -> decltype(hasCompletedMainLevel(levelID)) {
	using FunctionType = decltype(hasCompletedMainLevel(levelID))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x6d160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, levelID);
}

auto GameStatsManager::hasPendingUserCoin(char const* p0) -> decltype(hasPendingUserCoin(p0)) {
	using FunctionType = decltype(hasPendingUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x6f5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasUserCoin(char const* p0) -> decltype(hasUserCoin(p0)) {
	using FunctionType = decltype(hasUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x6f690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::isItemUnlocked(UnlockType p0, int p1) -> decltype(isItemUnlocked(p0, p1)) {
	using FunctionType = decltype(isItemUnlocked(p0, p1))(*)(GameStatsManager*, UnlockType, int);
	static auto func = wrapFunction(base::get() + 0x6a450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::isSpecialChestUnlocked(gd::string p0) -> decltype(isSpecialChestUnlocked(p0)) {
	using FunctionType = decltype(isSpecialChestUnlocked(p0))(*)(GameStatsManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x78310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::toggleEnableItem(UnlockType p0, int p1, bool p2) -> decltype(toggleEnableItem(p0, p1, p2)) {
	using FunctionType = decltype(toggleEnableItem(p0, p1, p2))(*)(GameStatsManager*, UnlockType, int, bool);
	static auto func = wrapFunction(base::get() + 0x78870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameStatsManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameStatsManager::init), this);
	using FunctionType = decltype(init())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x5b350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameToolbox::addBackButton(cocos2d::CCLayer* p0, cocos2d::CCMenuItem* p1) -> decltype(addBackButton(p0, p1)) {
	using FunctionType = decltype(addBackButton(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x4fa520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::addRThumbScrollButton(cocos2d::CCLayer* p0) -> decltype(addRThumbScrollButton(p0)) {
	using FunctionType = decltype(addRThumbScrollButton(p0))(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4fa5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, float p7, float p8, float p9, cocos2d::CCPoint p10, char const* p11, bool p12, int p13, cocos2d::CCArray* p14) -> decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14))(*)(gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x4f9b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
}

auto GameToolbox::intToShortString(int p0) -> decltype(intToShortString(p0)) {
	using FunctionType = decltype(intToShortString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x501e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::stringSetupToDict(gd::string const& p0, char const* p1) -> decltype(stringSetupToDict(p0, p1)) {
	using FunctionType = decltype(stringSetupToDict(p0, p1))(*)(gd::string const&, char const*);
	static auto func = wrapFunction(base::get() + 0x4fbb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

void LevelManagerDelegate::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) {}

void LevelManagerDelegate::loadLevelsFailed(char const* p0) {}

void LevelManagerDelegate::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) {}

void LevelManagerDelegate::loadLevelsFailed(char const* p0, int p1) {}

void LevelManagerDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto GauntletLayer::create(GauntletType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GauntletType);
	static auto func = wrapFunction(base::get() + 0x3954e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletLayer::init(GauntletType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletLayer*, GauntletType);
	static auto func = wrapFunction(base::get() + 0x3956d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GauntletLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GauntletLayer*);
	static auto func = wrapFunction(base::get() + 0x3978b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&GauntletLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(GauntletLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x396e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GauntletLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&GauntletLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(GauntletLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x397010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletNode::init(GJMapPack* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletNode*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x57abf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletSelectLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x578d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletSelectLayer::setupGauntlets() -> decltype(setupGauntlets()) {
	using FunctionType = decltype(setupGauntlets())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x579a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GauntletSelectLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GauntletSelectLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x57ab60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GauntletSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x57aa30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletSelectLayer::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&GauntletSelectLayer::scrollLayerWillScrollToPage), this);
	using FunctionType = decltype(scrollLayerWillScrollToPage(p0, p1))(*)(GauntletSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x57a990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletSelectLayer::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&GauntletSelectLayer::scrollLayerScrolledToPage), this);
	using FunctionType = decltype(scrollLayerScrolledToPage(p0, p1))(*)(GauntletSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x57a8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletSelectLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&GauntletSelectLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(GauntletSelectLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x579fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GauntletSelectLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&GauntletSelectLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(GauntletSelectLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x57a180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GhostTrailEffect::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GhostTrailEffect::init), this);
	using FunctionType = decltype(init())(*)(GhostTrailEffect*);
	static auto func = wrapFunction(base::get() + 0x604890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GhostTrailEffect::draw() {}

GJAccountManager* GJAccountManager::get() {
		return GJAccountManager::sharedState();
	}

auto GJAccountManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0xd2800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJAccountManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJAccountManager::init), this);
	using FunctionType = decltype(init())(*)(GJAccountManager*);
	static auto func = wrapFunction(base::get() + 0xd5a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountSettingsDelegate::updateSettingsFinished() -> decltype(updateSettingsFinished()) {
	throw std::runtime_error("GJAccountSettingsDelegate::updateSettingsFinished not implemented");
}

auto GJAccountSettingsDelegate::updateSettingsFailed() -> decltype(updateSettingsFailed()) {
	throw std::runtime_error("GJAccountSettingsDelegate::updateSettingsFailed not implemented");
}

auto GJAccountSettingsLayer::create(int a1) -> decltype(create(a1)) {
	using FunctionType = decltype(create(a1))(*)(int);
	static auto func = wrapFunction(base::get() + 0x29b2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(a1);
}

auto GJAccountSettingsLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJAccountSettingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x29b470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJAccountSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJAccountSettingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJAccountSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x29df40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountSettingsLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&GJAccountSettingsLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(GJAccountSettingsLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x29d710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJAccountSettingsLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJAccountSettingsLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(GJAccountSettingsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x29d7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJActionManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJActionManager::init), this);
	using FunctionType = decltype(init())(*)(GJActionManager*);
	static auto func = wrapFunction(base::get() + 0x614890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void TriggerEffectDelegate::toggleGroupTriggered(int p0, bool p1, gd::vector<int> const& p2, int p3, int p4) {}

void TriggerEffectDelegate::spawnGroup(int p0, bool p1, double p2, gd::vector<int> const& p3, int p4, int p5) {}

void TriggerEffectDelegate::spawnObject(GameObject* p0, double p1, gd::vector<int> const& p2) {}

GJBaseGameLayer* GJBaseGameLayer::get() {
		return GameManager::get()->m_gameLayer;
	}

auto GJBaseGameLayer::addObjectCounter(LabelGameObject* p0) -> decltype(addObjectCounter(p0)) {
	using FunctionType = decltype(addObjectCounter(p0))(*)(GJBaseGameLayer*, LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x141020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::addToGroups(GameObject* p0, bool p1) -> decltype(addToGroups(p0, p1)) {
	using FunctionType = decltype(addToGroups(p0, p1))(*)(GJBaseGameLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1319f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::bumpPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(bumpPlayer(p0, p1)) {
	using FunctionType = decltype(bumpPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x11c6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::canBeActivatedByPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(canBeActivatedByPlayer(p0, p1)) {
	using FunctionType = decltype(canBeActivatedByPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x11c270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::checkCameraLimitAfterTeleport(PlayerObject* p0, float p1) -> decltype(checkCameraLimitAfterTeleport(p0, p1)) {
	using FunctionType = decltype(checkCameraLimitAfterTeleport(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x115690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::checkCollisions(PlayerObject* p0, float p1, bool p2) -> decltype(checkCollisions(p0, p1, p2)) {
	using FunctionType = decltype(checkCollisions(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x119810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::collisionCheckObjects(PlayerObject* p0, gd::vector<GameObject*>* p1, int p2, float p3) -> decltype(collisionCheckObjects(p0, p1, p2, p3)) {
	using FunctionType = decltype(collisionCheckObjects(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, gd::vector<GameObject*>*, int, float);
	static auto func = wrapFunction(base::get() + 0x11a8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::createBackground(int p0) -> decltype(createBackground(p0)) {
	using FunctionType = decltype(createBackground(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x107650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::enterDualMode(GameObject* p0, bool p1) -> decltype(enterDualMode(p0, p1)) {
	using FunctionType = decltype(enterDualMode(p0, p1))(*)(GJBaseGameLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x11e160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::flipGravity(PlayerObject* p0, bool p1, bool p2) -> decltype(flipGravity(p0, p1, p2)) {
	using FunctionType = decltype(flipGravity(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x118870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::gameEventTriggered(GJGameEvent p0, int p1, int p2) -> decltype(gameEventTriggered(p0, p1, p2)) {
	using FunctionType = decltype(gameEventTriggered(p0, p1, p2))(*)(GJBaseGameLayer*, GJGameEvent, int, int);
	static auto func = wrapFunction(base::get() + 0x115740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::gravBumpPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(gravBumpPlayer(p0, p1)) {
	using FunctionType = decltype(gravBumpPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x11c8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::handleButton(bool down, int button, bool isPlayer1) -> decltype(handleButton(down, button, isPlayer1)) {
	using FunctionType = decltype(handleButton(down, button, isPlayer1))(*)(GJBaseGameLayer*, bool, int, bool);
	static auto func = wrapFunction(base::get() + 0x13fc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, down, button, isPlayer1);
}

auto GJBaseGameLayer::loadLevelSettings() -> decltype(loadLevelSettings()) {
	using FunctionType = decltype(loadLevelSettings())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x14cce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::objectTypeToGameEvent(int p0) -> decltype(objectTypeToGameEvent(p0)) {
	using FunctionType = decltype(objectTypeToGameEvent(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x118d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::pauseAudio() -> decltype(pauseAudio()) {
	using FunctionType = decltype(pauseAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x146fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::playerTouchedRing(PlayerObject* p0, RingObject* p1) -> decltype(playerTouchedRing(p0, p1)) {
	using FunctionType = decltype(playerTouchedRing(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, RingObject*);
	static auto func = wrapFunction(base::get() + 0x11ca30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::processAreaEffects(gd::vector<EnterEffectInstance>* p0, GJAreaActionType p1, float p2, bool p3) -> decltype(processAreaEffects(p0, p1, p2, p3)) {
	using FunctionType = decltype(processAreaEffects(p0, p1, p2, p3))(*)(GJBaseGameLayer*, gd::vector<EnterEffectInstance>*, GJAreaActionType, float, bool);
	static auto func = wrapFunction(base::get() + 0x1358e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::processAreaVisualActions(float p0) -> decltype(processAreaVisualActions(p0)) {
	using FunctionType = decltype(processAreaVisualActions(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1389e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processCommands(float p0) -> decltype(processCommands(p0)) {
	using FunctionType = decltype(processCommands(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x148740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processQueuedButtons() -> decltype(processQueuedButtons()) {
	using FunctionType = decltype(processQueuedButtons())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x13fbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::queueButton(int button, bool push, bool isPlayer2) -> decltype(queueButton(button, push, isPlayer2)) {
	using FunctionType = decltype(queueButton(button, push, isPlayer2))(*)(GJBaseGameLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x13fa20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, button, push, isPlayer2);
}

auto GJBaseGameLayer::refreshKeyframeAnims() -> decltype(refreshKeyframeAnims()) {
	using FunctionType = decltype(refreshKeyframeAnims())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x111860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::removeObjectFromSection(GameObject* p0) -> decltype(removeObjectFromSection(p0)) {
	using FunctionType = decltype(removeObjectFromSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1332c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::reorderObjectSection(GameObject* p0) -> decltype(reorderObjectSection(p0)) {
	using FunctionType = decltype(reorderObjectSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x11f2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::resetAudio() -> decltype(resetAudio()) {
	using FunctionType = decltype(resetAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x147000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetCamera() -> decltype(resetCamera()) {
	using FunctionType = decltype(resetCamera())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x14e1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetLevelVariables() -> decltype(resetLevelVariables()) {
	using FunctionType = decltype(resetLevelVariables())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x14d150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void GJBaseGameLayer::resumeAudio() {
		FMODAudioEngine::sharedEngine()->resumeAllAudio();
		FMODAudioEngine::sharedEngine()->resumeAllMusic();
		FMODAudioEngine::sharedEngine()->m_system->update();
	}

auto GJBaseGameLayer::setStartPosObject(StartPosObject* startPos) -> decltype(setStartPosObject(startPos)) {
	using FunctionType = decltype(setStartPosObject(startPos))(*)(GJBaseGameLayer*, StartPosObject*);
	static auto func = wrapFunction(base::get() + 0x1176d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, startPos);
}

auto GJBaseGameLayer::shakeCamera(float p0, float p1, float p2) -> decltype(shakeCamera(p0, p1, p2)) {
	using FunctionType = decltype(shakeCamera(p0, p1, p2))(*)(GJBaseGameLayer*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x14f790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::toggleAudioVisualizer(bool p0) -> decltype(toggleAudioVisualizer(p0)) {
	using FunctionType = decltype(toggleAudioVisualizer(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1047d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) -> decltype(toggleDualMode(p0, p1, p2, p3)) {
	using FunctionType = decltype(toggleDualMode(p0, p1, p2, p3))(*)(GJBaseGameLayer*, GameObject*, bool, PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x117fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::toggleGroup(int p0, bool p1) -> decltype(toggleGroup(p0, p1)) {
	using FunctionType = decltype(toggleGroup(p0, p1))(*)(GJBaseGameLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x131520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::togglePlayerStreakBlend(bool p0) -> decltype(togglePlayerStreakBlend(p0)) {
	using FunctionType = decltype(togglePlayerStreakBlend(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x131910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::triggerGradientCommand(GradientTriggerObject* p0) -> decltype(triggerGradientCommand(p0)) {
	using FunctionType = decltype(triggerGradientCommand(p0))(*)(GJBaseGameLayer*, GradientTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x12d9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::tryGetMainObject(int p0) -> decltype(tryGetMainObject(p0)) {
	using FunctionType = decltype(tryGetMainObject(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x11ea90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateAudioVisualizer() -> decltype(updateAudioVisualizer()) {
	using FunctionType = decltype(updateAudioVisualizer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1485d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateCamera(float p0) -> decltype(updateCamera(p0)) {
	using FunctionType = decltype(updateCamera(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x148c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateCameraOffsetX(float p0, float p1, int p2, float p3, int p4, int p5) -> decltype(updateCameraOffsetX(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(updateCameraOffsetX(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, float, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x144270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::updateCameraOffsetY(float p0, float p1, int p2, float p3, int p4, int p5) -> decltype(updateCameraOffsetY(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(updateCameraOffsetY(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, float, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x144370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::updateDualGround(PlayerObject* p0, int p1, bool p2, float p3) -> decltype(updateDualGround(p0, p1, p2, p3)) {
	using FunctionType = decltype(updateDualGround(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, int, bool, float);
	static auto func = wrapFunction(base::get() + 0x118660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::updateEnterEffects(float p0) -> decltype(updateEnterEffects(p0)) {
	using FunctionType = decltype(updateEnterEffects(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x113110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateGradientLayers() -> decltype(updateGradientLayers()) {
	using FunctionType = decltype(updateGradientLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x12e160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateLevelColors() -> decltype(updateLevelColors()) {
	using FunctionType = decltype(updateLevelColors())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1078c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateParticles(float p0) -> decltype(updateParticles(p0)) {
	using FunctionType = decltype(updateParticles(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x152c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateShaderLayer(float p0) -> decltype(updateShaderLayer(p0)) {
	using FunctionType = decltype(updateShaderLayer(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x12fdd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateSpecialGroupData() -> decltype(updateSpecialGroupData()) {
	using FunctionType = decltype(updateSpecialGroupData())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x10aa20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateStaticCameraPos(cocos2d::CCPoint p0, bool p1, bool p2, bool p3, float p4, int p5, float p6) -> decltype(updateStaticCameraPos(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(updateStaticCameraPos(p0, p1, p2, p3, p4, p5, p6))(*)(GJBaseGameLayer*, cocos2d::CCPoint, bool, bool, bool, float, int, float);
	static auto func = wrapFunction(base::get() + 0x1191c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto GJBaseGameLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x147140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::init), this);
	using FunctionType = decltype(init())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x102b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::visit), this);
	using FunctionType = decltype(visit())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1581b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	throw std::runtime_error("GJBaseGameLayer::postUpdate not implemented");
}

auto GJBaseGameLayer::checkForEnd() -> decltype(checkForEnd()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::checkForEnd), this);
	using FunctionType = decltype(checkForEnd())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfd990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::testTime() -> decltype(testTime()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::testTime), this);
	using FunctionType = decltype(testTime())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfd9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::updateVerifyDamage() -> decltype(updateVerifyDamage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::updateVerifyDamage), this);
	using FunctionType = decltype(updateVerifyDamage())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfd9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::updateAttemptTime(float p0) -> decltype(updateAttemptTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::updateAttemptTime), this);
	using FunctionType = decltype(updateAttemptTime(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0xfd9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateVisibility not implemented");
}

auto GJBaseGameLayer::playerTookDamage(PlayerObject* p0) -> decltype(playerTookDamage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&GJBaseGameLayer::playerTookDamage), this);
	using FunctionType = decltype(playerTookDamage(p0))(*)(GJBaseGameLayer*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0xc0020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::opacityForObject(GameObject* p0) -> decltype(opacityForObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::opacityForObject), this);
	using FunctionType = decltype(opacityForObject(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x146f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::addToSpeedObjects(EffectGameObject* p0) -> decltype(addToSpeedObjects(p0)) {
	auto self = addresser::thunkAdjust(Resolve<EffectGameObject*>::func(&GJBaseGameLayer::addToSpeedObjects), this);
	using FunctionType = decltype(addToSpeedObjects(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0xc0030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::objectsCollided(int p0, int p1) -> decltype(objectsCollided(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJBaseGameLayer::objectsCollided), this);
	using FunctionType = decltype(objectsCollided(p0, p1))(*)(GJBaseGameLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x11faa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::updateColor(cocos2d::ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	throw std::runtime_error("GJBaseGameLayer::updateColor not implemented");
}

auto GJBaseGameLayer::toggleGroupTriggered(int p0, bool p1, gd::vector<int> const& p2, int p3, int p4) -> decltype(toggleGroupTriggered(p0, p1, p2, p3, p4)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool, gd::vector<int> const&, int, int>::func(&GJBaseGameLayer::toggleGroupTriggered), this);
	using FunctionType = decltype(toggleGroupTriggered(p0, p1, p2, p3, p4))(*)(GJBaseGameLayer*, int, bool, gd::vector<int> const&, int, int);
	static auto func = wrapFunction(base::get() + 0x1314b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4);
}

auto GJBaseGameLayer::spawnGroup(int p0, bool p1, double p2, gd::vector<int> const& p3, int p4, int p5) -> decltype(spawnGroup(p0, p1, p2, p3, p4, p5)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool, double, gd::vector<int> const&, int, int>::func(&GJBaseGameLayer::spawnGroup), this);
	using FunctionType = decltype(spawnGroup(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, int, bool, double, gd::vector<int> const&, int, int);
	static auto func = wrapFunction(base::get() + 0x1210c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::spawnObject(GameObject* p0, double p1, gd::vector<int> const& p2) -> decltype(spawnObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, double, gd::vector<int> const&>::func(&GJBaseGameLayer::spawnObject), this);
	using FunctionType = decltype(spawnObject(p0, p1, p2))(*)(GJBaseGameLayer*, GameObject*, double, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0x121460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GJBaseGameLayer::activateEndTrigger(int p0, bool p1, bool p2) -> decltype(activateEndTrigger(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool, bool>::func(&GJBaseGameLayer::activateEndTrigger), this);
	using FunctionType = decltype(activateEndTrigger(p0, p1, p2))(*)(GJBaseGameLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0xfd9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GJBaseGameLayer::activatePlatformerEndTrigger(EndTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activatePlatformerEndTrigger(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<EndTriggerGameObject*, gd::vector<int> const&>::func(&GJBaseGameLayer::activatePlatformerEndTrigger), this);
	using FunctionType = decltype(activatePlatformerEndTrigger(p0, p1))(*)(GJBaseGameLayer*, EndTriggerGameObject*, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0xfd9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::toggleGlitter(bool p0) -> decltype(toggleGlitter(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJBaseGameLayer::toggleGlitter), this);
	using FunctionType = decltype(toggleGlitter(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xfd9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::destroyPlayer(PlayerObject* p0, GameObject* p1) -> decltype(destroyPlayer(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*, GameObject*>::func(&GJBaseGameLayer::destroyPlayer), this);
	using FunctionType = decltype(destroyPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xfda00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::updateDebugDraw() -> decltype(updateDebugDraw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::updateDebugDraw), this);
	using FunctionType = decltype(updateDebugDraw())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x115b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::addToSection(GameObject* p0) -> decltype(addToSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::addToSection), this);
	using FunctionType = decltype(addToSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1336e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::addToGroup(GameObject* p0, int p1, bool p2) -> decltype(addToGroup(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int, bool>::func(&GJBaseGameLayer::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0, p1, p2))(*)(GJBaseGameLayer*, GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x131a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GJBaseGameLayer::removeFromGroup(GameObject* p0, int p1) -> decltype(removeFromGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int>::func(&GJBaseGameLayer::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0, p1))(*)(GJBaseGameLayer*, GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x131c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::updateObjectSection(GameObject* p0) -> decltype(updateObjectSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::updateObjectSection), this);
	using FunctionType = decltype(updateObjectSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1357e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateDisabledObjectsLastPos(cocos2d::CCArray* p0) -> decltype(updateDisabledObjectsLastPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*>::func(&GJBaseGameLayer::updateDisabledObjectsLastPos), this);
	using FunctionType = decltype(updateDisabledObjectsLastPos(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xc0040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::toggleGroundVisibility(bool p0) -> decltype(toggleGroundVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJBaseGameLayer::toggleGroundVisibility), this);
	using FunctionType = decltype(toggleGroundVisibility(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x143e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::toggleMGVisibility(bool p0) -> decltype(toggleMGVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJBaseGameLayer::toggleMGVisibility), this);
	using FunctionType = decltype(toggleMGVisibility(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x143e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::toggleHideAttempts(bool p0) -> decltype(toggleHideAttempts(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJBaseGameLayer::toggleHideAttempts), this);
	using FunctionType = decltype(toggleHideAttempts(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x143e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

float GJBaseGameLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) { return 0.f; }

float GJBaseGameLayer::posForTime(float p0) { return 0.f; }

void GJBaseGameLayer::resetSPTriggered() {}

auto GJBaseGameLayer::updateScreenRotation(float p0, bool p1, bool p2, float p3, int p4, float p5, int p6, int p7) -> decltype(updateScreenRotation(p0, p1, p2, p3, p4, p5, p6, p7)) {
	auto self = addresser::thunkAdjust(Resolve<float, bool, bool, float, int, float, int, int>::func(&GJBaseGameLayer::updateScreenRotation), this);
	using FunctionType = decltype(updateScreenRotation(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJBaseGameLayer*, float, bool, bool, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x144030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GJBaseGameLayer::reverseDirection(EffectGameObject* p0) -> decltype(reverseDirection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<EffectGameObject*>::func(&GJBaseGameLayer::reverseDirection), this);
	using FunctionType = decltype(reverseDirection(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x11ec40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::rotateGameplay(RotateGameplayGameObject* p0) -> decltype(rotateGameplay(p0)) {
	auto self = addresser::thunkAdjust(Resolve<RotateGameplayGameObject*>::func(&GJBaseGameLayer::rotateGameplay), this);
	using FunctionType = decltype(rotateGameplay(p0))(*)(GJBaseGameLayer*, RotateGameplayGameObject*);
	static auto func = wrapFunction(base::get() + 0x11ec80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::didRotateGameplay() -> decltype(didRotateGameplay()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::didRotateGameplay), this);
	using FunctionType = decltype(didRotateGameplay())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xc0050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::updateTimeWarp(float p0) -> decltype(updateTimeWarp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::updateTimeWarp), this);
	using FunctionType = decltype(updateTimeWarp(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1447d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateTimeWarp(GameObject* p0, float p1) -> decltype(updateTimeWarp(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, float>::func(&GJBaseGameLayer::updateTimeWarp), this);
	using FunctionType = decltype(updateTimeWarp(p0, p1))(*)(GJBaseGameLayer*, GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1447b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::applyTimeWarp(float p0) -> decltype(applyTimeWarp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::applyTimeWarp), this);
	using FunctionType = decltype(applyTimeWarp(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x144820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::playGravityEffect(bool p0) -> decltype(playGravityEffect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJBaseGameLayer::playGravityEffect), this);
	using FunctionType = decltype(playGravityEffect(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xfda10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	throw std::runtime_error("GJBaseGameLayer::manualUpdateObjectColors not implemented");
}

auto GJBaseGameLayer::createCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, bool p3) -> decltype(createCustomParticle(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::ParticleStruct const&, int, bool>::func(&GJBaseGameLayer::createCustomParticle), this);
	using FunctionType = decltype(createCustomParticle(p0, p1, p2, p3))(*)(GJBaseGameLayer*, gd::string const&, cocos2d::ParticleStruct const&, int, bool);
	static auto func = wrapFunction(base::get() + 0x152660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto GJBaseGameLayer::claimCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, int p3, int p4, bool p5) -> decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool>::func(&GJBaseGameLayer::claimCustomParticle), this);
	using FunctionType = decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x1529b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::unclaimCustomParticle(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(unclaimCustomParticle(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::CCParticleSystemQuad*>::func(&GJBaseGameLayer::unclaimCustomParticle), this);
	using FunctionType = decltype(unclaimCustomParticle(p0, p1))(*)(GJBaseGameLayer*, gd::string const&, cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0x152bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::activatedAudioTrigger(SFXTriggerGameObject* p0) -> decltype(activatedAudioTrigger(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXTriggerGameObject*>::func(&GJBaseGameLayer::activatedAudioTrigger), this);
	using FunctionType = decltype(activatedAudioTrigger(p0))(*)(GJBaseGameLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x153b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	throw std::runtime_error("GJBaseGameLayer::checkpointActivated not implemented");
}

auto GJBaseGameLayer::flipArt(bool p0) -> decltype(flipArt(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJBaseGameLayer::flipArt), this);
	using FunctionType = decltype(flipArt(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x157ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::addKeyframe(KeyframeGameObject* p0) -> decltype(addKeyframe(p0)) {
	auto self = addresser::thunkAdjust(Resolve<KeyframeGameObject*>::func(&GJBaseGameLayer::addKeyframe), this);
	using FunctionType = decltype(addKeyframe(p0))(*)(GJBaseGameLayer*, KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0x1405b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateTimeLabel(int p0, int p1, bool p2) -> decltype(updateTimeLabel(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<int, int, bool>::func(&GJBaseGameLayer::updateTimeLabel), this);
	using FunctionType = decltype(updateTimeLabel(p0, p1, p2))(*)(GJBaseGameLayer*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0xfda20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GJBaseGameLayer::checkSnapshot() -> decltype(checkSnapshot()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::checkSnapshot), this);
	using FunctionType = decltype(checkSnapshot())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfda30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::toggleProgressbar() -> decltype(toggleProgressbar()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::toggleProgressbar), this);
	using FunctionType = decltype(toggleProgressbar())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfda40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::toggleInfoLabel() -> decltype(toggleInfoLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::toggleInfoLabel), this);
	using FunctionType = decltype(toggleInfoLabel())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfda50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::removeAllCheckpoints() -> decltype(removeAllCheckpoints()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::removeAllCheckpoints), this);
	using FunctionType = decltype(removeAllCheckpoints())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfda60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::toggleMusicInPractice() -> decltype(toggleMusicInPractice()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::toggleMusicInPractice), this);
	using FunctionType = decltype(toggleMusicInPractice())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfda70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBigSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBigSprite::init), this);
	using FunctionType = decltype(init())(*)(GJBigSprite*);
	static auto func = wrapFunction(base::get() + 0x265f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBigSpriteNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBigSpriteNode::init), this);
	using FunctionType = decltype(init())(*)(GJBigSpriteNode*);
	static auto func = wrapFunction(base::get() + 0x265f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJChestSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJChestSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJChestSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x21a180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJChestSprite::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GJChestSprite::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(GJChestSprite*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x21a090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJColorSetupLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJColorSetupLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJColorSetupLayer*);
	static auto func = wrapFunction(base::get() + 0x206870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJColorSetupLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&GJColorSetupLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(GJColorSetupLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x206840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJComment::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJComment::init), this);
	using FunctionType = decltype(init())(*)(GJComment*);
	static auto func = wrapFunction(base::get() + 0x568dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJCommentListLayer::create(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) -> decltype(create(listView, title, color, width, height, blueBorder)) {
	using FunctionType = decltype(create(listView, title, color, width, height, blueBorder))(*)(BoomListView*, char const*, cocos2d::ccColor4B, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x29a930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(listView, title, color, width, height, blueBorder);
}

auto GJCommentListLayer::init(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) -> decltype(init(listView, title, color, width, height, blueBorder)) {
	using FunctionType = decltype(init(listView, title, color, width, height, blueBorder))(*)(GJCommentListLayer*, BoomListView*, char const*, cocos2d::ccColor4B, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x29aa40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, listView, title, color, width, height, blueBorder);
}

auto GJDifficultySprite::create(int p0, GJDifficultyName p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x2b2920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJDifficultySprite::getDifficultyFrame(int p0, GJDifficultyName p1) -> decltype(getDifficultyFrame(p0, p1)) {
	using FunctionType = decltype(getDifficultyFrame(p0, p1))(*)(int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x2b2a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJDifficultySprite::init(int p0, GJDifficultyName p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJDifficultySprite*, int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x2b2a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJDifficultySprite::updateDifficultyFrame(int p0, GJDifficultyName p1) -> decltype(updateDifficultyFrame(p0, p1)) {
	using FunctionType = decltype(updateDifficultyFrame(p0, p1))(*)(GJDifficultySprite*, int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x2b2ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJDifficultySprite::updateFeatureState(GJFeatureState p0) -> decltype(updateFeatureState(p0)) {
	using FunctionType = decltype(updateFeatureState(p0))(*)(GJDifficultySprite*, GJFeatureState);
	static auto func = wrapFunction(base::get() + 0x2b2d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJDifficultySprite::updateFeatureStateFromLevel(GJGameLevel* p0) -> decltype(updateFeatureStateFromLevel(p0)) {
	using FunctionType = decltype(updateFeatureStateFromLevel(p0))(*)(GJDifficultySprite*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x2b2cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::activeColorForIndex(int p0) -> decltype(activeColorForIndex(p0)) {
	using FunctionType = decltype(activeColorForIndex(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2da1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::colorActionChanged(ColorAction* p0) -> decltype(colorActionChanged(p0)) {
	using FunctionType = decltype(colorActionChanged(p0))(*)(GJEffectManager*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x2db560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::colorExists(int p0) -> decltype(colorExists(p0)) {
	using FunctionType = decltype(colorExists(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2db530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::isGroupEnabled(int p0) -> decltype(isGroupEnabled(p0)) {
	using FunctionType = decltype(isGroupEnabled(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2e64b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::loadFromState(EffectManagerState& p0) -> decltype(loadFromState(p0)) {
	using FunctionType = decltype(loadFromState(p0))(*)(GJEffectManager*, EffectManagerState&);
	static auto func = wrapFunction(base::get() + 0x2ea7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::objectsCollided(int p0, int p1) -> decltype(objectsCollided(p0, p1)) {
	using FunctionType = decltype(objectsCollided(p0, p1))(*)(GJEffectManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x2dc570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::shouldBlend(int p0) -> decltype(shouldBlend(p0)) {
	using FunctionType = decltype(shouldBlend(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2da350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::updateColorEffects(float p0) -> decltype(updateColorEffects(p0)) {
	using FunctionType = decltype(updateColorEffects(p0))(*)(GJEffectManager*, float);
	static auto func = wrapFunction(base::get() + 0x2db6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("GJEffectManager::rewardedVideoFinished not implemented");
}

auto GJEffectManager::updateEffects(float p0) -> decltype(updateEffects(p0)) {
	using FunctionType = decltype(updateEffects(p0))(*)(GJEffectManager*, float);
	static auto func = wrapFunction(base::get() + 0x2db590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::updatePulseEffects(float p0) -> decltype(updatePulseEffects(p0)) {
	using FunctionType = decltype(updatePulseEffects(p0))(*)(GJEffectManager*, float);
	static auto func = wrapFunction(base::get() + 0x2db890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJEffectManager::init), this);
	using FunctionType = decltype(init())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x2d8d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGroundLayer::init(int p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJGroundLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x5f4320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGroundLayer::updateLineBlend(bool p0) -> decltype(updateLineBlend(p0)) {
	using FunctionType = decltype(updateLineBlend(p0))(*)(GJGroundLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5f5130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GJGroundLayer::draw() {}

auto GJGroundLayer::showGround() -> decltype(showGround()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGroundLayer::showGround), this);
	using FunctionType = decltype(showGround())(*)(GJGroundLayer*);
	static auto func = wrapFunction(base::get() + 0x5f5180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGroundLayer::fadeInGround(float p0) -> decltype(fadeInGround(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJGroundLayer::fadeInGround), this);
	using FunctionType = decltype(fadeInGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5f5190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGroundLayer::fadeOutGround(float p0) -> decltype(fadeOutGround(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJGroundLayer::fadeOutGround), this);
	using FunctionType = decltype(fadeOutGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5f5330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJFlyGroundLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJFlyGroundLayer::init), this);
	using FunctionType = decltype(init())(*)(GJFlyGroundLayer*);
	static auto func = wrapFunction(base::get() + 0x5f54c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJFollowCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJFollowCommandLayer::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(GJFollowCommandLayer*);
	static auto func = wrapFunction(base::get() + 0x2d37d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJFollowCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJFollowCommandLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(GJFollowCommandLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2d43a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto GJFollowCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJFollowCommandLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJFollowCommandLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2d3de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJFriendRequest::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJFriendRequest::init), this);
	using FunctionType = decltype(init())(*)(GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x567640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGameLevel::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x533810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJGameLevel::demonIconForDifficulty(DemonDifficultyType p0) -> decltype(demonIconForDifficulty(p0)) {
	using FunctionType = decltype(demonIconForDifficulty(p0))(*)(GJGameLevel*, DemonDifficultyType);
	static auto func = wrapFunction(base::get() + 0x566800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::getAverageDifficulty() -> decltype(getAverageDifficulty()) {
	using FunctionType = decltype(getAverageDifficulty())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x562d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

char const* GJGameLevel::getCoinKey(int coinNumber) {
		if(m_dailyID > 0) return cocos2d::CCString::createWithFormat("%i_%i_%i", m_levelID.value(), coinNumber, m_dailyID.value())->getCString();
		if(m_gauntletLevel) return cocos2d::CCString::createWithFormat("%i_%i_g", m_levelID.value(), coinNumber)->getCString();
		return cocos2d::CCString::createWithFormat("%i_%i", m_levelID.value(), coinNumber)->getCString();
	}

auto GJGameLevel::getLengthKey(int length, bool platformer) -> decltype(getLengthKey(length, platformer)) {
	using FunctionType = decltype(getLengthKey(length, platformer))(*)(GJGameLevel*, int, bool);
	static auto func = wrapFunction(base::get() + 0x562c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, length, platformer);
}

auto GJGameLevel::lengthKeyToString(int key) -> decltype(lengthKeyToString(key)) {
	using FunctionType = decltype(lengthKeyToString(key))(*)(int);
	static auto func = wrapFunction(base::get() + 0x562cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(key);
}

auto GJGameLevel::savePercentage(int percent, bool p1, int clicks, int attempts, bool p4) -> decltype(savePercentage(percent, p1, clicks, attempts, p4)) {
	using FunctionType = decltype(savePercentage(percent, p1, clicks, attempts, p4))(*)(GJGameLevel*, int, bool, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x562730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, percent, p1, clicks, attempts, p4);
}

auto GJGameLevel::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJGameLevel::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJGameLevel*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x565af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGameLevel::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLevel::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x5666a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGameLevel::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLevel::init), this);
	using FunctionType = decltype(init())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x562340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGameLoadingLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLoadingLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(GJGameLoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x15a350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGameLoadingLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLoadingLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(GJGameLoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x15a340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ListButtonBarDelegate::listButtonBarSwitchedPage(ListButtonBar* p0, int p1) -> decltype(listButtonBarSwitchedPage(p0, p1)) {
	throw std::runtime_error("ListButtonBarDelegate::listButtonBarSwitchedPage not implemented");
}

auto GJGarageLayer::getItems(IconType p0) -> decltype(getItems(p0)) {
	using FunctionType = decltype(getItems(p0))(*)(GJGarageLayer*, IconType);
	static auto func = wrapFunction(base::get() + 0x36f1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGarageLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onSelectTab(cocos2d::CCObject* sender) -> decltype(onSelectTab(sender)) {
	using FunctionType = decltype(onSelectTab(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36e1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::playRainbowEffect() -> decltype(playRainbowEffect()) {
	using FunctionType = decltype(playRainbowEffect())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x370230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::selectTab(IconType p0) -> decltype(selectTab(p0)) {
	using FunctionType = decltype(selectTab(p0))(*)(GJGarageLayer*, IconType);
	static auto func = wrapFunction(base::get() + 0x36e340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGarageLayer::setupPage(int p0, IconType p1) -> decltype(setupPage(p0, p1)) {
	using FunctionType = decltype(setupPage(p0, p1))(*)(GJGarageLayer*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x36e480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGarageLayer::setupSpecialPage() -> decltype(setupSpecialPage()) {
	using FunctionType = decltype(setupSpecialPage())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x36eb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::updatePlayerColors() -> decltype(updatePlayerColors()) {
	using FunctionType = decltype(updatePlayerColors())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x36c500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::init), this);
	using FunctionType = decltype(init())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x36a810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x3715d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x36de20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x36df50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x36e150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::listButtonBarSwitchedPage(ListButtonBar* p0, int p1) -> decltype(listButtonBarSwitchedPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ListButtonBar*, int>::func(&GJGarageLayer::listButtonBarSwitchedPage), this);
	using FunctionType = decltype(listButtonBarSwitchedPage(p0, p1))(*)(GJGarageLayer*, ListButtonBar*, int);
	static auto func = wrapFunction(base::get() + 0x370570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::showUnlockPopup(int p0, UnlockType p1) -> decltype(showUnlockPopup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, UnlockType>::func(&GJGarageLayer::showUnlockPopup), this);
	using FunctionType = decltype(showUnlockPopup(p0, p1))(*)(GJGarageLayer*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x370700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::updateRate() -> decltype(updateRate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::updateRate), this);
	using FunctionType = decltype(updateRate())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x371380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJGarageLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJGarageLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x371110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&GJGarageLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(GJGarageLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x371220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::playerColorChanged() -> decltype(playerColorChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::playerColorChanged), this);
	using FunctionType = decltype(playerColorChanged())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x370470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x36de00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGradientLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGradientLayer::init), this);
	using FunctionType = decltype(init())(*)(GJGradientLayer*);
	static auto func = wrapFunction(base::get() + 0x159cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJItemIcon::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJItemIcon::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJItemIcon*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x372e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJLevelList::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJLevelList::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJLevelList*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x56afa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJLevelList::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelList::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x56b210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLevelList::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelList::init), this);
	using FunctionType = decltype(init())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x569080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLevelScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x251a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLevelScoreCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelScoreCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x251a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJListLayer::create(BoomListView* p0, char const* p1, cocos2d::ccColor4B p2, float p3, float p4, int p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(BoomListView*, char const*, cocos2d::ccColor4B, float, float, int);
	static auto func = wrapFunction(base::get() + 0x5dadf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto GJListLayer::init(BoomListView* p0, char const* p1, cocos2d::ccColor4B p2, float p3, float p4, int p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(GJListLayer*, BoomListView*, char const*, cocos2d::ccColor4B, float, float, int);
	static auto func = wrapFunction(base::get() + 0x5daf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJLocalLevelScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLocalLevelScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJLocalLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x251820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLocalLevelScoreCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLocalLevelScoreCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJLocalLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x251840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMapPack::hasCompletedMapPack() -> decltype(hasCompletedMapPack()) {
	using FunctionType = decltype(hasCompletedMapPack())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x57b857, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int GJMapPack::totalMaps() {
		if (this->m_levels) {
			return this->m_levels->count();
		}

		return 0;
	}

auto GJMapPack::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMapPack::init), this);
	using FunctionType = decltype(init())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x566dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessageCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMessageCell::init), this);
	using FunctionType = decltype(init())(*)(GJMessageCell*);
	static auto func = wrapFunction(base::get() + 0x254100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessageCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMessageCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJMessageCell*);
	static auto func = wrapFunction(base::get() + 0x254410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessageCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJMessageCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJMessageCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2544e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessageCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJMessageCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x254670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessageCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJMessageCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x254850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJMessageCell::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJMessageCell*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2549c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMessagePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJMessagePopup*);
	static auto func = wrapFunction(base::get() + 0x2a3920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessagePopup::downloadMessageFinished(GJUserMessage* p0) -> decltype(downloadMessageFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserMessage*>::func(&GJMessagePopup::downloadMessageFinished), this);
	using FunctionType = decltype(downloadMessageFinished(p0))(*)(GJMessagePopup*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x2a3990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::downloadMessageFailed(int p0) -> decltype(downloadMessageFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJMessagePopup::downloadMessageFailed), this);
	using FunctionType = decltype(downloadMessageFailed(p0))(*)(GJMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x2a3a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessagePopup::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJMessagePopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x2a3af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessagePopup::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessagePopup::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJMessagePopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x2a3cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessagePopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJMessagePopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJMessagePopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2a3e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJMessagePopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJMessagePopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2a3f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMGLayer::updateMG01Blend(bool p0) -> decltype(updateMG01Blend(p0)) {
	using FunctionType = decltype(updateMG01Blend(p0))(*)(GJMGLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5f5fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJMGLayer::updateMG02Blend(bool p0) -> decltype(updateMG02Blend(p0)) {
	using FunctionType = decltype(updateMG02Blend(p0))(*)(GJMGLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5f6020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GJMGLayer::draw() {}

auto GJMGLayer::showGround() -> decltype(showGround()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMGLayer::showGround), this);
	using FunctionType = decltype(showGround())(*)(GJMGLayer*);
	static auto func = wrapFunction(base::get() + 0x5f5f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMoreGamesLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMoreGamesLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GJMoreGamesLayer*);
	static auto func = wrapFunction(base::get() + 0x7a1510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMPDelegate::joinLobbyFinished(int p0) -> decltype(joinLobbyFinished(p0)) {
	throw std::runtime_error("GJMPDelegate::joinLobbyFinished not implemented");
}

auto GJMPDelegate::joinLobbyFailed(int p0, GJMPErrorCode p1) -> decltype(joinLobbyFailed(p0, p1)) {
	throw std::runtime_error("GJMPDelegate::joinLobbyFailed not implemented");
}

auto GJMPDelegate::didUploadMPComment(int p0) -> decltype(didUploadMPComment(p0)) {
	throw std::runtime_error("GJMPDelegate::didUploadMPComment not implemented");
}

auto GJMPDelegate::updateComments() -> decltype(updateComments()) {
	throw std::runtime_error("GJMPDelegate::updateComments not implemented");
}

auto GJMultiplayerManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMultiplayerManager::init), this);
	using FunctionType = decltype(init())(*)(GJMultiplayerManager*);
	static auto func = wrapFunction(base::get() + 0x6671e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectDecoderDelegate::getDecodedObject(int p0, DS_Dictionary* p1) -> decltype(getDecodedObject(p0, p1)) {
	throw std::runtime_error("ObjectDecoderDelegate::getDecodedObject not implemented");
}

auto GJObjectDecoder::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJObjectDecoder::init), this);
	using FunctionType = decltype(init())(*)(GJObjectDecoder*);
	static auto func = wrapFunction(base::get() + 0x731e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJObjectDecoder::getDecodedObject(int p0, DS_Dictionary* p1) -> decltype(getDecodedObject(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, DS_Dictionary*>::func(&GJObjectDecoder::getDecodedObject), this);
	using FunctionType = decltype(getDecodedObject(p0, p1))(*)(GJObjectDecoder*, int, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x731e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJPurchaseDelegate::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	throw std::runtime_error("GJPurchaseDelegate::didPurchaseItem not implemented");
}

auto GJPathPage::create(int p0, GJPathsLayer* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2fd710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJPathPage::init(int p0, GJPathsLayer* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJPathPage*, int, GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2fdcf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJPathPage::onActivatePath(cocos2d::CCObject* sender) -> decltype(onActivatePath(sender)) {
	using FunctionType = decltype(onActivatePath(sender))(*)(GJPathPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ffb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathPage::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GJPathPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ff7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathPage::onIconInfo(cocos2d::CCObject* sender) -> decltype(onIconInfo(sender)) {
	using FunctionType = decltype(onIconInfo(sender))(*)(GJPathPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ff850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathPage::onUnlock(cocos2d::CCObject* sender) -> decltype(onUnlock(sender)) {
	using FunctionType = decltype(onUnlock(sender))(*)(GJPathPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ffa40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathPage::playUnlockAnimation() -> decltype(playUnlockAnimation()) {
	using FunctionType = decltype(playUnlockAnimation())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x2ffb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathPage::showCantAffordMessage(GJStoreItem* p0) -> decltype(showCantAffordMessage(p0)) {
	using FunctionType = decltype(showCantAffordMessage(p0))(*)(GJPathPage*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x300220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathPage::unlockAnimationFinished() -> decltype(unlockAnimationFinished()) {
	using FunctionType = decltype(unlockAnimationFinished())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x300c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathPage::unlockAnimationStep2() -> decltype(unlockAnimationStep2()) {
	using FunctionType = decltype(unlockAnimationStep2())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x300920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathPage::unlockAnimationStep3() -> decltype(unlockAnimationStep3()) {
	using FunctionType = decltype(unlockAnimationStep3())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x300d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x3018a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x301760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathPage::show), this);
	using FunctionType = decltype(show())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x3018e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathPage::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJStoreItem*>::func(&GJPathPage::didPurchaseItem), this);
	using FunctionType = decltype(didPurchaseItem(p0))(*)(GJPathPage*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x2ffb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJPathRewardPopup::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2fd890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathRewardPopup::closePopup() -> decltype(closePopup()) {
	using FunctionType = decltype(closePopup())(*)(GJPathRewardPopup*);
	static auto func = wrapFunction(base::get() + 0x302230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathRewardPopup::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPathRewardPopup*, int);
	static auto func = wrapFunction(base::get() + 0x301c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathRewardPopup::onClaim(cocos2d::CCObject* sender) -> decltype(onClaim(sender)) {
	using FunctionType = decltype(onClaim(sender))(*)(GJPathRewardPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x302100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void GJPathRewardPopup::keyBackClicked() {}

auto GJPathsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2fce10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJPathsLayer::darkenButtons(bool p0) -> decltype(darkenButtons(p0)) {
	using FunctionType = decltype(darkenButtons(p0))(*)(GJPathsLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2fd6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathsLayer::nameForPath(int p0) -> decltype(nameForPath(p0)) {
	using FunctionType = decltype(nameForPath(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2fcc70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(GJPathsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fd480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathsLayer::onPath(cocos2d::CCObject* sender) -> decltype(onPath(sender)) {
	using FunctionType = decltype(onPath(sender))(*)(GJPathsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fd600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::init), this);
	using FunctionType = decltype(init())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2fcf60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2fd680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2fdaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2fd9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::show), this);
	using FunctionType = decltype(show())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2fdae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2fd4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathSprite::addRankLabel(int p0) -> decltype(addRankLabel(p0)) {
	using FunctionType = decltype(addRankLabel(p0))(*)(GJPathSprite*, int);
	static auto func = wrapFunction(base::get() + 0x301b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathSprite::addShardSprite() -> decltype(addShardSprite()) {
	using FunctionType = decltype(addShardSprite())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x301650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathSprite::changeToLockedArt() -> decltype(changeToLockedArt()) {
	using FunctionType = decltype(changeToLockedArt())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x300640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathSprite::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPathSprite*, int);
	static auto func = wrapFunction(base::get() + 0x301a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathSprite::updateState() -> decltype(updateState()) {
	using FunctionType = decltype(updateState())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x2fd580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPFollowCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPFollowCommandLayer::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(GJPFollowCommandLayer*);
	static auto func = wrapFunction(base::get() + 0x367ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPFollowCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJPFollowCommandLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(GJPFollowCommandLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x368c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto GJPFollowCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJPFollowCommandLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJPFollowCommandLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3684c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJPromoPopup::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x2b2650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPromoPopup::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x2b2760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPromoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x2b2690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPromoPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::show), this);
	using FunctionType = decltype(show())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x2b27a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRequestCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRequestCell::init), this);
	using FunctionType = decltype(init())(*)(GJRequestCell*);
	static auto func = wrapFunction(base::get() + 0x253360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRequestCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRequestCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJRequestCell*);
	static auto func = wrapFunction(base::get() + 0x253670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRequestCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJRequestCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJRequestCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x253740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJRequestCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJRequestCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x253910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJRequestCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJRequestCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x253b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJRequestCell::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJRequestCell*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x253c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRewardDelegate::rewardsStatusFinished(int p0) -> decltype(rewardsStatusFinished(p0)) {
	throw std::runtime_error("GJRewardDelegate::rewardsStatusFinished not implemented");
}

auto GJRewardDelegate::rewardsStatusFailed() -> decltype(rewardsStatusFailed()) {
	throw std::runtime_error("GJRewardDelegate::rewardsStatusFailed not implemented");
}

auto GJRewardItem::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJRewardItem::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJRewardItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8e580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRewardItem::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRewardItem::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJRewardItem*);
	static auto func = wrapFunction(base::get() + 0x8e5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRewardObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJRewardObject::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJRewardObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8e000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRewardObject::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRewardObject::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJRewardObject*);
	static auto func = wrapFunction(base::get() + 0x8e080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRobotSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x5e4f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJRobotSprite::hideGlow() -> decltype(hideGlow()) {
	using FunctionType = decltype(hideGlow())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x5e5f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRobotSprite::init(int p0, gd::string p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJRobotSprite*, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x5e5100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJRobotSprite::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJRobotSprite*, int);
	static auto func = wrapFunction(base::get() + 0x5e5090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRobotSprite::showGlow() -> decltype(showGlow()) {
	using FunctionType = decltype(showGlow())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x5e5f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRobotSprite::updateColor01(cocos2d::ccColor3B p0) -> decltype(updateColor01(p0)) {
	using FunctionType = decltype(updateColor01(p0))(*)(GJRobotSprite*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x5e5fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRobotSprite::updateColor02(cocos2d::ccColor3B p0) -> decltype(updateColor02(p0)) {
	using FunctionType = decltype(updateColor02(p0))(*)(GJRobotSprite*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x5e62e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRobotSprite::updateColors() -> decltype(updateColors()) {
	using FunctionType = decltype(updateColors())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x5e5fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRobotSprite::updateFrame(int p0) -> decltype(updateFrame(p0)) {
	using FunctionType = decltype(updateFrame(p0))(*)(GJRobotSprite*, int);
	static auto func = wrapFunction(base::get() + 0x5e5720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRobotSprite::updateGlowColor(cocos2d::ccColor3B p0, bool p1) -> decltype(updateGlowColor(p0, p1)) {
	using FunctionType = decltype(updateGlowColor(p0, p1))(*)(GJRobotSprite*, cocos2d::ccColor3B, bool);
	static auto func = wrapFunction(base::get() + 0x5e6300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJRobotSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJRobotSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJRobotSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x5e6380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRobotSprite::hideSecondary() -> decltype(hideSecondary()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRobotSprite::hideSecondary), this);
	using FunctionType = decltype(hideSecondary())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x5e6490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotateCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotateCommandLayer::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(GJRotateCommandLayer*);
	static auto func = wrapFunction(base::get() + 0x43f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotateCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJRotateCommandLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(GJRotateCommandLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto GJRotateCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJRotateCommandLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJRotateCommandLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRotateCommandLayer::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&GJRotateCommandLayer::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(GJRotateCommandLayer*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x4910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotationControl::init), this);
	using FunctionType = decltype(init())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0x51fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotationControl::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotationControl::draw), this);
	using FunctionType = decltype(draw())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0x525e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotationControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x524d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x525a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScaleControl::init), this);
	using FunctionType = decltype(init())(*)(GJScaleControl*);
	static auto func = wrapFunction(base::get() + 0x52650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScaleControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x533c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x53520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScoreCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJScoreCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x245130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJScoreCell*);
	static auto func = wrapFunction(base::get() + 0x251390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScoreCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScoreCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJScoreCell*);
	static auto func = wrapFunction(base::get() + 0x251650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScoreCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJScoreCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJScoreCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x251590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSearchObject::create(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) -> decltype(create(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode)) {
	using FunctionType = decltype(create(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode))(*)(SearchType, gd::string, gd::string, gd::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, int, int, int);
	static auto func = wrapFunction(base::get() + 0x567a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode);
}

auto GJSearchObject::create(SearchType searchType, gd::string searchQuery) -> decltype(create(searchType, searchQuery)) {
	using FunctionType = decltype(create(searchType, searchQuery))(*)(SearchType, gd::string);
	static auto func = wrapFunction(base::get() + 0x567f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType, searchQuery);
}

auto GJSearchObject::create(SearchType searchType) -> decltype(create(searchType)) {
	using FunctionType = decltype(create(searchType))(*)(SearchType);
	static auto func = wrapFunction(base::get() + 0x567ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType);
}

auto GJSearchObject::getKey() -> decltype(getKey()) {
	using FunctionType = decltype(getKey())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x547b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSearchObject::getNextPageObject() -> decltype(getNextPageObject()) {
	using FunctionType = decltype(getNextPageObject())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x5687d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSearchObject::getPageObject(int page) -> decltype(getPageObject(page)) {
	using FunctionType = decltype(getPageObject(page))(*)(GJSearchObject*, int);
	static auto func = wrapFunction(base::get() + 0x5687f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, page);
}

auto GJSearchObject::isLevelSearchObject() -> decltype(isLevelSearchObject()) {
	using FunctionType = decltype(isLevelSearchObject())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x568be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJShopLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x323680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJShopLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJShopLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x325d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void GJShopLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void GJShopLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto GJShopLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJShopLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJShopLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x326190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJShopLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x3261d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x3246c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJStoreItem*>::func(&GJShopLayer::didPurchaseItem), this);
	using FunctionType = decltype(didPurchaseItem(p0))(*)(GJShopLayer*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x323fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJShopLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x323970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&GJShopLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(GJShopLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x325ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSmartBlockPreviewSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSmartBlockPreviewSprite::init), this);
	using FunctionType = decltype(init())(*)(GJSmartBlockPreviewSprite*);
	static auto func = wrapFunction(base::get() + 0x433380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSmartBlockPreviewSprite::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSmartBlockPreviewSprite::visit), this);
	using FunctionType = decltype(visit())(*)(GJSmartBlockPreviewSprite*);
	static auto func = wrapFunction(base::get() + 0x433390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSmartPrefab::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJSmartPrefab::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJSmartPrefab*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x432260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSmartPrefab::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSmartPrefab::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJSmartPrefab*);
	static auto func = wrapFunction(base::get() + 0x432110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSmartTemplate::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJSmartTemplate::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJSmartTemplate*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x431f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSmartTemplate::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSmartTemplate::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x431b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TableViewCellDelegate::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("TableViewCellDelegate::cellPerformedAction not implemented");
}

auto TableViewCellDelegate::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("TableViewCellDelegate::getSelectedCellIdx not implemented");
}

auto TableViewCellDelegate::shouldSnapToSelected() -> decltype(shouldSnapToSelected()) {
	throw std::runtime_error("TableViewCellDelegate::shouldSnapToSelected not implemented");
}

auto GJSongBrowser::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::init), this);
	using FunctionType = decltype(init())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x609a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x609cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJSongBrowser::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(GJSongBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x609ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSongBrowser::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJSongBrowser::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJSongBrowser*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x60a260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSongBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&GJSongBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(GJSongBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x60a340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto GJSongBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::getSelectedCellIdx), this);
	using FunctionType = decltype(getSelectedCellIdx())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x60a3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSpecialColorSelect::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSpecialColorSelect::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJSpecialColorSelect*);
	static auto func = wrapFunction(base::get() + 0x633bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSpiderSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x5e6690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJSpiderSprite::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJSpiderSprite*, int);
	static auto func = wrapFunction(base::get() + 0x5e67e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJTransformControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJTransformControl::init), this);
	using FunctionType = decltype(init())(*)(GJTransformControl*);
	static auto func = wrapFunction(base::get() + 0x53870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJTransformControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x53d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x541f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x547a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x549b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUINode::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUINode::draw), this);
	using FunctionType = decltype(draw())(*)(GJUINode*);
	static auto func = wrapFunction(base::get() + 0x4d5370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserCell::init), this);
	using FunctionType = decltype(init())(*)(GJUserCell*);
	static auto func = wrapFunction(base::get() + 0x251fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJUserCell*);
	static auto func = wrapFunction(base::get() + 0x2527a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJUserCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJUserCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x252870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJUserCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJUserCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x252b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJUserCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJUserCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x252d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJUserCell::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJUserCell*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x252e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJUserMessage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x567830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJUserMessage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserMessage::init), this);
	using FunctionType = decltype(init())(*)(GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x5678d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserScore::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x567170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJUserScore::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserScore::init), this);
	using FunctionType = decltype(init())(*)(GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x5672d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadMessageDelegate::uploadMessageFinished(int p0) -> decltype(uploadMessageFinished(p0)) {
	throw std::runtime_error("UploadMessageDelegate::uploadMessageFinished not implemented");
}

auto UploadMessageDelegate::uploadMessageFailed(int p0) -> decltype(uploadMessageFailed(p0)) {
	throw std::runtime_error("UploadMessageDelegate::uploadMessageFailed not implemented");
}

auto GJWriteMessagePopup::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJWriteMessagePopup::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJWriteMessagePopup*);
	static auto func = wrapFunction(base::get() + 0x2a5ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJWriteMessagePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJWriteMessagePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJWriteMessagePopup*);
	static auto func = wrapFunction(base::get() + 0x2a5a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GJWriteMessagePopup::textInputOpened(CCTextInputNode* p0) {}

auto GJWriteMessagePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJWriteMessagePopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(GJWriteMessagePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2a5af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJWriteMessagePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJWriteMessagePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2a5b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::uploadMessageFinished(int p0) -> decltype(uploadMessageFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJWriteMessagePopup::uploadMessageFinished), this);
	using FunctionType = decltype(uploadMessageFinished(p0))(*)(GJWriteMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x2a6150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::uploadMessageFailed(int p0) -> decltype(uploadMessageFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJWriteMessagePopup::uploadMessageFailed), this);
	using FunctionType = decltype(uploadMessageFailed(p0))(*)(GJWriteMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x2a6210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJWriteMessagePopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJWriteMessagePopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2a6340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJWriteMessagePopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJWriteMessagePopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2a6490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJWriteMessagePopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&GJWriteMessagePopup::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(GJWriteMessagePopup*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x2a6570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJWriteMessagePopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJWriteMessagePopup::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(GJWriteMessagePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2a6630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void GooglePlayDelegate::googlePlaySignedIn() {}

auto GooglePlayManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GooglePlayManager::init), this);
	using FunctionType = decltype(init())(*)(GooglePlayManager*);
	static auto func = wrapFunction(base::get() + 0x481fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GradientTriggerObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GradientTriggerObject::init), this);
	using FunctionType = decltype(init())(*)(GradientTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x196bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GradientTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&GradientTriggerObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(GradientTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x198500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GradientTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&GradientTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(GradientTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x196c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GravityEffectSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GravityEffectSprite::init), this);
	using FunctionType = decltype(init())(*)(GravityEffectSprite*);
	static auto func = wrapFunction(base::get() + 0xbfda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GravityEffectSprite::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GravityEffectSprite::draw), this);
	using FunctionType = decltype(draw())(*)(GravityEffectSprite*);
	static auto func = wrapFunction(base::get() + 0xc0000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HardStreak::addPoint(cocos2d::CCPoint p0) -> decltype(addPoint(p0)) {
	using FunctionType = decltype(addPoint(p0))(*)(HardStreak*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x9d260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto HardStreak::reset() -> decltype(reset()) {
	using FunctionType = decltype(reset())(*)(HardStreak*);
	static auto func = wrapFunction(base::get() + 0x9d240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto HardStreak::stopStroke() -> decltype(stopStroke()) {
	using FunctionType = decltype(stopStroke())(*)(HardStreak*);
	static auto func = wrapFunction(base::get() + 0x9d200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto HardStreak::updateStroke(float p0) -> decltype(updateStroke(p0)) {
	using FunctionType = decltype(updateStroke(p0))(*)(HardStreak*, float);
	static auto func = wrapFunction(base::get() + 0x9c970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto HardStreak::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HardStreak::init), this);
	using FunctionType = decltype(init())(*)(HardStreak*);
	static auto func = wrapFunction(base::get() + 0x9c7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HSVLiveOverlay::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HSVLiveOverlay::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(HSVLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x267120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HSVLiveOverlay::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HSVLiveOverlay::show), this);
	using FunctionType = decltype(show())(*)(HSVLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x2671d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HSVLiveOverlay::hsvChanged(ConfigureHSVWidget* p0) -> decltype(hsvChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureHSVWidget*>::func(&HSVLiveOverlay::hsvChanged), this);
	using FunctionType = decltype(hsvChanged(p0))(*)(HSVLiveOverlay*, ConfigureHSVWidget*);
	static auto func = wrapFunction(base::get() + 0x2672a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto HSVWidgetPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HSVWidgetPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(HSVWidgetPopup*);
	static auto func = wrapFunction(base::get() + 0x4398a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoAlertButton::create(gd::string p0, gd::string p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(gd::string, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x57cca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto InfoAlertButton::init(gd::string p0, gd::string p1, float p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(InfoAlertButton*, gd::string, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x57cf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto InfoAlertButton::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoAlertButton::activate), this);
	using FunctionType = decltype(activate())(*)(InfoAlertButton*);
	static auto func = wrapFunction(base::get() + 0x57cfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void LevelCommentDelegate::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) {}

void LevelCommentDelegate::loadCommentsFailed(char const* p0) {}

void LevelCommentDelegate::updateUserScoreFinished() {}

void LevelCommentDelegate::setupPageInfo(gd::string p0, char const* p1) {}

int InfoLayer::getID() {
		if(m_score) return m_score->m_userID;
		if(m_levelList) return - m_levelList->m_listID;
		if(m_level) return m_level->m_levelID;
		return 0;
	}

auto InfoLayer::init(GJGameLevel* p0, GJUserScore* p1, GJLevelList* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(InfoLayer*, GJGameLevel*, GJUserScore*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x7ba6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto InfoLayer::loadPage(int p0, bool p1) -> decltype(loadPage(p0, p1)) {
	using FunctionType = decltype(loadPage(p0, p1))(*)(InfoLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x7bd7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto InfoLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7bd440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7bd420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(InfoLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x7bdb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto InfoLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x7be910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x7be800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::show), this);
	using FunctionType = decltype(show())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x7bf760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&InfoLayer::loadCommentsFinished), this);
	using FunctionType = decltype(loadCommentsFinished(p0, p1))(*)(InfoLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x7bea70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&InfoLayer::loadCommentsFailed), this);
	using FunctionType = decltype(loadCommentsFailed(p0))(*)(InfoLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x7beb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto InfoLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&InfoLayer::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(InfoLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x7bebe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&InfoLayer::commentUploadFinished), this);
	using FunctionType = decltype(commentUploadFinished(p0))(*)(InfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x7bf310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto InfoLayer::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, CommentError>::func(&InfoLayer::commentUploadFailed), this);
	using FunctionType = decltype(commentUploadFailed(p0, p1))(*)(InfoLayer*, int, CommentError);
	static auto func = wrapFunction(base::get() + 0x7bf460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x7bf170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&InfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(InfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x7be5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ItemInfoPopup::create(int p0, UnlockType p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x3705b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto ItemInfoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ItemInfoPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ItemInfoPopup*);
	static auto func = wrapFunction(base::get() + 0x374960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ItemTriggerGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ItemTriggerGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ItemTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ded80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ItemTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&ItemTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(ItemTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1dedc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto ItemTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&ItemTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ItemTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1e3ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ItemTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ItemTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ItemTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1def10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto KeybindingsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeybindingsLayer::init), this);
	using FunctionType = decltype(init())(*)(KeybindingsLayer*);
	static auto func = wrapFunction(base::get() + 0x615040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeybindingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeybindingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(KeybindingsLayer*);
	static auto func = wrapFunction(base::get() + 0x616950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeybindingsManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeybindingsManager::init), this);
	using FunctionType = decltype(init())(*)(KeybindingsManager*);
	static auto func = wrapFunction(base::get() + 0x4ef7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeyframeAnimTriggerObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeyframeAnimTriggerObject::init), this);
	using FunctionType = decltype(init())(*)(KeyframeAnimTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x1b6710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeyframeAnimTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&KeyframeAnimTriggerObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(KeyframeAnimTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1b7780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto KeyframeAnimTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&KeyframeAnimTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(KeyframeAnimTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b6760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto KeyframeGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeyframeGameObject::init), this);
	using FunctionType = decltype(init())(*)(KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0x1c16a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeyframeGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&KeyframeGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(KeyframeGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1c19e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto KeyframeGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&KeyframeGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(KeyframeGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1c1b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto KeyframeGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&KeyframeGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(KeyframeGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c20b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LabelGameObject::init), this);
	using FunctionType = decltype(init())(*)(LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x1bbd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LabelGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&LabelGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(LabelGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1bc1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string>::func(&LabelGameObject::setupCustomSprites), this);
	using FunctionType = decltype(setupCustomSprites(p0))(*)(LabelGameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1bbd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&LabelGameObject::addMainSpriteToParent), this);
	using FunctionType = decltype(addMainSpriteToParent(p0))(*)(LabelGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1bcb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LabelGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x1bdab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LabelGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&LabelGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(LabelGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1bc8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LabelGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&LabelGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(LabelGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bcbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&LabelGameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(LabelGameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1bcb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LabelGameObject::updateTextKerning), this);
	using FunctionType = decltype(updateTextKerning(p0))(*)(LabelGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x1bc230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::getTextKerning() -> decltype(getTextKerning()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LabelGameObject::getTextKerning), this);
	using FunctionType = decltype(getTextKerning())(*)(LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void LeaderboardManagerDelegate::updateUserScoreFinished() {}

void LeaderboardManagerDelegate::updateUserScoreFailed() {}

void LeaderboardManagerDelegate::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) {}

void LeaderboardManagerDelegate::loadLeaderboardFailed(char const* p0) {}

auto LeaderboardsLayer::create(LeaderboardState state) -> decltype(create(state)) {
	using FunctionType = decltype(create(state))(*)(LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x51a6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(state);
}

auto LeaderboardsLayer::init(LeaderboardState p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LeaderboardsLayer*, LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x51a7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x51c490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LeaderboardsLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LeaderboardsLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x51c430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LeaderboardsLayer::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x51ba00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x51ba60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&LeaderboardsLayer::loadLeaderboardFinished), this);
	using FunctionType = decltype(loadLeaderboardFinished(p0, p1))(*)(LeaderboardsLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x51bb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LeaderboardsLayer::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&LeaderboardsLayer::loadLeaderboardFailed), this);
	using FunctionType = decltype(loadLeaderboardFailed(p0))(*)(LeaderboardsLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x51c1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelAreaInnerLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelAreaInnerLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x275da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelAreaInnerLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::onDoor(cocos2d::CCObject* sender) -> decltype(onDoor(sender)) {
	using FunctionType = decltype(onDoor(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaInnerLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelAreaInnerLayer*);
	static auto func = wrapFunction(base::get() + 0x277aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaInnerLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelAreaInnerLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelAreaInnerLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x2778c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelAreaLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::init), this);
	using FunctionType = decltype(init())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x273a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x275b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelAreaLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelAreaLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x275900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SetTextPopupDelegate::setTextPopupClosed(SetTextPopup* p0, gd::string p1) {}

auto ShareCommentDelegate::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	throw std::runtime_error("ShareCommentDelegate::shareCommentClosed not implemented");
}

LevelBrowserLayer::~LevelBrowserLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x493f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) LevelBrowserLayer(geode::CutoffConstructor, sizeof(LevelBrowserLayer));
	CCDestructor::lock(this) = true;
}

LevelBrowserLayer::LevelBrowserLayer() {}

auto LevelBrowserLayer::create(GJSearchObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x494190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelBrowserLayer::scene(GJSearchObject* search) -> decltype(scene(search)) {
	using FunctionType = decltype(scene(search))(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x494150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(search);
}

auto LevelBrowserLayer::init(GJSearchObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelBrowserLayer*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x494360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::loadPage(GJSearchObject* p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(LevelBrowserLayer*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x497710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::setupLevelBrowser(cocos2d::CCArray* p0) -> decltype(setupLevelBrowser(p0)) {
	using FunctionType = decltype(setupLevelBrowser(p0))(*)(LevelBrowserLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x4990a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x49b3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x49b590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelBrowserLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(LevelBrowserLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x49b680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void LevelBrowserLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LevelBrowserLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LevelBrowserLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto LevelBrowserLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x49b5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x49a740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelBrowserLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelBrowserLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x49a780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelBrowserLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&LevelBrowserLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(LevelBrowserLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x499c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelBrowserLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&LevelBrowserLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(LevelBrowserLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x499de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&LevelBrowserLayer::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(LevelBrowserLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x499ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&LevelBrowserLayer::onBack), this);
	using FunctionType = decltype(onBack(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x49a690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto LevelBrowserLayer::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, ShareCommentLayer*>::func(&LevelBrowserLayer::shareCommentClosed), this);
	using FunctionType = decltype(shareCommentClosed(p0, p1))(*)(LevelBrowserLayer*, gd::string, ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x49aa70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&LevelBrowserLayer::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(LevelBrowserLayer*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x49ab50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelBrowserLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelBrowserLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x49ada0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelBrowserLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelBrowserLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x49a560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::updateResultArray(cocos2d::CCArray* p0) -> decltype(updateResultArray(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*>::func(&LevelBrowserLayer::updateResultArray), this);
	using FunctionType = decltype(updateResultArray(p0))(*)(LevelBrowserLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x49b700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelBrowserLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&LevelBrowserLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(LevelBrowserLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x49b470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

LevelCell::LevelCell(char const* p0, float p1, float p2) : LevelCell(geode::CutoffConstructor, sizeof(LevelCell)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	LevelCell::~LevelCell();
	using FunctionType = void(*)(LevelCell*, char const*, float, float);
	static auto func = wrapFunction(base::get() + 0x24a640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelCell::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x24a540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelCell::loadCustomLevelCell() -> decltype(loadCustomLevelCell()) {
	using FunctionType = decltype(loadCustomLevelCell())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x24b030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelCell::loadFromLevel(GJGameLevel* p0) -> decltype(loadFromLevel(p0)) {
	using FunctionType = decltype(loadFromLevel(p0))(*)(LevelCell*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x23fd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelCell::loadLocalLevelCell() -> decltype(loadLocalLevelCell()) {
	using FunctionType = decltype(loadLocalLevelCell())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x24a710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelCell::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x24dca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::onToggle(cocos2d::CCObject* sender) -> decltype(onToggle(sender)) {
	using FunctionType = decltype(onToggle(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x24dc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x24de00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::updateCellMode(int p0) -> decltype(updateCellMode(p0)) {
	using FunctionType = decltype(updateCellMode(p0))(*)(LevelCell*, int);
	static auto func = wrapFunction(base::get() + 0x24a0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelCell::init), this);
	using FunctionType = decltype(init())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x24a6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelCell::draw), this);
	using FunctionType = decltype(draw())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x24de30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void LevelDeleteDelegate::levelDeleteFinished(int p0) {}

void LevelDeleteDelegate::levelDeleteFailed(int p0) {}

void LevelSettingsDelegate::levelSettingsUpdated() {}

LevelEditorLayer* LevelEditorLayer::get() {
        return GameManager::sharedState()->m_levelEditorLayer;
    }

auto LevelEditorLayer::create(GJGameLevel* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0xdeb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelEditorLayer::getNextFreeGroupID(cocos2d::CCArray* p0) -> decltype(getNextFreeGroupID(p0)) {
	using FunctionType = decltype(getNextFreeGroupID(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xef5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::init(GJGameLevel* p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelEditorLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0xdeba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

bool LevelEditorLayer::isLayerLocked(int layer) {
		if (layer < 10000 && m_layerLockingEnabled) {
			return m_lockedLayers.at(layer);
		}
		return false;
	}

auto LevelEditorLayer::onPlaytest() -> decltype(onPlaytest()) {
	using FunctionType = decltype(onPlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xf4c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::processLoadedMoveActions() -> decltype(processLoadedMoveActions()) {
	using FunctionType = decltype(processLoadedMoveActions())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xb7be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updateEditorMode() -> decltype(updateEditorMode()) {
	using FunctionType = decltype(updateEditorMode())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe2af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updateGameObjects() -> decltype(updateGameObjects()) {
	using FunctionType = decltype(updateGameObjects())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe1b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updatePreviewParticle(ParticleGameObject* p0) -> decltype(updatePreviewParticle(p0)) {
	using FunctionType = decltype(updatePreviewParticle(p0))(*)(LevelEditorLayer*, ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ad850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::draw), this);
	using FunctionType = decltype(draw())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xf90a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelEditorLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::postUpdate), this);
	using FunctionType = decltype(postUpdate(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0xf5f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::updateVisibility), this);
	using FunctionType = decltype(updateVisibility(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0xee540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::playerTookDamage(PlayerObject* p0) -> decltype(playerTookDamage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&LevelEditorLayer::playerTookDamage), this);
	using FunctionType = decltype(playerTookDamage(p0))(*)(LevelEditorLayer*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0xf5f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::updateColor(cocos2d::ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int>::func(&LevelEditorLayer::updateColor), this);
	using FunctionType = decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10))(*)(LevelEditorLayer*, cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0xf2a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
}

auto LevelEditorLayer::updateDebugDraw() -> decltype(updateDebugDraw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::updateDebugDraw), this);
	using FunctionType = decltype(updateDebugDraw())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xf7130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelEditorLayer::addToGroup(GameObject* p0, int p1, bool p2) -> decltype(addToGroup(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int, bool>::func(&LevelEditorLayer::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0, p1, p2))(*)(LevelEditorLayer*, GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0xf34c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelEditorLayer::removeFromGroup(GameObject* p0, int p1) -> decltype(removeFromGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int>::func(&LevelEditorLayer::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0, p1))(*)(LevelEditorLayer*, GameObject*, int);
	static auto func = wrapFunction(base::get() + 0xf3570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelEditorLayer::updateObjectSection(GameObject* p0) -> decltype(updateObjectSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&LevelEditorLayer::updateObjectSection), this);
	using FunctionType = decltype(updateObjectSection(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xf4830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::updateDisabledObjectsLastPos(cocos2d::CCArray* p0) -> decltype(updateDisabledObjectsLastPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*>::func(&LevelEditorLayer::updateDisabledObjectsLastPos), this);
	using FunctionType = decltype(updateDisabledObjectsLastPos(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xf4970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) -> decltype(timeForPos(p0, p1, p2, p3, p4)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint, int, int, bool, int>::func(&LevelEditorLayer::timeForPos), this);
	using FunctionType = decltype(timeForPos(p0, p1, p2, p3, p4))(*)(LevelEditorLayer*, cocos2d::CCPoint, int, int, bool, int);
	static auto func = wrapFunction(base::get() + 0xf2dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4);
}

auto LevelEditorLayer::posForTime(float p0) -> decltype(posForTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::posForTime), this);
	using FunctionType = decltype(posForTime(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0xf2e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::resetSPTriggered() -> decltype(resetSPTriggered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::resetSPTriggered), this);
	using FunctionType = decltype(resetSPTriggered())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xf2f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelEditorLayer::didRotateGameplay() -> decltype(didRotateGameplay()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::didRotateGameplay), this);
	using FunctionType = decltype(didRotateGameplay())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xf4640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelEditorLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&LevelEditorLayer::manualUpdateObjectColors), this);
	using FunctionType = decltype(manualUpdateObjectColors(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xef0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::claimCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, int p3, int p4, bool p5) -> decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool>::func(&LevelEditorLayer::claimCustomParticle), this);
	using FunctionType = decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5))(*)(LevelEditorLayer*, gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0xf6ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5);
}

auto LevelEditorLayer::unclaimCustomParticle(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(unclaimCustomParticle(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::CCParticleSystemQuad*>::func(&LevelEditorLayer::unclaimCustomParticle), this);
	using FunctionType = decltype(unclaimCustomParticle(p0, p1))(*)(LevelEditorLayer*, gd::string const&, cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0xf6fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelEditorLayer::activatedAudioTrigger(SFXTriggerGameObject* p0) -> decltype(activatedAudioTrigger(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXTriggerGameObject*>::func(&LevelEditorLayer::activatedAudioTrigger), this);
	using FunctionType = decltype(activatedAudioTrigger(p0))(*)(LevelEditorLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0xf5e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CheckpointGameObject*>::func(&LevelEditorLayer::checkpointActivated), this);
	using FunctionType = decltype(checkpointActivated(p0))(*)(LevelEditorLayer*, CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0xf5e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::addKeyframe(KeyframeGameObject* p0) -> decltype(addKeyframe(p0)) {
	auto self = addresser::thunkAdjust(Resolve<KeyframeGameObject*>::func(&LevelEditorLayer::addKeyframe), this);
	using FunctionType = decltype(addKeyframe(p0))(*)(LevelEditorLayer*, KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0xf6fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::levelSettingsUpdated() -> decltype(levelSettingsUpdated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::levelSettingsUpdated), this);
	using FunctionType = decltype(levelSettingsUpdated())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe3140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelFeatureLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelFeatureLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelFeatureLayer*);
	static auto func = wrapFunction(base::get() + 0x5101e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void LevelUpdateDelegate::levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) {}

void LevelUpdateDelegate::levelUpdateFailed(int p0) {}

void RateLevelDelegate::rateLevelClosed() {}

void NumberInputDelegate::numberInputClosed(NumberInputLayer* p0) {}

auto LevelInfoLayer::create(GJGameLevel* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2b8e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelInfoLayer::confirmClone(cocos2d::CCObject* p0) -> decltype(confirmClone(p0)) {
	using FunctionType = decltype(confirmClone(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bddb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmDelete(cocos2d::CCObject* p0) -> decltype(confirmDelete(p0)) {
	using FunctionType = decltype(confirmDelete(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bd590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmMoveToBottom(cocos2d::CCObject* p0) -> decltype(confirmMoveToBottom(p0)) {
	using FunctionType = decltype(confirmMoveToBottom(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmMoveToTop(cocos2d::CCObject* p0) -> decltype(confirmMoveToTop(p0)) {
	using FunctionType = decltype(confirmMoveToTop(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmOwnerDelete(cocos2d::CCObject* p0) -> decltype(confirmOwnerDelete(p0)) {
	using FunctionType = decltype(confirmOwnerDelete(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bdcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::downloadLevel() -> decltype(downloadLevel()) {
	using FunctionType = decltype(downloadLevel())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2bbdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::init(GJGameLevel* p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelInfoLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2b9040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelInfoLayer::loadLevelStep() -> decltype(loadLevelStep()) {
	using FunctionType = decltype(loadLevelStep())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2c0300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::onAddToList(cocos2d::CCObject* sender) -> decltype(onAddToList(sender)) {
	using FunctionType = decltype(onAddToList(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onFavorite(cocos2d::CCObject* sender) -> decltype(onFavorite(sender)) {
	using FunctionType = decltype(onFavorite(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onGarage(cocos2d::CCObject* sender) -> decltype(onGarage(sender)) {
	using FunctionType = decltype(onGarage(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bd800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelOptions(cocos2d::CCObject* sender) -> decltype(onLevelOptions(sender)) {
	using FunctionType = decltype(onLevelOptions(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelLeaderboard(cocos2d::CCObject* sender) -> decltype(onLevelLeaderboard(sender)) {
	using FunctionType = decltype(onLevelLeaderboard(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bd830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLike(cocos2d::CCObject* sender) -> decltype(onLike(sender)) {
	using FunctionType = decltype(onLike(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bd8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bb5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onPlayReplay(cocos2d::CCObject* sender) -> decltype(onPlayReplay(sender)) {
	using FunctionType = decltype(onPlayReplay(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c0430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c0a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateDemon(cocos2d::CCObject* sender) -> decltype(onRateDemon(sender)) {
	using FunctionType = decltype(onRateDemon(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bda80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateStars(cocos2d::CCObject* sender) -> decltype(onRateStars(sender)) {
	using FunctionType = decltype(onRateStars(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bd920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateStarsMod(cocos2d::CCObject* sender) -> decltype(onRateStarsMod(sender)) {
	using FunctionType = decltype(onRateStarsMod(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bdc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onSetFolder(cocos2d::CCObject* sender) -> decltype(onSetFolder(sender)) {
	using FunctionType = decltype(onSetFolder(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2be7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bd680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bb540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::playStep2() -> decltype(playStep2()) {
	using FunctionType = decltype(playStep2())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2c01b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::playStep3() -> decltype(playStep3()) {
	using FunctionType = decltype(playStep3())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2c0270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::playStep4() -> decltype(playStep4()) {
	using FunctionType = decltype(playStep4())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2c03b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::setupLevelInfo() -> decltype(setupLevelInfo()) {
	using FunctionType = decltype(setupLevelInfo())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2bbeb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::setupPlatformerStats() -> decltype(setupPlatformerStats()) {
	using FunctionType = decltype(setupPlatformerStats())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2bcb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::setupProgressBars() -> decltype(setupProgressBars()) {
	using FunctionType = decltype(setupProgressBars())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2bce50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::showSongWarning() -> decltype(showSongWarning()) {
	using FunctionType = decltype(showSongWarning())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2c00c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::showUpdateAlert(UpdateResponse p0) -> decltype(showUpdateAlert(p0)) {
	using FunctionType = decltype(showUpdateAlert(p0))(*)(LevelInfoLayer*, UpdateResponse);
	static auto func = wrapFunction(base::get() + 0x2bfc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::tryCloneLevel(cocos2d::CCObject* p0) -> decltype(tryCloneLevel(p0)) {
	using FunctionType = decltype(tryCloneLevel(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bdee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::updateLabelValues() -> decltype(updateLabelValues()) {
	using FunctionType = decltype(updateLabelValues())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2bebc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::updateSideButtons() -> decltype(updateSideButtons()) {
	using FunctionType = decltype(updateSideButtons())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2bdae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2c0ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelInfoLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelInfoLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelInfoLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x2c0ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::numberInputClosed(NumberInputLayer* p0) -> decltype(numberInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<NumberInputLayer*>::func(&LevelInfoLayer::numberInputClosed), this);
	using FunctionType = decltype(numberInputClosed(p0))(*)(LevelInfoLayer*, NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x2c05f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&LevelInfoLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(LevelInfoLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2be8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto LevelInfoLayer::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&LevelInfoLayer::levelDownloadFinished), this);
	using FunctionType = decltype(levelDownloadFinished(p0))(*)(LevelInfoLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x2bf730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDownloadFailed), this);
	using FunctionType = decltype(levelDownloadFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2bfac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) -> decltype(levelUpdateFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*, UpdateResponse>::func(&LevelInfoLayer::levelUpdateFinished), this);
	using FunctionType = decltype(levelUpdateFinished(p0, p1))(*)(LevelInfoLayer*, GJGameLevel*, UpdateResponse);
	static auto func = wrapFunction(base::get() + 0x2bfbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelInfoLayer::levelUpdateFailed(int p0) -> decltype(levelUpdateFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelUpdateFailed), this);
	using FunctionType = decltype(levelUpdateFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2bfda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDeleteFinished(int p0) -> decltype(levelDeleteFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDeleteFinished), this);
	using FunctionType = decltype(levelDeleteFinished(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2bfea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDeleteFailed(int p0) -> decltype(levelDeleteFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDeleteFailed), this);
	using FunctionType = decltype(levelDeleteFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2bffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::rateLevelClosed() -> decltype(rateLevelClosed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelInfoLayer::rateLevelClosed), this);
	using FunctionType = decltype(rateLevelClosed())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2c0bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelInfoLayer::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&LevelInfoLayer::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(LevelInfoLayer*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x2c0be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelInfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelInfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelInfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2c0cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelInfoLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelInfoLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelInfoLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x2be9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelLeaderboard::init(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(LevelLeaderboard*, GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x3de080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelLeaderboard::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3dfeb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3dfe40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::show), this);
	using FunctionType = decltype(show())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3e03d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&LevelLeaderboard::loadLeaderboardFinished), this);
	using FunctionType = decltype(loadLeaderboardFinished(p0, p1))(*)(LevelLeaderboard*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x3e00d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelLeaderboard::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&LevelLeaderboard::loadLeaderboardFailed), this);
	using FunctionType = decltype(loadLeaderboardFailed(p0))(*)(LevelLeaderboard*, char const*);
	static auto func = wrapFunction(base::get() + 0x3e0210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelLeaderboard::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelLeaderboard::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelLeaderboard*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3dfa90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelLeaderboard::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3dfc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3dfcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListCell::loadFromList(GJLevelList* p0) -> decltype(loadFromList(p0)) {
	using FunctionType = decltype(loadFromList(p0))(*)(LevelListCell*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x240be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListCell::init), this);
	using FunctionType = decltype(init())(*)(LevelListCell*);
	static auto func = wrapFunction(base::get() + 0x2550a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListCell::draw), this);
	using FunctionType = decltype(draw())(*)(LevelListCell*);
	static auto func = wrapFunction(base::get() + 0x2551e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void LevelListDeleteDelegate::levelListDeleteFinished(int p0) {}

void LevelListDeleteDelegate::levelListDeleteFailed(int p0) {}

void SelectListIconDelegate::iconSelectClosed(SelectListIconLayer* p0) {}

LevelListLayer::LevelListLayer() {}

auto LevelListLayer::create(GJLevelList* list) -> decltype(create(list)) {
	using FunctionType = decltype(create(list))(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x35c7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(list);
}

auto LevelListLayer::init(GJLevelList* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelListLayer*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x35c820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListLayer::onSelectIcon(cocos2d::CCObject* sender) -> decltype(onSelectIcon(sender)) {
	using FunctionType = decltype(onSelectIcon(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35ee60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35eeb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::scene(GJLevelList* p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x35c730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelListLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x35ff50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x35ff80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&LevelListLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(LevelListLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x360390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelListLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&LevelListLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(LevelListLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x360630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&LevelListLayer::onBack), this);
	using FunctionType = decltype(onBack(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x360b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto LevelListLayer::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, ShareCommentLayer*>::func(&LevelListLayer::shareCommentClosed), this);
	using FunctionType = decltype(shareCommentClosed(p0, p1))(*)(LevelListLayer*, gd::string, ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x361580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelListLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelListLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3610c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelListLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelListLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x360a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::updateResultArray(cocos2d::CCArray* p0) -> decltype(updateResultArray(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*>::func(&LevelListLayer::updateResultArray), this);
	using FunctionType = decltype(updateResultArray(p0))(*)(LevelListLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x360b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&LevelListLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(LevelListLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x360660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto LevelListLayer::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&LevelListLayer::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(LevelListLayer*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x3616c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelListLayer::iconSelectClosed(SelectListIconLayer* p0) -> decltype(iconSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectListIconLayer*>::func(&LevelListLayer::iconSelectClosed), this);
	using FunctionType = decltype(iconSelectClosed(p0))(*)(LevelListLayer*, SelectListIconLayer*);
	static auto func = wrapFunction(base::get() + 0x361900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::levelListDeleteFinished(int p0) -> decltype(levelListDeleteFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelListLayer::levelListDeleteFinished), this);
	using FunctionType = decltype(levelListDeleteFinished(p0))(*)(LevelListLayer*, int);
	static auto func = wrapFunction(base::get() + 0x361a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::levelListDeleteFailed(int p0) -> decltype(levelListDeleteFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelListLayer::levelListDeleteFailed), this);
	using FunctionType = decltype(levelListDeleteFailed(p0))(*)(LevelListLayer*, int);
	static auto func = wrapFunction(base::get() + 0x361b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x361ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x361c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x361fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&LevelOptionsLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(LevelOptionsLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x26dcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelOptionsLayer::getValue), this);
	using FunctionType = decltype(getValue(p0))(*)(LevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x26dce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(LevelOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x26d570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(LevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x26dd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelOptionsLayer2::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelOptionsLayer2::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(LevelOptionsLayer2*);
	static auto func = wrapFunction(base::get() + 0x26dfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

LevelPage::LevelPage() {}

auto LevelPage::create(GJGameLevel* level) -> decltype(create(level)) {
	using FunctionType = decltype(create(level))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x43c580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level);
}

auto LevelPage::addSecretCoin() -> decltype(addSecretCoin()) {
	using FunctionType = decltype(addSecretCoin())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x43dde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::addSecretDoor() -> decltype(addSecretDoor()) {
	using FunctionType = decltype(addSecretDoor())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x440360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x43f130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelPage::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x43ea10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onMoreGames(cocos2d::CCObject* sender) -> decltype(onMoreGames(sender)) {
	using FunctionType = decltype(onMoreGames(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4404d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x43e730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onSecretDoor(cocos2d::CCObject* sender) -> decltype(onSecretDoor(sender)) {
	using FunctionType = decltype(onSecretDoor(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x440980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onTheTower(cocos2d::CCObject* sender) -> decltype(onTheTower(sender)) {
	using FunctionType = decltype(onTheTower(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x43fdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::playCoinEffect() -> decltype(playCoinEffect()) {
	using FunctionType = decltype(playCoinEffect())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x440530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::playStep2() -> decltype(playStep2()) {
	using FunctionType = decltype(playStep2())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x4412a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::playStep3() -> decltype(playStep3()) {
	using FunctionType = decltype(playStep3())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x441360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::updateDynamicPage(GJGameLevel* p0) -> decltype(updateDynamicPage(p0)) {
	using FunctionType = decltype(updateDynamicPage(p0))(*)(LevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x43c820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelPage::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelPage::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(LevelPage*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x441430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void LevelPage::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LevelPage::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto LevelPage::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelPage::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(LevelPage*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x441590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x4415d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelPage::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelPage::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelPage*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x441180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x634710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSearchLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x634960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSearchLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x6398b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSearchLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSearchLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(LevelSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x638e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSearchLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(LevelSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x638ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSearchLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(LevelSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x638fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelSearchLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelSearchLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x638d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSearchLayer::demonFilterSelectClosed(int p0) -> decltype(demonFilterSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelSearchLayer::demonFilterSelectClosed), this);
	using FunctionType = decltype(demonFilterSelectClosed(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x638880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

LevelSelectLayer::~LevelSelectLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(LevelSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x4ba220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) LevelSelectLayer(geode::CutoffConstructor, sizeof(LevelSelectLayer));
	CCDestructor::lock(this) = true;
}

auto LevelSelectLayer::init(int page) -> decltype(init(page)) {
	using FunctionType = decltype(init(page))(*)(LevelSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x43b920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, page);
}

auto LevelSelectLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x43b710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x43e490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSelectLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelSelectLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelSelectLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x43e530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSelectLayer::updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) -> decltype(updatePageWithObject(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*, cocos2d::CCObject*>::func(&LevelSelectLayer::updatePageWithObject), this);
	using FunctionType = decltype(updatePageWithObject(p0, p1))(*)(LevelSelectLayer*, cocos2d::CCObject*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x43c7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSelectLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&LevelSelectLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(LevelSelectLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x43e000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SelectArtDelegate::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	throw std::runtime_error("SelectArtDelegate::selectArtClosed not implemented");
}

auto SelectSettingDelegate::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	throw std::runtime_error("SelectSettingDelegate::selectSettingClosed not implemented");
}

auto LevelSettingsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x26ae10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x26b740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSettingsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelSettingsLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelSettingsLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x26b2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSettingsLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&LevelSettingsLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(LevelSettingsLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x26b1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&LevelSettingsLayer::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(LevelSettingsLayer*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x26b4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSettingLayer*>::func(&LevelSettingsLayer::selectSettingClosed), this);
	using FunctionType = decltype(selectSettingClosed(p0))(*)(LevelSettingsLayer*, SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x26ac40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSettingsLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(LevelSettingsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x26ae60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSettingsLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(LevelSettingsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x26aea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsObject::objectFromDict(cocos2d::CCDictionary* p0) -> decltype(objectFromDict(p0)) {
	using FunctionType = decltype(objectFromDict(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0xfb9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSettingsObject::objectFromString(gd::string const& str) -> decltype(objectFromString(str)) {
	using FunctionType = decltype(objectFromString(str))(*)(gd::string const&);
	static auto func = wrapFunction(base::get() + 0xe35f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(str);
}

auto LevelSettingsObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsObject::init), this);
	using FunctionType = decltype(init())(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0xfb840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void LevelUploadDelegate::levelUploadFinished(GJGameLevel* p0) {}

void LevelUploadDelegate::levelUploadFailed(GJGameLevel* p0) {}

auto LikeItemLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LikeItemLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LikeItemLayer*);
	static auto func = wrapFunction(base::get() + 0x604020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ListCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ListCell::init), this);
	using FunctionType = decltype(init())(*)(ListCell*);
	static auto func = wrapFunction(base::get() + 0x30c690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ListCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ListCell::draw), this);
	using FunctionType = decltype(draw())(*)(ListCell*);
	static auto func = wrapFunction(base::get() + 0x30c720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ListUploadDelegate::listUploadFinished(GJLevelList* p0) -> decltype(listUploadFinished(p0)) {
	throw std::runtime_error("ListUploadDelegate::listUploadFinished not implemented");
}

auto ListUploadDelegate::listUploadFailed(GJLevelList* p0, int p1) -> decltype(listUploadFailed(p0, p1)) {
	throw std::runtime_error("ListUploadDelegate::listUploadFailed not implemented");
}

auto LoadingCircle::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x4c8dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LoadingCircle::fadeAndRemove() -> decltype(fadeAndRemove()) {
	using FunctionType = decltype(fadeAndRemove())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x4c90f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingCircle::show() -> decltype(show()) {
	using FunctionType = decltype(show())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x4c9000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void LoadingCircle::setFade(bool fade) {
		m_fade = fade;
	}

auto LoadingCircle::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::init), this);
	using FunctionType = decltype(init())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x4c8f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingCircle::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::draw), this);
	using FunctionType = decltype(draw())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x4c9180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingCircle::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LoadingCircle::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(LoadingCircle*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4c9400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void LoadingCircle::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LoadingCircle::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LoadingCircle::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto LoadingCircle::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x4c91a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingCircleSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircleSprite::init), this);
	using FunctionType = decltype(init())(*)(LoadingCircleSprite*);
	static auto func = wrapFunction(base::get() + 0x4c92e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LoadingLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3a5890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LoadingLayer::loadAssets() -> decltype(loadAssets()) {
	using FunctionType = decltype(loadAssets())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x3a60d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingLayer::loadingFinished() -> decltype(loadingFinished()) {
	using FunctionType = decltype(loadingFinished())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x3a6870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LocalLevelManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x601110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LocalLevelManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LocalLevelManager::init), this);
	using FunctionType = decltype(init())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x6012b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LocalLevelManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&LocalLevelManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(LocalLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x6028e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LocalLevelManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&LocalLevelManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(LocalLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x602940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LocalLevelManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LocalLevelManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x602850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapPackCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapPackCell::init), this);
	using FunctionType = decltype(init())(*)(MapPackCell*);
	static auto func = wrapFunction(base::get() + 0x24e2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapPackCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapPackCell::draw), this);
	using FunctionType = decltype(draw())(*)(MapPackCell*);
	static auto func = wrapFunction(base::get() + 0x24e7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MapSelectLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(MapSelectLayer*, float);
	static auto func = wrapFunction(base::get() + 0x264ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MapSelectLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapSelectLayer::init), this);
	using FunctionType = decltype(init())(*)(MapSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x263ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapSelectLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(MapSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x2651b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MapSelectLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(MapSelectLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2658c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MapSelectLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MapSelectLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(MapSelectLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2659d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MapSelectLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MapSelectLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(MapSelectLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x265bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MapSelectLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MapSelectLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(MapSelectLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x265cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MapSelectLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapSelectLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MapSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x265d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MapSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x2650d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&MapSelectLayer::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(MapSelectLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x264cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MenuGameLayer::resetPlayer() -> decltype(resetPlayer()) {
	using FunctionType = decltype(resetPlayer())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x504f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuGameLayer::tryJump(float p0) -> decltype(tryJump(p0)) {
	using FunctionType = decltype(tryJump(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x504ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MenuGameLayer::updateColor(float p0) -> decltype(updateColor(p0)) {
	using FunctionType = decltype(updateColor(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x504d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MenuGameLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MenuGameLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x505750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MenuGameLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuGameLayer::init), this);
	using FunctionType = decltype(init())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x5045b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuGameLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MenuGameLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(MenuGameLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x505cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void MenuGameLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void MenuGameLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto MenuGameLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MenuGameLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(MenuGameLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x505e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MenuGameLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuGameLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x505e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::scene(bool p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x392b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto MenuLayer::onQuit(cocos2d::CCObject* sender) -> decltype(onQuit(sender)) {
	using FunctionType = decltype(onQuit(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x394500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::init), this);
	using FunctionType = decltype(init())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x392d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x394cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&MenuLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(MenuLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x394f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MenuLayer::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::googlePlaySignedIn), this);
	using FunctionType = decltype(googlePlaySignedIn())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x394a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MenuLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MenuLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x394d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void MessageListDelegate::loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) {}

void MessageListDelegate::loadMessagesFailed(char const* p0, GJErrorCode p1) {}

void MessageListDelegate::forceReloadMessages(bool p0) {}

void MessageListDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto MessagesProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(MessagesProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x22a2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22a220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22a200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MessagesProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MessagesProfilePage*);
	static auto func = wrapFunction(base::get() + 0x22ad40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MessagesProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MessagesProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MessagesProfilePage*);
	static auto func = wrapFunction(base::get() + 0x22ad10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MessagesProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MessagesProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MessagesProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x22a8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&MessagesProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(MessagesProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x22a960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MessagesProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MessagesProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(MessagesProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x22a9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MessagesProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(MessagesProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x22ab70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadMessagesFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&MessagesProfilePage::loadMessagesFinished), this);
	using FunctionType = decltype(loadMessagesFinished(p0, p1))(*)(MessagesProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x22b010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::loadMessagesFailed(char const* p0, GJErrorCode p1) -> decltype(loadMessagesFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, GJErrorCode>::func(&MessagesProfilePage::loadMessagesFailed), this);
	using FunctionType = decltype(loadMessagesFailed(p0, p1))(*)(MessagesProfilePage*, char const*, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x22b140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::forceReloadMessages(bool p0) -> decltype(forceReloadMessages(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&MessagesProfilePage::forceReloadMessages), this);
	using FunctionType = decltype(forceReloadMessages(p0))(*)(MessagesProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x22b250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MessagesProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&MessagesProfilePage::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(MessagesProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x22b290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MoreOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7a79a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7aac00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&MoreOptionsLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(MoreOptionsLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x7aac30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MoreOptionsLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MoreOptionsLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(MoreOptionsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x7aacf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MoreOptionsLayer::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::googlePlaySignedIn), this);
	using FunctionType = decltype(googlePlaySignedIn())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7aada0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJDropDownLayer*>::func(&MoreOptionsLayer::dropDownLayerWillClose), this);
	using FunctionType = decltype(dropDownLayerWillClose(p0))(*)(MoreOptionsLayer*, GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x7aaa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MoreSearchLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x638980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MoreSearchLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreSearchLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x639f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreSearchLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreSearchLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x63c100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreSearchLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&MoreSearchLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(MoreSearchLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x63bf90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MoreSearchLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MoreSearchLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(MoreSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x63c050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MoreVideoOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreVideoOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7ad0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreVideoOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreVideoOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7af160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MPLobbyLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MPLobbyLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MPLobbyLayer*);
	static auto func = wrapFunction(base::get() + 0x49d3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MPLobbyLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&MPLobbyLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(MPLobbyLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x49dc10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::joinLobbyFinished(int p0) -> decltype(joinLobbyFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&MPLobbyLayer::joinLobbyFinished), this);
	using FunctionType = decltype(joinLobbyFinished(p0))(*)(MPLobbyLayer*, int);
	static auto func = wrapFunction(base::get() + 0x49d560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::joinLobbyFailed(int p0, GJMPErrorCode p1) -> decltype(joinLobbyFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJMPErrorCode>::func(&MPLobbyLayer::joinLobbyFailed), this);
	using FunctionType = decltype(joinLobbyFailed(p0, p1))(*)(MPLobbyLayer*, int, GJMPErrorCode);
	static auto func = wrapFunction(base::get() + 0x49da40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MPLobbyLayer::updateComments() -> decltype(updateComments()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MPLobbyLayer::updateComments), this);
	using FunctionType = decltype(updateComments())(*)(MPLobbyLayer*);
	static auto func = wrapFunction(base::get() + 0x49d910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MPLobbyLayer::didUploadMPComment(int p0) -> decltype(didUploadMPComment(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&MPLobbyLayer::didUploadMPComment), this);
	using FunctionType = decltype(didUploadMPComment(p0))(*)(MPLobbyLayer*, int);
	static auto func = wrapFunction(base::get() + 0x49da20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MPLobbyLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(MPLobbyLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x49db40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MPLobbyLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(MPLobbyLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x49db60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MPLobbyLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(MPLobbyLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x49db80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&MPLobbyLayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(MPLobbyLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x49dc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MPLobbyLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MPLobbyLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x49dba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MPLobbyLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MPLobbyLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(MPLobbyLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x49dc70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MPLobbyLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MPLobbyLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(MPLobbyLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x49de90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MPLobbyLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&MPLobbyLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(MPLobbyLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x49e030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MultilineBitmapFont::createWithFont(char const* p0, gd::string p1, float p2, float p3, cocos2d::CCPoint p4, int p5, bool p6) -> decltype(createWithFont(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(createWithFont(p0, p1, p2, p3, p4, p5, p6))(*)(char const*, gd::string, float, float, cocos2d::CCPoint, int, bool);
	static auto func = wrapFunction(base::get() + 0x490240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto MultilineBitmapFont::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&MultilineBitmapFont::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(MultilineBitmapFont*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x4920d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MultiplayerLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MultiplayerLayer::init), this);
	using FunctionType = decltype(init())(*)(MultiplayerLayer*);
	static auto func = wrapFunction(base::get() + 0x39de70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MultiplayerLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MultiplayerLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MultiplayerLayer*);
	static auto func = wrapFunction(base::get() + 0x39df60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MusicBrowser::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MusicBrowser::update), this);
	using FunctionType = decltype(update(p0))(*)(MusicBrowser*, float);
	static auto func = wrapFunction(base::get() + 0x61a210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicBrowser::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x61b300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MusicBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicBrowser::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x61b1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MusicBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&MusicBrowser::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(MusicBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x61ab70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&MusicBrowser::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(MusicBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x61ac70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&MusicBrowser::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(MusicBrowser*, Slider*);
	static auto func = wrapFunction(base::get() + 0x61a390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&MusicBrowser::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(MusicBrowser*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x61af20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MusicBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&MusicBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(MusicBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x61aea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto MusicBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicBrowser::getSelectedCellIdx), this);
	using FunctionType = decltype(getSelectedCellIdx())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x61af00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MusicBrowser::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MusicBrowser::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MusicBrowser*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x61b130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void PlatformDownloadDelegate::downloadFinished(char const* p0) {}

void PlatformDownloadDelegate::downloadFailed(char const* p0) {}

auto MusicDownloadManager::addDLToActive(char const* tag, cocos2d::CCObject* obj) -> decltype(addDLToActive(tag, obj)) {
	using FunctionType = decltype(addDLToActive(tag, obj))(*)(MusicDownloadManager*, char const*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x597180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, tag, obj);
}

auto MusicDownloadManager::downloadCustomSong(int p0) -> decltype(downloadCustomSong(p0)) {
	using FunctionType = decltype(downloadCustomSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x596ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::downloadSong(int p0) -> decltype(downloadSong(p0)) {
	using FunctionType = decltype(downloadSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x5965c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::getSongInfoObject(int p0) -> decltype(getSongInfoObject(p0)) {
	using FunctionType = decltype(getSongInfoObject(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x592c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicDownloadManager::init), this);
	using FunctionType = decltype(init())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x592600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsObjectDelegate::stateChanged(OptionsObject* p0) -> decltype(stateChanged(p0)) {
	throw std::runtime_error("OptionsObjectDelegate::stateChanged not implemented");
}

auto MusicSearchResult::updateObjects(AudioSortType p0) -> decltype(updateObjects(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AudioSortType>::func(&MusicSearchResult::updateObjects), this);
	using FunctionType = decltype(updateObjects(p0))(*)(MusicSearchResult*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x5a2410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicSearchResult::stateChanged(OptionsObject* p0) -> decltype(stateChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<OptionsObject*>::func(&MusicSearchResult::stateChanged), this);
	using FunctionType = decltype(stateChanged(p0))(*)(MusicSearchResult*, OptionsObject*);
	static auto func = wrapFunction(base::get() + 0x5a23b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto NCSInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NCSInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(NCSInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x213260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NewgroundsInfoLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NewgroundsInfoLayer::init), this);
	using FunctionType = decltype(init())(*)(NewgroundsInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x211f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NewgroundsInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NewgroundsInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(NewgroundsInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x212a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NewgroundsInfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&NewgroundsInfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(NewgroundsInfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2129f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto NumberInputLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::init), this);
	using FunctionType = decltype(init())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x49bbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NumberInputLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x49c650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NumberInputLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x49c5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectControlGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectControlGameObject::init), this);
	using FunctionType = decltype(init())(*)(ObjectControlGameObject*);
	static auto func = wrapFunction(base::get() + 0x1e81c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&ObjectControlGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ObjectControlGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1e8710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ObjectControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ObjectControlGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ObjectControlGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1e8210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ObjectDecoder::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectDecoder::init), this);
	using FunctionType = decltype(init())(*)(ObjectDecoder*);
	static auto func = wrapFunction(base::get() + 0x79ded0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectManager::init), this);
	using FunctionType = decltype(init())(*)(ObjectManager*);
	static auto func = wrapFunction(base::get() + 0x7a1760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

const char* ObjectToolbox::intKeyToFrame(int key) {
		return m_allKeys[key].c_str();
	}

auto ObjectToolbox::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectToolbox::init), this);
	using FunctionType = decltype(init())(*)(ObjectToolbox*);
	static auto func = wrapFunction(base::get() + 0x6777a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void OnlineListDelegate::loadListFinished(cocos2d::CCArray* p0, char const* p1) {}

void OnlineListDelegate::loadListFailed(char const* p0) {}

void OnlineListDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto OptionsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(OptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7a6300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(OptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7a7790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void OptionsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto OptionsScrollLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsScrollLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(OptionsScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x61bc10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsScrollLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsScrollLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(OptionsScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x61bae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsScrollLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&OptionsScrollLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(OptionsScrollLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x61bc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto ParentalOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParentalOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(ParentalOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7af590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParentalOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParentalOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ParentalOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7b0d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::init), this);
	using FunctionType = decltype(init())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ac8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1ad990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1ada00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1ada70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1ad8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1ad910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1ad950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&ParticleGameObject::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(ParticleGameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1adbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1acbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&ParticleGameObject::addMainSpriteToParent), this);
	using FunctionType = decltype(addMainSpriteToParent(p0))(*)(ParticleGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1acc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1addc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&ParticleGameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(ParticleGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1add80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&ParticleGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ParticleGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ac8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ParticleGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ParticleGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ParticleGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1adfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::claimParticle() -> decltype(claimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::claimParticle), this);
	using FunctionType = decltype(claimParticle())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1acd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::unclaimParticle() -> decltype(unclaimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::unclaimParticle), this);
	using FunctionType = decltype(unclaimParticle())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ad310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::particleWasActivated() -> decltype(particleWasActivated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::particleWasActivated), this);
	using FunctionType = decltype(particleWasActivated())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ad390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&ParticleGameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(ParticleGameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1adae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::blendModeChanged() -> decltype(blendModeChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::blendModeChanged), this);
	using FunctionType = decltype(blendModeChanged())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1acc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::updateParticleColor(cocos2d::ccColor3B const& p0) -> decltype(updateParticleColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&ParticleGameObject::updateParticleColor), this);
	using FunctionType = decltype(updateParticleColor(p0))(*)(ParticleGameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1ed4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateParticleOpacity(unsigned char p0) -> decltype(updateParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&ParticleGameObject::updateParticleOpacity), this);
	using FunctionType = decltype(updateParticleOpacity(p0))(*)(ParticleGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1ed4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateMainParticleOpacity(unsigned char p0) -> decltype(updateMainParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&ParticleGameObject::updateMainParticleOpacity), this);
	using FunctionType = decltype(updateMainParticleOpacity(p0))(*)(ParticleGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1adcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateSecondaryParticleOpacity(unsigned char p0) -> decltype(updateSecondaryParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&ParticleGameObject::updateSecondaryParticleOpacity), this);
	using FunctionType = decltype(updateSecondaryParticleOpacity(p0))(*)(ParticleGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1add20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&ParticleGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(ParticleGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x1ade20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ParticleGameObject::updateAnimateOnTrigger(bool p0) -> decltype(updateAnimateOnTrigger(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&ParticleGameObject::updateAnimateOnTrigger), this);
	using FunctionType = decltype(updateAnimateOnTrigger(p0))(*)(ParticleGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1adf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticlePreviewLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticlePreviewLayer::draw), this);
	using FunctionType = decltype(draw())(*)(ParticlePreviewLayer*);
	static auto func = wrapFunction(base::get() + 0x481920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticlePreviewLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticlePreviewLayer::visit), this);
	using FunctionType = decltype(visit())(*)(ParticlePreviewLayer*);
	static auto func = wrapFunction(base::get() + 0x4817a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PauseLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x3d9bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto PauseLayer::goEdit() -> decltype(goEdit()) {
	using FunctionType = decltype(goEdit())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x3db8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PauseLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(PauseLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5208d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PauseLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3db1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onNormalMode(cocos2d::CCObject* sender) -> decltype(onNormalMode(sender)) {
	using FunctionType = decltype(onNormalMode(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3db360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onPracticeMode(cocos2d::CCObject* sender) -> decltype(onPracticeMode(sender)) {
	using FunctionType = decltype(onPracticeMode(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3db300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onQuit(cocos2d::CCObject* sender) -> decltype(onQuit(sender)) {
	using FunctionType = decltype(onQuit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3db980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onRestart(cocos2d::CCObject* sender) -> decltype(onRestart(sender)) {
	using FunctionType = decltype(onRestart(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3db4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onRestartFull(cocos2d::CCObject* sender) -> decltype(onRestartFull(sender)) {
	using FunctionType = decltype(onRestartFull(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3db2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onResume(cocos2d::CCObject* sender) -> decltype(onResume(sender)) {
	using FunctionType = decltype(onResume(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3db280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::tryQuit(cocos2d::CCObject* sender) -> decltype(tryQuit(sender)) {
	using FunctionType = decltype(tryQuit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3db3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PauseLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x3dbba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PauseLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&PauseLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(PauseLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3dbaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PauseLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PauseLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x3d9cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void PauseLayer::keyUp(cocos2d::enumKeyCodes p0) {}

auto PlatformToolbox::hideCursor() -> decltype(hideCursor()) {
	using FunctionType = decltype(hideCursor())(*)();
	static auto func = wrapFunction(base::get() + 0x4cdbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlatformToolbox::isControllerConnected() -> decltype(isControllerConnected()) {
	using FunctionType = decltype(isControllerConnected())(*)();
	static auto func = wrapFunction(base::get() + 0x4cea70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlatformToolbox::showCursor() -> decltype(showCursor()) {
	using FunctionType = decltype(showCursor())(*)();
	static auto func = wrapFunction(base::get() + 0x4cdbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlayerCheckpoint::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerCheckpoint::init), this);
	using FunctionType = decltype(init())(*)(PlayerCheckpoint*);
	static auto func = wrapFunction(base::get() + 0xbfbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerControlGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerControlGameObject::init), this);
	using FunctionType = decltype(init())(*)(PlayerControlGameObject*);
	static auto func = wrapFunction(base::get() + 0x1e6ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&PlayerControlGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(PlayerControlGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1e7f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayerControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&PlayerControlGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(PlayerControlGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1e7040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerFireBoostSprite::animateFireIn() -> decltype(animateFireIn()) {
	using FunctionType = decltype(animateFireIn())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x4211c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerFireBoostSprite::animateFireOut() -> decltype(animateFireOut()) {
	using FunctionType = decltype(animateFireOut())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x421230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerFireBoostSprite::loopFireAnimation() -> decltype(loopFireAnimation()) {
	using FunctionType = decltype(loopFireAnimation())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x420f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerFireBoostSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerFireBoostSprite::init), this);
	using FunctionType = decltype(init())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x4262a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::create(int p0, int p1, GJBaseGameLayer* p2, cocos2d::CCLayer* p3, bool p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(int, int, GJBaseGameLayer*, cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x403500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto PlayerObject::addToTouchedRings(RingObject* p0) -> decltype(addToTouchedRings(p0)) {
	using FunctionType = decltype(addToTouchedRings(p0))(*)(PlayerObject*, RingObject*);
	static auto func = wrapFunction(base::get() + 0x41ecf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::animatePlatformerJump(float p0) -> decltype(animatePlatformerJump(p0)) {
	using FunctionType = decltype(animatePlatformerJump(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x40cdb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::bumpPlayer(float p0, int p1, bool p2, GameObject* p3) -> decltype(bumpPlayer(p0, p1, p2, p3)) {
	using FunctionType = decltype(bumpPlayer(p0, p1, p2, p3))(*)(PlayerObject*, float, int, bool, GameObject*);
	static auto func = wrapFunction(base::get() + 0x423f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::collidedWithObject(float p0, GameObject* p1, cocos2d::CCRect p2, bool p3) -> decltype(collidedWithObject(p0, p1, p2, p3)) {
	using FunctionType = decltype(collidedWithObject(p0, p1, p2, p3))(*)(PlayerObject*, float, GameObject*, cocos2d::CCRect, bool);
	static auto func = wrapFunction(base::get() + 0x40fa20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::collidedWithObject(float p0, GameObject* p1) -> decltype(collidedWithObject(p0, p1)) {
	using FunctionType = decltype(collidedWithObject(p0, p1))(*)(PlayerObject*, float, GameObject*);
	static auto func = wrapFunction(base::get() + 0x416340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::collidedWithObjectInternal(float p0, GameObject* p1, cocos2d::CCRect p2, bool p3) -> decltype(collidedWithObjectInternal(p0, p1, p2, p3)) {
	using FunctionType = decltype(collidedWithObjectInternal(p0, p1, p2, p3))(*)(PlayerObject*, float, GameObject*, cocos2d::CCRect, bool);
	static auto func = wrapFunction(base::get() + 0x411b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::copyAttributes(PlayerObject* p0) -> decltype(copyAttributes(p0)) {
	using FunctionType = decltype(copyAttributes(p0))(*)(PlayerObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x4249f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::deactivateParticle() -> decltype(deactivateParticle()) {
	using FunctionType = decltype(deactivateParticle())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x40a870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void PlayerObject::disableCustomGlowColor() {
		m_hasCustomGlowColor = false;
	}

auto PlayerObject::disableSwingFire() -> decltype(disableSwingFire()) {
	using FunctionType = decltype(disableSwingFire())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x41d060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::doReversePlayer(bool p0) -> decltype(doReversePlayer(p0)) {
	using FunctionType = decltype(doReversePlayer(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x40b5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::enableCustomGlowColor(cocos2d::_ccColor3B const& color) {
		m_hasCustomGlowColor = true;
		m_glowColor = color;
	}

auto PlayerObject::fadeOutStreak2(float p0) -> decltype(fadeOutStreak2(p0)) {
	using FunctionType = decltype(fadeOutStreak2(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x41cfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::flipGravity(bool p0, bool p1) -> decltype(flipGravity(p0, p1)) {
	using FunctionType = decltype(flipGravity(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x40c9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::getActiveMode() -> decltype(getActiveMode()) {
	using FunctionType = decltype(getActiveMode())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x41f680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::incrementJumps() -> decltype(incrementJumps()) {
	using FunctionType = decltype(incrementJumps())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x40c980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::init(int p0, int p1, GJBaseGameLayer* p2, cocos2d::CCLayer* p3, bool p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(PlayerObject*, int, int, GJBaseGameLayer*, cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x403590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto PlayerObject::isFlying() -> decltype(isFlying()) {
	using FunctionType = decltype(isFlying())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x40a810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::loadFromCheckpoint(PlayerCheckpoint* p0) -> decltype(loadFromCheckpoint(p0)) {
	using FunctionType = decltype(loadFromCheckpoint(p0))(*)(PlayerObject*, PlayerCheckpoint*);
	static auto func = wrapFunction(base::get() + 0x425520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::lockPlayer() -> decltype(lockPlayer()) {
	using FunctionType = decltype(lockPlayer())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x423ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playCompleteEffect(bool p0, bool p1) -> decltype(playCompleteEffect(p0, p1)) {
	using FunctionType = decltype(playCompleteEffect(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x20eb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::playDeathEffect() -> decltype(playDeathEffect()) {
	using FunctionType = decltype(playDeathEffect())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x206990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playerDestroyed(bool p0) -> decltype(playerDestroyed(p0)) {
	using FunctionType = decltype(playerDestroyed(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x41cdd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::playingEndEffect() -> decltype(playingEndEffect()) {
	using FunctionType = decltype(playingEndEffect())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x423eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playSpiderDashEffect(cocos2d::CCPoint from, cocos2d::CCPoint to) -> decltype(playSpiderDashEffect(from, to)) {
	using FunctionType = decltype(playSpiderDashEffect(from, to))(*)(PlayerObject*, cocos2d::CCPoint, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x417a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, from, to);
}

auto PlayerObject::propellPlayer(float p0, bool p1, int p2) -> decltype(propellPlayer(p0, p1, p2)) {
	using FunctionType = decltype(propellPlayer(p0, p1, p2))(*)(PlayerObject*, float, bool, int);
	static auto func = wrapFunction(base::get() + 0x424240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto PlayerObject::pushButton(PlayerButton p0) -> decltype(pushButton(p0)) {
	using FunctionType = decltype(pushButton(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x41d330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::releaseAllButtons() -> decltype(releaseAllButtons()) {
	using FunctionType = decltype(releaseAllButtons())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x423a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::releaseButton(PlayerButton p0) -> decltype(releaseButton(p0)) {
	using FunctionType = decltype(releaseButton(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x41e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::resetPlayerIcon() -> decltype(resetPlayerIcon()) {
	using FunctionType = decltype(resetPlayerIcon())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x41ffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::reversePlayer(EffectGameObject* p0) -> decltype(reversePlayer(p0)) {
	using FunctionType = decltype(reversePlayer(p0))(*)(PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x41ed50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::ringJump(RingObject* p0, bool p1) -> decltype(ringJump(p0, p1)) {
	using FunctionType = decltype(ringJump(p0, p1))(*)(PlayerObject*, RingObject*, bool);
	static auto func = wrapFunction(base::get() + 0x41d7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void PlayerObject::runNormalRotation() {
		this->runNormalRotation(false, 1.0f);
	}

auto PlayerObject::runNormalRotation(bool p0, float p1) -> decltype(runNormalRotation(p0, p1)) {
	using FunctionType = decltype(runNormalRotation(p0, p1))(*)(PlayerObject*, bool, float);
	static auto func = wrapFunction(base::get() + 0x408ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::setSecondColor(cocos2d::ccColor3B const& p0) -> decltype(setSecondColor(p0)) {
	using FunctionType = decltype(setSecondColor(p0))(*)(PlayerObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x407090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::setupStreak() -> decltype(setupStreak()) {
	using FunctionType = decltype(setupStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x405810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::spiderTestJump(bool p0) -> decltype(spiderTestJump(p0)) {
	using FunctionType = decltype(spiderTestJump(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x40c870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::spiderTestJumpInternal(bool p0) -> decltype(spiderTestJumpInternal(p0)) {
	using FunctionType = decltype(spiderTestJumpInternal(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x416c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::stopDashing() -> decltype(stopDashing()) {
	using FunctionType = decltype(stopDashing())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x40ab10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::stopPlatformerJumpAnimation() -> decltype(stopPlatformerJumpAnimation()) {
	using FunctionType = decltype(stopPlatformerJumpAnimation())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x40d290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::stopStreak2() -> decltype(stopStreak2()) {
	using FunctionType = decltype(stopStreak2())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x424840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::switchedToMode(GameObjectType p0) -> decltype(switchedToMode(p0)) {
	using FunctionType = decltype(switchedToMode(p0))(*)(PlayerObject*, GameObjectType);
	static auto func = wrapFunction(base::get() + 0x41bfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::toggleBirdMode(bool p0, bool p1) -> decltype(toggleBirdMode(p0, p1)) {
	using FunctionType = decltype(toggleBirdMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x4201d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleDartMode(bool p0, bool p1) -> decltype(toggleDartMode(p0, p1)) {
	using FunctionType = decltype(toggleDartMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x421270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleFlyMode(bool p0, bool p1) -> decltype(toggleFlyMode(p0, p1)) {
	using FunctionType = decltype(toggleFlyMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x41f6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleGhostEffect(GhostType p0) -> decltype(toggleGhostEffect(p0)) {
	using FunctionType = decltype(toggleGhostEffect(p0))(*)(PlayerObject*, GhostType);
	static auto func = wrapFunction(base::get() + 0x41c590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::togglePlatformerMode(bool val) {
        m_isPlatformer = val;
    }

auto PlayerObject::togglePlayerScale(bool p0, bool p1) -> decltype(togglePlayerScale(p0, p1)) {
	using FunctionType = decltype(togglePlayerScale(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x41c110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleRobotMode(bool p0, bool p1) -> decltype(toggleRobotMode(p0, p1)) {
	using FunctionType = decltype(toggleRobotMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x421cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleRollMode(bool p0, bool p1) -> decltype(toggleRollMode(p0, p1)) {
	using FunctionType = decltype(toggleRollMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x421930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleSpiderMode(bool p0, bool p1) -> decltype(toggleSpiderMode(p0, p1)) {
	using FunctionType = decltype(toggleSpiderMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x4221b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleSwingMode(bool p0, bool p1) -> decltype(toggleSwingMode(p0, p1)) {
	using FunctionType = decltype(toggleSwingMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x420890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::updateEffects(float param) -> decltype(updateEffects(param)) {
	using FunctionType = decltype(updateEffects(param))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x40bd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, param);
}

auto PlayerObject::updateGlowColor() -> decltype(updateGlowColor()) {
	using FunctionType = decltype(updateGlowColor())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x423390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateJump(float p0) -> decltype(updateJump(p0)) {
	using FunctionType = decltype(updateJump(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x407100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerBirdFrame(int p0) -> decltype(updatePlayerBirdFrame(p0)) {
	using FunctionType = decltype(updatePlayerBirdFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x4205f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerDartFrame(int p0) -> decltype(updatePlayerDartFrame(p0)) {
	using FunctionType = decltype(updatePlayerDartFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x4216e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerFrame(int p0) -> decltype(updatePlayerFrame(p0)) {
	using FunctionType = decltype(updatePlayerFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x420f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerGlow() -> decltype(updatePlayerGlow()) {
	using FunctionType = decltype(updatePlayerGlow())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x41ef10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerJetpackFrame(int p0) -> decltype(updatePlayerJetpackFrame(p0)) {
	using FunctionType = decltype(updatePlayerJetpackFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x41fd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerRobotFrame(int id) -> decltype(updatePlayerRobotFrame(id)) {
	using FunctionType = decltype(updatePlayerRobotFrame(id))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x423a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, id);
}

auto PlayerObject::updatePlayerRollFrame(int p0) -> decltype(updatePlayerRollFrame(p0)) {
	using FunctionType = decltype(updatePlayerRollFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x421ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerShipFrame(int p0) -> decltype(updatePlayerShipFrame(p0)) {
	using FunctionType = decltype(updatePlayerShipFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x41fb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerSpiderFrame(int id) -> decltype(updatePlayerSpiderFrame(id)) {
	using FunctionType = decltype(updatePlayerSpiderFrame(id))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x423a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, id);
}

auto PlayerObject::updatePlayerSwingFrame(int p0) -> decltype(updatePlayerSwingFrame(p0)) {
	using FunctionType = decltype(updatePlayerSwingFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x420cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateStreakBlend(bool p0) -> decltype(updateStreakBlend(p0)) {
	using FunctionType = decltype(updateStreakBlend(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x405e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateTimeMod(float p0, bool p1) -> decltype(updateTimeMod(p0, p1)) {
	using FunctionType = decltype(updateTimeMod(p0, p1))(*)(PlayerObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x405680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::update), this);
	using FunctionType = decltype(update(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x405f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x425cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x425ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x425cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&PlayerObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(PlayerObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x422650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x425d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x425c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&PlayerObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(PlayerObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x423850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&PlayerObject::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(PlayerObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x423230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x425c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setFlipY), this);
	using FunctionType = decltype(setFlipY(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x425cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x41b180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::getRealPosition() -> decltype(getRealPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::getRealPosition), this);
	using FunctionType = decltype(getRealPosition())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x423a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::getOrientedBox() -> decltype(getOrientedBox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::getOrientedBox), this);
	using FunctionType = decltype(getOrientedBox())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x424d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::getObjectRotation() -> decltype(getObjectRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::getObjectRotation), this);
	using FunctionType = decltype(getObjectRotation())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x424da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&PlayerObject::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(PlayerObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x425df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

PlayLayer::~PlayLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xab7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) PlayLayer(geode::CutoffConstructor, sizeof(PlayLayer));
	CCDestructor::lock(this) = true;
}

auto PlayLayer::create(GJGameLevel* level, bool useReplay, bool dontCreateObjects) -> decltype(create(level, useReplay, dontCreateObjects)) {
	using FunctionType = decltype(create(level, useReplay, dontCreateObjects))(*)(GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0xabbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, useReplay, dontCreateObjects);
}

PlayLayer* PlayLayer::get() {
		return GameManager::get()->m_playLayer;
	}

void PlayLayer::addCircle(CCCircleWave* cw) {
		m_circleWaveArray->addObject(cw);
	}

auto PlayLayer::addObject(GameObject* p0) -> decltype(addObject(p0)) {
	using FunctionType = decltype(addObject(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xb24e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::delayedResetLevel() -> decltype(delayedResetLevel()) {
	using FunctionType = decltype(delayedResetLevel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbb940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::fullReset() -> decltype(fullReset()) {
	using FunctionType = decltype(fullReset())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbee70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

float PlayLayer::getCurrentPercent() {
		float percent;

		if (this->m_level->m_timestamp > 0)
			percent = static_cast<float>(this->m_gameState.m_currentProgress) / this->m_level->m_timestamp * 100.f;
		else
			percent = this->m_player1->getPosition().x / this->m_levelLength * 100.f;

		return std::clamp(percent, 0.f, 100.f);
	}

int PlayLayer::getCurrentPercentInt() {
		return static_cast<int>(this->getCurrentPercent());
	}

auto PlayLayer::incrementJumps() -> decltype(incrementJumps()) {
	using FunctionType = decltype(incrementJumps())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbf5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::init(GJGameLevel* level, bool useReplay, bool dontCreateObjects) -> decltype(init(level, useReplay, dontCreateObjects)) {
	using FunctionType = decltype(init(level, useReplay, dontCreateObjects))(*)(PlayLayer*, GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0xabc70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level, useReplay, dontCreateObjects);
}

auto PlayLayer::levelComplete() -> decltype(levelComplete()) {
	using FunctionType = decltype(levelComplete())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb4290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::loadDynamicSaveObjects(gd::vector<SavedObjectStateRef>& p0) -> decltype(loadDynamicSaveObjects(p0)) {
	using FunctionType = decltype(loadDynamicSaveObjects(p0))(*)(PlayLayer*, gd::vector<SavedObjectStateRef>&);
	static auto func = wrapFunction(base::get() + 0xbe9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::loadFromCheckpoint(CheckpointObject* p0) -> decltype(loadFromCheckpoint(p0)) {
	using FunctionType = decltype(loadFromCheckpoint(p0))(*)(PlayLayer*, CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0xbe490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::markCheckpoint() -> decltype(markCheckpoint()) {
	using FunctionType = decltype(markCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbbd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::onQuit() -> decltype(onQuit()) {
	using FunctionType = decltype(onQuit())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb3e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::pauseGame(bool p0) -> decltype(pauseGame(p0)) {
	using FunctionType = decltype(pauseGame(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbf630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::playEndAnimationToPos(cocos2d::CCPoint p0) -> decltype(playEndAnimationToPos(p0)) {
	using FunctionType = decltype(playEndAnimationToPos(p0))(*)(PlayLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xb6ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::playPlatformerEndAnimationToPos(cocos2d::CCPoint p0, bool p1) -> decltype(playPlatformerEndAnimationToPos(p0, p1)) {
	using FunctionType = decltype(playPlatformerEndAnimationToPos(p0, p1))(*)(PlayLayer*, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0xb7260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayLayer::prepareCreateObjectsFromSetup(gd::string& p0) -> decltype(prepareCreateObjectsFromSetup(p0)) {
	using FunctionType = decltype(prepareCreateObjectsFromSetup(p0))(*)(PlayLayer*, gd::string&);
	static auto func = wrapFunction(base::get() + 0xaccb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::processCreateObjectsFromSetup() -> decltype(processCreateObjectsFromSetup()) {
	using FunctionType = decltype(processCreateObjectsFromSetup())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xad0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resetLevel() -> decltype(resetLevel()) {
	using FunctionType = decltype(resetLevel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb32d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resumeAndRestart(bool p0) -> decltype(resumeAndRestart(p0)) {
	using FunctionType = decltype(resumeAndRestart(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbf770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::scene(GJGameLevel* level, bool useReplay, bool dontCreateObjects) -> decltype(scene(level, useReplay, dontCreateObjects)) {
	using FunctionType = decltype(scene(level, useReplay, dontCreateObjects))(*)(GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0xabb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, useReplay, dontCreateObjects);
}

auto PlayLayer::setupHasCompleted() -> decltype(setupHasCompleted()) {
	using FunctionType = decltype(setupHasCompleted())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xadb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showCompleteEffect() -> decltype(showCompleteEffect()) {
	using FunctionType = decltype(showCompleteEffect())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb4f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showCompleteText() -> decltype(showCompleteText()) {
	using FunctionType = decltype(showCompleteText())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb5380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) -> decltype(showNewBest(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(showNewBest(p0, p1, p2, p3, p4, p5))(*)(PlayLayer*, bool, int, int, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0xb5fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto PlayLayer::togglePracticeMode(bool p0) -> decltype(togglePracticeMode(p0)) {
	using FunctionType = decltype(togglePracticeMode(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbefe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::updateEffectPositions() -> decltype(updateEffectPositions()) {
	using FunctionType = decltype(updateEffectPositions())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbba40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateInfoLabel() -> decltype(updateInfoLabel()) {
	using FunctionType = decltype(updateInfoLabel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb0120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateProgressbar() -> decltype(updateProgressbar()) {
	using FunctionType = decltype(updateProgressbar())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb1f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbfa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbfab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::postUpdate), this);
	using FunctionType = decltype(postUpdate(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0xbbb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::checkForEnd() -> decltype(checkForEnd()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::checkForEnd), this);
	using FunctionType = decltype(checkForEnd())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbbe40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::testTime() -> decltype(testTime()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::testTime), this);
	using FunctionType = decltype(testTime())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xc0010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::updateVerifyDamage() -> decltype(updateVerifyDamage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::updateVerifyDamage), this);
	using FunctionType = decltype(updateVerifyDamage())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbbf30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::updateAttemptTime(float p0) -> decltype(updateAttemptTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::updateAttemptTime), this);
	using FunctionType = decltype(updateAttemptTime(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0xbbfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::updateVisibility), this);
	using FunctionType = decltype(updateVisibility(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0xb7dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::opacityForObject(GameObject* p0) -> decltype(opacityForObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&PlayLayer::opacityForObject), this);
	using FunctionType = decltype(opacityForObject(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xba170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::updateColor(cocos2d::ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int>::func(&PlayLayer::updateColor), this);
	using FunctionType = decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10))(*)(PlayLayer*, cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0xba250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
}

auto PlayLayer::activateEndTrigger(int p0, bool p1, bool p2) -> decltype(activateEndTrigger(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool, bool>::func(&PlayLayer::activateEndTrigger), this);
	using FunctionType = decltype(activateEndTrigger(p0, p1, p2))(*)(PlayLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0xb6c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto PlayLayer::activatePlatformerEndTrigger(EndTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activatePlatformerEndTrigger(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<EndTriggerGameObject*, gd::vector<int> const&>::func(&PlayLayer::activatePlatformerEndTrigger), this);
	using FunctionType = decltype(activatePlatformerEndTrigger(p0, p1))(*)(PlayLayer*, EndTriggerGameObject*, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0xb7170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayLayer::toggleGlitter(bool p0) -> decltype(toggleGlitter(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleGlitter), this);
	using FunctionType = decltype(toggleGlitter(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbad40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::destroyPlayer(PlayerObject* p0, GameObject* p1) -> decltype(destroyPlayer(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*, GameObject*>::func(&PlayLayer::destroyPlayer), this);
	using FunctionType = decltype(destroyPlayer(p0, p1))(*)(PlayLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xbae00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayLayer::toggleGroundVisibility(bool p0) -> decltype(toggleGroundVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleGroundVisibility), this);
	using FunctionType = decltype(toggleGroundVisibility(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbac50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::toggleMGVisibility(bool p0) -> decltype(toggleMGVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleMGVisibility), this);
	using FunctionType = decltype(toggleMGVisibility(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbac80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::toggleHideAttempts(bool p0) -> decltype(toggleHideAttempts(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleHideAttempts), this);
	using FunctionType = decltype(toggleHideAttempts(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbaca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) -> decltype(timeForPos(p0, p1, p2, p3, p4)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint, int, int, bool, int>::func(&PlayLayer::timeForPos), this);
	using FunctionType = decltype(timeForPos(p0, p1, p2, p3, p4))(*)(PlayLayer*, cocos2d::CCPoint, int, int, bool, int);
	static auto func = wrapFunction(base::get() + 0xbab30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4);
}

auto PlayLayer::posForTime(float p0) -> decltype(posForTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::posForTime), this);
	using FunctionType = decltype(posForTime(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0xbabb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::resetSPTriggered() -> decltype(resetSPTriggered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::resetSPTriggered), this);
	using FunctionType = decltype(resetSPTriggered())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbac00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::updateTimeWarp(float p0) -> decltype(updateTimeWarp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::updateTimeWarp), this);
	using FunctionType = decltype(updateTimeWarp(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0xb6b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::playGravityEffect(bool p0) -> decltype(playGravityEffect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::playGravityEffect), this);
	using FunctionType = decltype(playGravityEffect(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xba2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&PlayLayer::manualUpdateObjectColors), this);
	using FunctionType = decltype(manualUpdateObjectColors(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xba180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CheckpointGameObject*>::func(&PlayLayer::checkpointActivated), this);
	using FunctionType = decltype(checkpointActivated(p0))(*)(PlayLayer*, CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0xbc040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::flipArt(bool p0) -> decltype(flipArt(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::flipArt), this);
	using FunctionType = decltype(flipArt(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbaab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::updateTimeLabel(int p0, int p1, bool p2) -> decltype(updateTimeLabel(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<int, int, bool>::func(&PlayLayer::updateTimeLabel), this);
	using FunctionType = decltype(updateTimeLabel(p0, p1, p2))(*)(PlayLayer*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0xba6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto PlayLayer::checkSnapshot() -> decltype(checkSnapshot()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::checkSnapshot), this);
	using FunctionType = decltype(checkSnapshot())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbede0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::toggleProgressbar() -> decltype(toggleProgressbar()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::toggleProgressbar), this);
	using FunctionType = decltype(toggleProgressbar())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xba8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::toggleInfoLabel() -> decltype(toggleInfoLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::toggleInfoLabel), this);
	using FunctionType = decltype(toggleInfoLabel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbaaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::removeAllCheckpoints() -> decltype(removeAllCheckpoints()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::removeAllCheckpoints), this);
	using FunctionType = decltype(removeAllCheckpoints())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbebd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::toggleMusicInPractice() -> decltype(toggleMusicInPractice()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::toggleMusicInPractice), this);
	using FunctionType = decltype(toggleMusicInPractice())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xbaa50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CurrencyRewardLayer*>::func(&PlayLayer::currencyWillExit), this);
	using FunctionType = decltype(currencyWillExit(p0))(*)(PlayLayer*, CurrencyRewardLayer*);
	static auto func = wrapFunction(base::get() + 0xbb960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::circleWaveWillBeRemoved(CCCircleWave* p0) -> decltype(circleWaveWillBeRemoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCCircleWave*>::func(&PlayLayer::circleWaveWillBeRemoved), this);
	using FunctionType = decltype(circleWaveWillBeRemoved(p0))(*)(PlayLayer*, CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0xbba00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&PlayLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(PlayLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0xbb9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PointNode::create(cocos2d::CCPoint p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x9d380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

bool PointNode::init(cocos2d::CCPoint p0) {
		m_point = p0;

		return true;
	}

auto UserInfoDelegate::getUserInfoFinished(GJUserScore* p0) -> decltype(getUserInfoFinished(p0)) {
	throw std::runtime_error("UserInfoDelegate::getUserInfoFinished not implemented");
}

auto UserInfoDelegate::getUserInfoFailed(int p0) -> decltype(getUserInfoFailed(p0)) {
	throw std::runtime_error("UserInfoDelegate::getUserInfoFailed not implemented");
}

auto UserInfoDelegate::userInfoChanged(GJUserScore* p0) -> decltype(userInfoChanged(p0)) {
	throw std::runtime_error("UserInfoDelegate::userInfoChanged not implemented");
}

auto ProfilePage::create(int accountID, bool ownProfile) -> decltype(create(accountID, ownProfile)) {
	using FunctionType = decltype(create(accountID, ownProfile))(*)(int, bool);
	static auto func = wrapFunction(base::get() + 0x7c4d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(accountID, ownProfile);
}

auto ProfilePage::init(int accountID, bool ownProfile) -> decltype(init(accountID, ownProfile)) {
	using FunctionType = decltype(init(accountID, ownProfile))(*)(ProfilePage*, int, bool);
	static auto func = wrapFunction(base::get() + 0x7c4fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, accountID, ownProfile);
}

auto ProfilePage::loadPageFromUserInfo(GJUserScore* p0) -> decltype(loadPageFromUserInfo(p0)) {
	using FunctionType = decltype(loadPageFromUserInfo(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x7c6330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::onStatInfo(cocos2d::CCObject* sender) -> decltype(onStatInfo(sender)) {
	using FunctionType = decltype(onStatInfo(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7c8e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7be330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(ProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x7c61f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x7cdb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x7cc5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::show), this);
	using FunctionType = decltype(show())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x7cc860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&ProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(ProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x7cc090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x7cc6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x7cc7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::getUserInfoFinished(GJUserScore* p0) -> decltype(getUserInfoFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserScore*>::func(&ProfilePage::getUserInfoFinished), this);
	using FunctionType = decltype(getUserInfoFinished(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x7ccb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::getUserInfoFailed(int p0) -> decltype(getUserInfoFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&ProfilePage::getUserInfoFailed), this);
	using FunctionType = decltype(getUserInfoFailed(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x7ccea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::userInfoChanged(GJUserScore* p0) -> decltype(userInfoChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserScore*>::func(&ProfilePage::userInfoChanged), this);
	using FunctionType = decltype(userInfoChanged(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x7ccf60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&ProfilePage::loadCommentsFinished), this);
	using FunctionType = decltype(loadCommentsFinished(p0, p1))(*)(ProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x7cd170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&ProfilePage::loadCommentsFailed), this);
	using FunctionType = decltype(loadCommentsFailed(p0))(*)(ProfilePage*, char const*);
	static auto func = wrapFunction(base::get() + 0x7cd260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&ProfilePage::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(ProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x7cd330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&ProfilePage::commentUploadFinished), this);
	using FunctionType = decltype(commentUploadFinished(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x7cd830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, CommentError>::func(&ProfilePage::commentUploadFailed), this);
	using FunctionType = decltype(commentUploadFailed(p0, p1))(*)(ProfilePage*, int, CommentError);
	static auto func = wrapFunction(base::get() + 0x7cd8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::commentDeleteFailed(int p0, int p1) -> decltype(commentDeleteFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::commentDeleteFailed), this);
	using FunctionType = decltype(commentDeleteFailed(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x7cd990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&ProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(ProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x7cc270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x7cc2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x7cc4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&PromoInterstitial::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(PromoInterstitial*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2d1540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&PromoInterstitial::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(PromoInterstitial*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2d1760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&PromoInterstitial::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(PromoInterstitial*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2d1640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&PromoInterstitial::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(PromoInterstitial*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2d16e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PromoInterstitial::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(PromoInterstitial*);
	static auto func = wrapFunction(base::get() + 0x2d13a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PromoInterstitial::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PromoInterstitial::show), this);
	using FunctionType = decltype(show())(*)(PromoInterstitial*);
	static auto func = wrapFunction(base::get() + 0x2d1370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PurchaseItemPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PurchaseItemPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(PurchaseItemPopup*);
	static auto func = wrapFunction(base::get() + 0x327270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RandTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RandTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(RandTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1bdd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RandTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&RandTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(RandTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1be020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto RandTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&RandTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(RandTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1be280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RandTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&RandTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(RandTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1be8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RateDemonLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateDemonLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateDemonLayer*);
	static auto func = wrapFunction(base::get() + 0x280930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateDemonLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateDemonLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(RateDemonLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x2805f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateDemonLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateDemonLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(RateDemonLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x2806e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateDemonLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&RateDemonLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(RateDemonLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x280850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RateLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x56fbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateStarsLayer::init(int p0, bool p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(RateStarsLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x287930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto RateStarsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateStarsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateStarsLayer*);
	static auto func = wrapFunction(base::get() + 0x2886f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateStarsLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateStarsLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(RateStarsLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x2883b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateStarsLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateStarsLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(RateStarsLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x2884a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateStarsLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&RateStarsLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(RateStarsLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x288610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RetryLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x504350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&RetryLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(RetryLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x504280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RetryLevelLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x503110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&RetryLevelLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(RetryLevelLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x503d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RetryLevelLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::enterAnimFinished), this);
	using FunctionType = decltype(enterAnimFinished())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x503e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x504260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::shouldOffsetRewardCurrency() -> decltype(shouldOffsetRewardCurrency()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::shouldOffsetRewardCurrency), this);
	using FunctionType = decltype(shouldOffsetRewardCurrency())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x5043a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void RetryLevelLayer::keyUp(cocos2d::enumKeyCodes p0) {}

auto RewardsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::init), this);
	using FunctionType = decltype(init())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x214cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x216580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x216510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::show), this);
	using FunctionType = decltype(show())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x2163b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void RewardsPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto RewardsPage::rewardsStatusFinished(int p0) -> decltype(rewardsStatusFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&RewardsPage::rewardsStatusFinished), this);
	using FunctionType = decltype(rewardsStatusFinished(p0))(*)(RewardsPage*, int);
	static auto func = wrapFunction(base::get() + 0x216030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RewardsPage::rewardsStatusFailed() -> decltype(rewardsStatusFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::rewardsStatusFailed), this);
	using FunctionType = decltype(rewardsStatusFailed())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x2162c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void RewardUnlockLayer::keyBackClicked() {}

auto RewardUnlockLayer::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CurrencyRewardLayer*>::func(&RewardUnlockLayer::currencyWillExit), this);
	using FunctionType = decltype(currencyWillExit(p0))(*)(RewardUnlockLayer*, CurrencyRewardLayer*);
	static auto func = wrapFunction(base::get() + 0x219f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RotateGameplayGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RotateGameplayGameObject::init), this);
	using FunctionType = decltype(init())(*)(RotateGameplayGameObject*);
	static auto func = wrapFunction(base::get() + 0x1eb3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RotateGameplayGameObject::updateStartValues() -> decltype(updateStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RotateGameplayGameObject::updateStartValues), this);
	using FunctionType = decltype(updateStartValues())(*)(RotateGameplayGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ed0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RotateGameplayGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&RotateGameplayGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(RotateGameplayGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ecd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RotateGameplayGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&RotateGameplayGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(RotateGameplayGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1eb420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ScrollingLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ScrollingLayer::draw), this);
	using FunctionType = decltype(draw())(*)(ScrollingLayer*);
	static auto func = wrapFunction(base::get() + 0x72db30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ScrollingLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ScrollingLayer::visit), this);
	using FunctionType = decltype(visit())(*)(ScrollingLayer*);
	static auto func = wrapFunction(base::get() + 0x72dc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ScrollingLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x72dd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x72def0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x72e010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x72e050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetTextPopup::create(gd::string value, gd::string placeholder, int maxLength, gd::string title, gd::string okBtnText, bool showResetBtn, float p6) -> decltype(create(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6)) {
	using FunctionType = decltype(create(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6))(*)(gd::string, gd::string, int, gd::string, gd::string, bool, float);
	static auto func = wrapFunction(base::get() + 0x2a9b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6);
}

auto SetTextPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTextPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetTextPopup*);
	static auto func = wrapFunction(base::get() + 0x2ab090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTextPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTextPopup::show), this);
	using FunctionType = decltype(show())(*)(SetTextPopup*);
	static auto func = wrapFunction(base::get() + 0x2ab030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTextPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetTextPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetTextPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2aaf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetTextPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetTextPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetTextPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2aaf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer*);
	static auto func = wrapFunction(base::get() + 0x6056d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer*);
	static auto func = wrapFunction(base::get() + 0x6094b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x608630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x608700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SecretLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x6087d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SecretLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto SecretLayer2::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x4a6f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x4ad060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x4acf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer2::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer2*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4abff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer2::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer2::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer2*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4ac0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer2::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer2::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SecretLayer2*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4ac190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SecretLayer2::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto SecretLayer2::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretLayer2::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretLayer2*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x4aaa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer3::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x4ad500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x4b2400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x4b23d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretLayer3::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretLayer3*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x4b20b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer4::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x3b3ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x3b84b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x3b83c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer4::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer4*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3b7500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer4::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer4::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer4*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3b75d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer4::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer4::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SecretLayer4*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3b76a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SecretLayer4::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

void SecretLayer4::dialogClosed(DialogLayer* p0) {}

auto SecretNumberLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretNumberLayer::init), this);
	using FunctionType = decltype(init())(*)(SecretNumberLayer*);
	static auto func = wrapFunction(base::get() + 0x4ad140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretRewardsLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SecretRewardsLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x63d020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretRewardsLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x646ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretRewardsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretRewardsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x646a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretRewardsLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretRewardsLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretRewardsLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x6468d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretRewardsLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&SecretRewardsLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(SecretRewardsLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x63f0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SelectArtLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectArtLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x26c700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectEventLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectEventLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectEventLayer*);
	static auto func = wrapFunction(base::get() + 0x581790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectEventLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SelectEventLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SelectEventLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5816c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SelectEventLayer::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SelectEventLayer::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SelectEventLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x581490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SelectFontLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectFontLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectFontLayer*);
	static auto func = wrapFunction(base::get() + 0x296930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

SelectListIconLayer::SelectListIconLayer() {}

auto SelectListIconLayer::create(int difficulty) -> decltype(create(difficulty)) {
	using FunctionType = decltype(create(difficulty))(*)(int);
	static auto func = wrapFunction(base::get() + 0x35ee60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(difficulty);
}

auto SelectListIconLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SelectListIconLayer*, int);
	static auto func = wrapFunction(base::get() + 0x362770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SelectListIconLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SelectListIconLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x362d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectListIconLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(SelectListIconLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x362ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectListIconLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectListIconLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectListIconLayer*);
	static auto func = wrapFunction(base::get() + 0x362db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectPremadeDelegate::selectPremadeClosed(SelectPremadeLayer* p0, int p1) -> decltype(selectPremadeClosed(p0, p1)) {
	throw std::runtime_error("SelectPremadeDelegate::selectPremadeClosed not implemented");
}

auto SelectPremadeLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectPremadeLayer::init), this);
	using FunctionType = decltype(init())(*)(SelectPremadeLayer*);
	static auto func = wrapFunction(base::get() + 0x309190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectPremadeLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectPremadeLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectPremadeLayer*);
	static auto func = wrapFunction(base::get() + 0x3096a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectSettingLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectSettingLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x26d3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectSFXSortDelegate::sortSelectClosed(SelectSFXSortLayer* p0) -> decltype(sortSelectClosed(p0)) {
	throw std::runtime_error("SelectSFXSortDelegate::sortSelectClosed not implemented");
}

auto SelectSFXSortLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectSFXSortLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectSFXSortLayer*);
	static auto func = wrapFunction(base::get() + 0x44ab10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SequenceTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SequenceTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(SequenceTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1bf2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SequenceTriggerGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SequenceTriggerGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(SequenceTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1bf330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SequenceTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&SequenceTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(SequenceTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1bf5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto SequenceTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&SequenceTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SequenceTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1bfb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SequenceTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SequenceTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SequenceTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c0060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetColorIDPopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&SetColorIDPopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(SetColorIDPopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x2a8870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetFolderPopup::valueChanged() -> decltype(valueChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetFolderPopup::valueChanged), this);
	using FunctionType = decltype(valueChanged())(*)(SetFolderPopup*);
	static auto func = wrapFunction(base::get() + 0x2a9a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetFolderPopup::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&SetFolderPopup::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(SetFolderPopup*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2aa060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetGroupIDLayer::create(GameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3115c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetGroupIDLayer::init(GameObject* obj, cocos2d::CCArray* objs) -> decltype(init(obj, objs)) {
	using FunctionType = decltype(init(obj, objs))(*)(SetGroupIDLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x311790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, obj, objs);
}

auto SetGroupIDLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetGroupIDLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x316750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetGroupIDLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetGroupIDLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetGroupIDLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x315fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetGroupIDLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetGroupIDLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetGroupIDLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x316010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetItemIDLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetItemIDLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetItemIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9c540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetItemIDLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetItemIDLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetItemIDLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x9c450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetItemIDLayer::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetItemIDLayer::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetItemIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9c330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetTargetIDLayer::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTargetIDLayer::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetTargetIDLayer*);
	static auto func = wrapFunction(base::get() + 0x2b65b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTargetIDLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetTargetIDLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetTargetIDLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x2b65c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowEditPhysicsPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowEditPhysicsPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowEditPhysicsPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x30a800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupAdvFollowPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupAdvFollowPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3090f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupAdvFollowPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAdvFollowPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAdvFollowPopup*);
	static auto func = wrapFunction(base::get() + 0x308690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAdvFollowPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3087d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupAdvFollowPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupAdvFollowPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x308a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupAdvFollowPopup::selectPremadeClosed(SelectPremadeLayer* p0, int p1) -> decltype(selectPremadeClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SelectPremadeLayer*, int>::func(&SetupAdvFollowPopup::selectPremadeClosed), this);
	using FunctionType = decltype(selectPremadeClosed(p0, p1))(*)(SetupAdvFollowPopup*, SelectPremadeLayer*, int);
	static auto func = wrapFunction(base::get() + 0x308c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowRetargetPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAdvFollowRetargetPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAdvFollowRetargetPopup*);
	static auto func = wrapFunction(base::get() + 0x30b0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAdvFollowRetargetPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowRetargetPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowRetargetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x30b210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAnimationPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAnimationPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupAnimationPopup*);
	static auto func = wrapFunction(base::get() + 0x3d9640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAnimationPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupAnimationPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupAnimationPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3d9a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupAnimationPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupAnimationPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupAnimationPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3d9870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupAnimSettingsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupAnimSettingsPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupAnimSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9ae50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupAreaMoveTriggerPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupAreaMoveTriggerPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x4dea00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAreaMoveTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAreaMoveTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x4de5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaMoveTriggerPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4de9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4de890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4de960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4de9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaTintTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAreaTintTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupAreaTintTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x4e2ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaTintTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupAreaTintTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupAreaTintTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e2de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupAreaTintTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaTintTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAreaTintTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4e29e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaTintTriggerPopup::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::ccHSVValue>::func(&SetupAreaTintTriggerPopup::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(SetupAreaTintTriggerPopup*, HSVWidgetPopup*, cocos2d::ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x4e2c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaAnimTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAreaAnimTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAreaAnimTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x4e6040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaAnimTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaAnimTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAreaAnimTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4e61e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupArtSwitchPopup::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&SetupArtSwitchPopup::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(SetupArtSwitchPopup*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x58d020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupAudioLineGuidePopup::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSettingLayer*>::func(&SetupAudioLineGuidePopup::selectSettingClosed), this);
	using FunctionType = decltype(selectSettingClosed(p0))(*)(SetupAudioLineGuidePopup*, SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x58b4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupAudioTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAudioTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAudioTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4c18a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupCameraEdgePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCameraEdgePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCameraEdgePopup*);
	static auto func = wrapFunction(base::get() + 0x590a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCameraEdgePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupCameraEdgePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupCameraEdgePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x590cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupCameraEdgePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCameraEdgePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCameraEdgePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x590bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraModePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCameraModePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCameraModePopup*);
	static auto func = wrapFunction(base::get() + 0x4b3bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCameraModePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupCameraModePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupCameraModePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4b3ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupCameraOffsetTrigger::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCameraOffsetTrigger::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCameraOffsetTrigger*);
	static auto func = wrapFunction(base::get() + 0x6706c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCameraOffsetTrigger::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupCameraOffsetTrigger::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupCameraOffsetTrigger*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6711f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupCameraOffsetTrigger::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCameraOffsetTrigger::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCameraOffsetTrigger*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x670ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraOffsetTrigger::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupCameraOffsetTrigger::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupCameraOffsetTrigger*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x670a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupCameraRotatePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCameraRotatePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCameraRotatePopup*);
	static auto func = wrapFunction(base::get() + 0x4c7d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCameraRotatePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupCameraRotatePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupCameraRotatePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4c8510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupCameraRotatePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCameraRotatePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCameraRotatePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4c82a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraRotatePopup::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupCameraRotatePopup::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupCameraRotatePopup*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x4c7fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupInstantCollisionTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupInstantCollisionTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupInstantCollisionTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x39aab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupInstantCollisionTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupInstantCollisionTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupInstantCollisionTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x39a7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupCollisionTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCollisionTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCollisionTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x399730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCollisionTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupCollisionTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupCollisionTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x399dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupCollisionTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCollisionTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCollisionTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x399ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCountTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCountTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCountTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x2b8570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCountTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupCountTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupCountTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b8b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupCountTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCountTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCountTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2b88a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupEndPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupEndPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupEndPopup*);
	static auto func = wrapFunction(base::get() + 0x676a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupEndPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupEndPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupEndPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x676d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupEndPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupEndPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupEndPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x676c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupEndPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupEndPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupEndPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x676c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupEnterEffectPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupEnterEffectPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupEnterEffectPopup*);
	static auto func = wrapFunction(base::get() + 0x3fc2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupEnterEffectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupEnterEffectPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupEnterEffectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3fc6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupEnterEffectPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupEnterEffectPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupEnterEffectPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x3fc890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3fc860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3fc490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3fc7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3fc830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::ccHSVValue>::func(&SetupEnterEffectPopup::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(SetupEnterEffectPopup*, HSVWidgetPopup*, cocos2d::ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x3fc560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupEnterTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupEnterTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x297850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupForceBlockPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupForceBlockPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupForceBlockPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x58c6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupGameplayOffsetPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupGameplayOffsetPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x7a51e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGameplayOffsetPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupGameplayOffsetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x7a51c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGameplayOffsetPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupGameplayOffsetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x7a5170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGameplayOffsetPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupGameplayOffsetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x7a51a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupGameplayOffsetPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupGameplayOffsetPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7a50d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupGradientPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupGradientPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupGradientPopup*);
	static auto func = wrapFunction(base::get() + 0x5fda40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupGradientPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupGradientPopup::onPlusButton), this);
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupGradientPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5fdb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupGradientPopup::updateToggleItem(int p0, bool p1) -> decltype(updateToggleItem(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupGradientPopup::updateToggleItem), this);
	using FunctionType = decltype(updateToggleItem(p0, p1))(*)(SetupGradientPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x5fdbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGradientPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGradientPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupGradientPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x5fdd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGravityModPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupGravityModPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupGravityModPopup*);
	static auto func = wrapFunction(base::get() + 0x3dd660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupGravityModPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupGravityModPopup::show), this);
	using FunctionType = decltype(show())(*)(SetupGravityModPopup*);
	static auto func = wrapFunction(base::get() + 0x3dd600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupGravityModPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupGravityModPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupGravityModPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3dd4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupGravityModPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupGravityModPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupGravityModPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3dd500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupGravityTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGravityTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupGravityTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4cf300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupInstantCountPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupInstantCountPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupInstantCountPopup*);
	static auto func = wrapFunction(base::get() + 0x5f3870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupInstantCountPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupInstantCountPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupInstantCountPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f3ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupInstantCountPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupInstantCountPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupInstantCountPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5f3bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupInteractObjectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupInteractObjectPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupInteractObjectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x516e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupInteractObjectPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupInteractObjectPopup::onPlusButton), this);
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupInteractObjectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x516d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupInteractObjectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupInteractObjectPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupInteractObjectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x516d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupItemCompareTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupItemCompareTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupItemCompareTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x589cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupItemCompareTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupItemCompareTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupItemCompareTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x589b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupItemEditTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupItemEditTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupItemEditTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x587980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupItemEditTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupItemEditTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupItemEditTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5877a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupKeyframePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupKeyframePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupKeyframePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1fc400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupKeyframePopup::onCustomButton(cocos2d::CCObject* sender) -> decltype(onCustomButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupKeyframePopup::onCustomButton), this);
	using FunctionType = decltype(onCustomButton(sender))(*)(SetupKeyframePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1fc050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupKeyframePopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupKeyframePopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupKeyframePopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x1fbd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupKeyframePopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupKeyframePopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupKeyframePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1fbfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupMGTrigger::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupMGTrigger::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupMGTrigger*);
	static auto func = wrapFunction(base::get() + 0x511cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupMGTrigger::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupMGTrigger::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupMGTrigger*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x512520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupMGTrigger::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupMGTrigger::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupMGTrigger*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5122c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupMGTrigger::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupMGTrigger::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupMGTrigger*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x511f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupMoveCommandPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupMoveCommandPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x613e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupMoveCommandPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupMoveCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x613e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupMoveCommandPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupMoveCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x613e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupMoveCommandPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupMoveCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x613d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupMoveCommandPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupMoveCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x613d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupMoveCommandPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupMoveCommandPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x614090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupObjectOptions2Popup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupObjectOptions2Popup::onPlusButton), this);
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupObjectOptions2Popup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x31a1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupObjectOptionsPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupObjectOptionsPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupObjectOptionsPopup*);
	static auto func = wrapFunction(base::get() + 0x319b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupObjectOptionsPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupObjectOptionsPopup::show), this);
	using FunctionType = decltype(show())(*)(SetupObjectOptionsPopup*);
	static auto func = wrapFunction(base::get() + 0x319b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupObjectOptionsPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupObjectOptionsPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupObjectOptionsPopup*);
	static auto func = wrapFunction(base::get() + 0x319720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupObjectOptionsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupObjectOptionsPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupObjectOptionsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x319bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupObjectTogglePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupObjectTogglePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupObjectTogglePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3782a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupObjectTogglePopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupObjectTogglePopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupObjectTogglePopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x378220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupOpacityPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupOpacityPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupOpacityPopup*);
	static auto func = wrapFunction(base::get() + 0x591c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupOpacityPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupOpacityPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupOpacityPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x597c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupOpacityPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupOpacityPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupOpacityPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x59520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupOpacityPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupOpacityPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupOpacityPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x59560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupOptionsTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupOptionsTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupOptionsTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f1080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupPickupTriggerPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupPickupTriggerPopup::onPlusButton), this);
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupPickupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5a2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupPickupTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupPickupTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupPickupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5a330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupPortalPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupPortalPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupPortalPopup*);
	static auto func = wrapFunction(base::get() + 0x578070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupPulsePopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupPulsePopup::show), this);
	using FunctionType = decltype(show())(*)(SetupPulsePopup*);
	static auto func = wrapFunction(base::get() + 0x3b31d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupPulsePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupPulsePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupPulsePopup*);
	static auto func = wrapFunction(base::get() + 0x3b1e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupPulsePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupPulsePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupPulsePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b2a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupPulsePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupPulsePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupPulsePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3b3250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupPulsePopup::colorValueChanged(cocos2d::ccColor3B p0) -> decltype(colorValueChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B>::func(&SetupPulsePopup::colorValueChanged), this);
	using FunctionType = decltype(colorValueChanged(p0))(*)(SetupPulsePopup*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x3b2c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SetupPulsePopup::textInputOpened(CCTextInputNode* p0) {}

auto SetupPulsePopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&SetupPulsePopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(SetupPulsePopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x3b23b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRandAdvTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupRandAdvTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupRandAdvTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x390790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

void SetupRandAdvTriggerPopup::textChanged(CCTextInputNode* p0) {}

auto SetupRandTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupRandTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupRandTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x5efe20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupRandTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupRandTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupRandTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f0400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupRandTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupRandTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupRandTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5f0110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupReverbPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupReverbPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupReverbPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4c2370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupRotateCommandPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateCommandPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupRotateCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x6b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRotateCommandPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateCommandPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupRotateCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x6ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRotateCommandPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateCommandPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupRotateCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x6b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRotateCommandPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateCommandPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupRotateCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x6b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRotateCommandPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupRotateCommandPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupRotateCommandPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupRotateGameplayPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupRotateGameplayPopup::onPlusButton), this);
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupRotateGameplayPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7a45a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupRotateGameplayPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateGameplayPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupRotateGameplayPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x7a45e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRotatePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupRotatePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupRotatePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5a59e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupRotatePopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupRotatePopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupRotatePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5a5a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupSequenceTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupSequenceTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupSequenceTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e8ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SFXBrowserDelegate::sfxBrowserClosed(SFXBrowser* p0) -> decltype(sfxBrowserClosed(p0)) {
	throw std::runtime_error("SFXBrowserDelegate::sfxBrowserClosed not implemented");
}

auto SetupSFXPopup::pageChanged() -> decltype(pageChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSFXPopup::pageChanged), this);
	using FunctionType = decltype(pageChanged())(*)(SetupSFXPopup*);
	static auto func = wrapFunction(base::get() + 0x4c3dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSFXPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupSFXPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupSFXPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4c3e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupSFXPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupSFXPopup::onPlusButton), this);
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupSFXPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4c43b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupSFXPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupSFXPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupSFXPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4c4290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void SetupSFXPopup::sfxObjectSelected(SFXInfoObject* p0) {}

auto SetupSFXPopup::getActiveSFXID() -> decltype(getActiveSFXID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSFXPopup::getActiveSFXID), this);
	using FunctionType = decltype(getActiveSFXID())(*)(SetupSFXPopup*);
	static auto func = wrapFunction(base::get() + 0x4c41d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSFXPopup::overridePlaySFX(SFXInfoObject* p0) -> decltype(overridePlaySFX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXInfoObject*>::func(&SetupSFXPopup::overridePlaySFX), this);
	using FunctionType = decltype(overridePlaySFX(p0))(*)(SetupSFXPopup*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x4c41f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSFXPopup::sfxBrowserClosed(SFXBrowser* p0) -> decltype(sfxBrowserClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXBrowser*>::func(&SetupSFXPopup::sfxBrowserClosed), this);
	using FunctionType = decltype(sfxBrowserClosed(p0))(*)(SetupSFXPopup*, SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x4c4450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupShaderEffectPopup::toggleGroup(int p0, bool p1) -> decltype(toggleGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupShaderEffectPopup::toggleGroup), this);
	using FunctionType = decltype(toggleGroup(p0, p1))(*)(SetupShaderEffectPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2cce80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupShaderEffectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupShaderEffectPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupShaderEffectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ccec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupShaderEffectPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupShaderEffectPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupShaderEffectPopup*);
	static auto func = wrapFunction(base::get() + 0x2cc610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupShaderEffectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupShaderEffectPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupShaderEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x2ccb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupShakePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupShakePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupShakePopup*);
	static auto func = wrapFunction(base::get() + 0x672480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupShakePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupShakePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupShakePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x672b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupShakePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupShakePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupShakePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x6727e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartBlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSmartBlockLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupSmartBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f1c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSmartBlockLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSmartBlockLayer::show), this);
	using FunctionType = decltype(show())(*)(SetupSmartBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f1bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSmartBlockLayer::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&SetupSmartBlockLayer::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(SetupSmartBlockLayer*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x4f1c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartTemplateLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSmartTemplateLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupSmartTemplateLayer*);
	static auto func = wrapFunction(base::get() + 0x4f31d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSmartTemplateLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SetupSmartTemplateLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SetupSmartTemplateLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4f2e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupSmartTemplateLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupSmartTemplateLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SetupSmartTemplateLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4f30f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartTemplateLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupSmartTemplateLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupSmartTemplateLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4f2f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartTemplateLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupSmartTemplateLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupSmartTemplateLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4f31b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongPlaybackDelegate::onPlayback(SongInfoObject* p0) -> decltype(onPlayback(p0)) {
	throw std::runtime_error("SongPlaybackDelegate::onPlayback not implemented");
}

auto SetupSongTriggerPopup::pageChanged() -> decltype(pageChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSongTriggerPopup::pageChanged), this);
	using FunctionType = decltype(pageChanged())(*)(SetupSongTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x2d0dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSongTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupSongTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupSongTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2d0e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupSongTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupSongTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupSongTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x2d0cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupSongTriggerPopup::onPlayback(SongInfoObject* p0) -> decltype(onPlayback(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SongInfoObject*>::func(&SetupSongTriggerPopup::onPlayback), this);
	using FunctionType = decltype(onPlayback(p0))(*)(SetupSongTriggerPopup*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x2d0a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSpawnPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupSpawnPopup::onClose not implemented");
}

auto SetupStaticCameraPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupStaticCameraPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupStaticCameraPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x39ede0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupStaticCameraPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupStaticCameraPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupStaticCameraPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x39ee70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupStopTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupStopTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupStopTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x58d9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupStopTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupStopTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupStopTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x58d960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupTeleportPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTeleportPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTeleportPopup*);
	static auto func = wrapFunction(base::get() + 0x35ae30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTeleportPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTeleportPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupTeleportPopup*);
	static auto func = wrapFunction(base::get() + 0x35ae40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTeleportPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTeleportPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupTeleportPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x35af60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTimerControlTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupTimerControlTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupTimerControlTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3a5470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupTimeWarpPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTimeWarpPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTimeWarpPopup*);
	static auto func = wrapFunction(base::get() + 0x50dd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTimeWarpPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupTimeWarpPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupTimeWarpPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x50dee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupTouchTogglePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTouchTogglePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTouchTogglePopup*);
	static auto func = wrapFunction(base::get() + 0x2b5890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTouchTogglePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupTouchTogglePopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupTouchTogglePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b5bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupTouchTogglePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTouchTogglePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupTouchTogglePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2b5ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupZoomTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupZoomTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupZoomTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x3200b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupZoomTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupZoomTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupZoomTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3200c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SFXBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x44a270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SFXBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x44a1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SFXBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&SFXBrowser::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(SFXBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x4497d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&SFXBrowser::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(SFXBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x4498d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::sortSelectClosed(SelectSFXSortLayer* p0) -> decltype(sortSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSFXSortLayer*>::func(&SFXBrowser::sortSelectClosed), this);
	using FunctionType = decltype(sortSelectClosed(p0))(*)(SFXBrowser*, SelectSFXSortLayer*);
	static auto func = wrapFunction(base::get() + 0x449ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&SFXBrowser::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(SFXBrowser*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x449f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SFXBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&SFXBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(SFXBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x44a020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto SFXBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::getSelectedCellIdx), this);
	using FunctionType = decltype(getSelectedCellIdx())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x44a190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SFXBrowser::shouldSnapToSelected() -> decltype(shouldSnapToSelected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::shouldSnapToSelected), this);
	using FunctionType = decltype(shouldSnapToSelected())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x44a1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SFXSearchResult::updateObjects(AudioSortType p0) -> decltype(updateObjects(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AudioSortType>::func(&SFXSearchResult::updateObjects), this);
	using FunctionType = decltype(updateObjects(p0))(*)(SFXSearchResult*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x5a2ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&SFXTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SFXTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1c9be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SFXTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SFXTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SFXTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c4b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShaderGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ShaderGameObject*);
	static auto func = wrapFunction(base::get() + 0x198980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShaderGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&ShaderGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ShaderGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x19d750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ShaderGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ShaderGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ShaderGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1989f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShaderLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ShaderLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(ShaderLayer*, float);
	static auto func = wrapFunction(base::get() + 0x3cfaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShaderLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderLayer::init), this);
	using FunctionType = decltype(init())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3ce300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShaderLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderLayer::visit), this);
	using FunctionType = decltype(visit())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3d5910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::init), this);
	using FunctionType = decltype(init())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x4cf860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x4d1890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x4d1820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::show), this);
	using FunctionType = decltype(show())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x4d1690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShareCommentLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareCommentLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x5eaab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShareCommentLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareCommentLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x5eaa00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void ShareCommentLayer::textInputOpened(CCTextInputNode* textInput) {}

auto ShareCommentLayer::textInputClosed(CCTextInputNode* textInput) -> decltype(textInputClosed(textInput)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(textInput))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5eaaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, textInput);
}

auto ShareCommentLayer::textChanged(CCTextInputNode* textInput) -> decltype(textChanged(textInput)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textChanged), this);
	using FunctionType = decltype(textChanged(textInput))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5eac70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, textInput);
}

auto ShareCommentLayer::uploadActionFinished(int ID, int unk) -> decltype(uploadActionFinished(ID, unk)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ShareCommentLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(ID, unk))(*)(ShareCommentLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x5eaed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, ID, unk);
}

auto ShareCommentLayer::uploadActionFailed(int ID, int unk) -> decltype(uploadActionFailed(ID, unk)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ShareCommentLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(ID, unk))(*)(ShareCommentLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x5eafd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, ID, unk);
}

auto ShareCommentLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&ShareCommentLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(ShareCommentLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x5eb0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x27da30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShareLevelSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareLevelSettingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareLevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x27f550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void ShareLevelSettingsLayer::numberInputClosed(NumberInputLayer* p0) {}

auto ShareListLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareListLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareListLayer*);
	static auto func = wrapFunction(base::get() + 0x3649d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SimplePlayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x36c360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SimplePlayer::setSecondColor(cocos2d::_ccColor3B const& color) -> decltype(setSecondColor(color)) {
	using FunctionType = decltype(setSecondColor(color))(*)(SimplePlayer*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x372200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, color);
}

auto SimplePlayer::updateColors() -> decltype(updateColors()) {
	using FunctionType = decltype(updateColors())(*)(SimplePlayer*);
	static auto func = wrapFunction(base::get() + 0x36ffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SimplePlayer::updatePlayerFrame(int p0, IconType p1) -> decltype(updatePlayerFrame(p0, p1)) {
	using FunctionType = decltype(updatePlayerFrame(p0, p1))(*)(SimplePlayer*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x36c630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SimplePlayer::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&SimplePlayer::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(SimplePlayer*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x372500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SimplePlayer::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&SimplePlayer::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(SimplePlayer*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x3721a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::init), this);
	using FunctionType = decltype(init())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::draw), this);
	using FunctionType = decltype(draw())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28aa30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SlideInLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(SlideInLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x28aa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SlideInLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SlideInLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(SlideInLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x28aac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SlideInLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SlideInLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(SlideInLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x28aa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SlideInLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SlideInLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(SlideInLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x28aaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SlideInLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SlideInLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(SlideInLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28a7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&SlideInLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(SlideInLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x28a800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&SlideInLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(SlideInLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x28a8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::enterAnimFinished), this);
	using FunctionType = decltype(enterAnimFinished())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::disableUI() -> decltype(disableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::disableUI), this);
	using FunctionType = decltype(disableUI())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::enableUI() -> decltype(enableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::enableUI), this);
	using FunctionType = decltype(enableUI())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x28a6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

float SliderThumb::getValue() {
		return (this->getScaleX() * m_length * .5f +
				(m_vertical ?
					this->getPositionY() :
					this->getPositionX())
			) / (this->getScaleX() * m_length);
	}

auto SliderThumb::setValue(float p0) -> decltype(setValue(p0)) {
	using FunctionType = decltype(setValue(p0))(*)(SliderThumb*, float);
	static auto func = wrapFunction(base::get() + 0x302670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SliderTouchLogic::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x302d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x302f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x302eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SliderTouchLogic::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(SliderTouchLogic*);
	static auto func = wrapFunction(base::get() + 0x303280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto Slider::create(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x303500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler) -> decltype(create(target, handler)) {
	using FunctionType = decltype(create(target, handler))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x3032c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(target, handler);
}

auto Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, float idk) -> decltype(create(target, handler, idk)) {
	using FunctionType = decltype(create(target, handler, idk))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler, float);
	static auto func = wrapFunction(base::get() + 0x3033e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(target, handler, idk);
}

auto Slider::disableTouch() -> decltype(disableTouch()) {
	using FunctionType = decltype(disableTouch())(*)(Slider*);
	static auto func = wrapFunction(base::get() + 0x303b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

bool Slider::getLiveDragging() {
		return m_touchLogic->m_activateThumb;
	}

SliderThumb* Slider::getThumb() {
		return m_touchLogic->m_thumb;
	}

auto Slider::init(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(Slider*, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x303620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto Slider::setBarVisibility(bool p0) -> decltype(setBarVisibility(p0)) {
	using FunctionType = decltype(setBarVisibility(p0))(*)(Slider*, bool);
	static auto func = wrapFunction(base::get() + 0x303c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto Slider::setValue(float val) -> decltype(setValue(val)) {
	using FunctionType = decltype(setValue(val))(*)(Slider*, float);
	static auto func = wrapFunction(base::get() + 0x303960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, val);
}

void Slider::updateBar() {
		float local_8;
		auto thumb = this->getThumb();
		if (!thumb->m_vertical) {
			local_8 = thumb->getPositionX();
		} else {
			local_8 = thumb->getPositionY();
		}

		float local_c = thumb->getScale() * thumb->m_length * 0.5f + local_8;
		float fVar6 = m_width;
		local_c = local_c / (thumb->getScale() * thumb->m_length);
		if (fVar6 * local_c <= fVar6) {
			fVar6 = fVar6 * local_c;
		}

		this->m_sliderBar->setTextureRect(cocos2d::CCRect(0.0f, 0.0f, fVar6, m_height));
	}

auto Slider::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x303c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto Slider::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x303ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto Slider::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x303ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SmartGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&SmartGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SmartGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ac670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SmartGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SmartGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SmartGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ac0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SmartTemplateCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SmartTemplateCell::init), this);
	using FunctionType = decltype(init())(*)(SmartTemplateCell*);
	static auto func = wrapFunction(base::get() + 0x254b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SmartTemplateCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SmartTemplateCell::draw), this);
	using FunctionType = decltype(draw())(*)(SmartTemplateCell*);
	static auto func = wrapFunction(base::get() + 0x254be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongCell::init), this);
	using FunctionType = decltype(init())(*)(SongCell*);
	static auto func = wrapFunction(base::get() + 0x24f6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongCell::draw), this);
	using FunctionType = decltype(draw())(*)(SongCell*);
	static auto func = wrapFunction(base::get() + 0x24f730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SongInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x60d190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongInfoObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&SongInfoObject::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(SongInfoObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x5a01f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongInfoObject::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongInfoObject::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x5a03b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SongOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x211f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SongSelectNode::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SongSelectNode*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2142e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SongSelectNode::customSongLayerClosed() -> decltype(customSongLayerClosed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::customSongLayerClosed), this);
	using FunctionType = decltype(customSongLayerClosed())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x2143c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&SongSelectNode::songIDChanged), this);
	using FunctionType = decltype(songIDChanged(p0))(*)(SongSelectNode*, int);
	static auto func = wrapFunction(base::get() + 0x214420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongSelectNode::getActiveSongID() -> decltype(getActiveSongID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getActiveSongID), this);
	using FunctionType = decltype(getActiveSongID())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x214450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::getSongFileName() -> decltype(getSongFileName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getSongFileName), this);
	using FunctionType = decltype(getSongFileName())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x214470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::getLevelSettings() -> decltype(getLevelSettings()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getLevelSettings), this);
	using FunctionType = decltype(getLevelSettings())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x2145b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SongsLayer*);
	static auto func = wrapFunction(base::get() + 0x519f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&SongTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SongTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1cb1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SongTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SongTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SongTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ca8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpawnParticleGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SpawnParticleGameObject::init), this);
	using FunctionType = decltype(init())(*)(SpawnParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1e9500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpawnParticleGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&SpawnParticleGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SpawnParticleGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1eafb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SpawnParticleGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SpawnParticleGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SpawnParticleGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1e9550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpawnTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SpawnTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(SpawnTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ccca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpawnTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&SpawnTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(SpawnTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1cd010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto SpawnTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&SpawnTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SpawnTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1cd500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SpawnTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SpawnTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SpawnTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1cd9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpecialAnimGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SpecialAnimGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(SpecialAnimGameObject*);
	static auto func = wrapFunction(base::get() + 0x1aecf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpecialAnimGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&SpecialAnimGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SpecialAnimGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1aed10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SpecialAnimGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SpecialAnimGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SpecialAnimGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1aed70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpecialAnimGameObject::updateMainColor(cocos2d::ccColor3B const& p0) -> decltype(updateMainColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&SpecialAnimGameObject::updateMainColor), this);
	using FunctionType = decltype(updateMainColor(p0))(*)(SpecialAnimGameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1aecb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpecialAnimGameObject::updateSecondaryColor(cocos2d::ccColor3B const& p0) -> decltype(updateSecondaryColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&SpecialAnimGameObject::updateSecondaryColor), this);
	using FunctionType = decltype(updateSecondaryColor(p0))(*)(SpecialAnimGameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1aecd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpecialAnimGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&SpecialAnimGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(SpecialAnimGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x259570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto StarInfoPopup::create(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, bool p9) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(int, int, int, int, int, int, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x7cea20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto StarInfoPopup::createFromString(gd::string p0) -> decltype(createFromString(p0)) {
	using FunctionType = decltype(createFromString(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x7cb650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto StarInfoPopup::createFromStringMoons(gd::string p0) -> decltype(createFromStringMoons(p0)) {
	using FunctionType = decltype(createFromStringMoons(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x7cb8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto StarInfoPopup::init(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, bool p9) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(StarInfoPopup*, int, int, int, int, int, int, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x7cebb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto StarInfoPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&StarInfoPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(StarInfoPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7cf3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto StarInfoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StarInfoPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(StarInfoPopup*);
	static auto func = wrapFunction(base::get() + 0x7cf3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StartPosObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StartPosObject::init), this);
	using FunctionType = decltype(init())(*)(StartPosObject*);
	static auto func = wrapFunction(base::get() + 0x1b88a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StartPosObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&StartPosObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(StartPosObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1b89f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto StartPosObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&StartPosObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(StartPosObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b8a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto StatsCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsCell::init), this);
	using FunctionType = decltype(init())(*)(StatsCell*);
	static auto func = wrapFunction(base::get() + 0x24ea90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StatsCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsCell::draw), this);
	using FunctionType = decltype(draw())(*)(StatsCell*);
	static auto func = wrapFunction(base::get() + 0x24f4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StatsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(StatsLayer*);
	static auto func = wrapFunction(base::get() + 0x9b1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SupportLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SupportLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SupportLayer*);
	static auto func = wrapFunction(base::get() + 0x39b820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SupportLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&SupportLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(SupportLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x39d6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&SupportLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(SupportLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x39d820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&SupportLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(SupportLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x39d690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SupportLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SupportLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SupportLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x39dbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::reloadData() -> decltype(reloadData()) {
	using FunctionType = decltype(reloadData())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x62db70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto TableView::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TableView::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x62e110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TableView::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TableView::onExit), this);
	using FunctionType = decltype(onExit())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x62e120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TableView::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x62e2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x62ee00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x62ebc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x62ed40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TableView::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x62e130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TableView::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&TableView::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(TableView*, float, float);
	static auto func = wrapFunction(base::get() + 0x62eef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void TableView::scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) {}

void TableView::scrollViewDidEndDecelerating(CCScrollLayerExt* p0) {}

void TableView::scrollViewTouchMoving(CCScrollLayerExt* p0) {}

void TableView::scrollViewDidEndMoving(CCScrollLayerExt* p0) {}

auto TableView::getCellDelegateType() -> decltype(getCellDelegateType()) {
	throw std::runtime_error("TableView::getCellDelegateType not implemented");
}

auto TeleportPortalObject::create(char const* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, bool);
	static auto func = wrapFunction(base::get() + 0x1b8ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto TeleportPortalObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&TeleportPortalObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(TeleportPortalObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x1b8e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&TeleportPortalObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(TeleportPortalObject*, float);
	static auto func = wrapFunction(base::get() + 0x1b8f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::setStartPos(cocos2d::CCPoint p0) -> decltype(setStartPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&TeleportPortalObject::setStartPos), this);
	using FunctionType = decltype(setStartPos(p0))(*)(TeleportPortalObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x1b8cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&TeleportPortalObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TeleportPortalObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1bb5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TeleportPortalObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TeleportPortalObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TeleportPortalObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b9060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::addToGroup(int p0) -> decltype(addToGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TeleportPortalObject::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0))(*)(TeleportPortalObject*, int);
	static auto func = wrapFunction(base::get() + 0x1b8fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::removeFromGroup(int p0) -> decltype(removeFromGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TeleportPortalObject::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0))(*)(TeleportPortalObject*, int);
	static auto func = wrapFunction(base::get() + 0x1b9000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::setRotation2(float p0) -> decltype(setRotation2(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&TeleportPortalObject::setRotation2), this);
	using FunctionType = decltype(setRotation2(p0))(*)(TeleportPortalObject*, float);
	static auto func = wrapFunction(base::get() + 0x1b8f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::addToGroup2(int p0) -> decltype(addToGroup2(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TeleportPortalObject::addToGroup2), this);
	using FunctionType = decltype(addToGroup2(p0))(*)(TeleportPortalObject*, int);
	static auto func = wrapFunction(base::get() + 0x1b8f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::removeFromGroup2(int p0) -> decltype(removeFromGroup2(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TeleportPortalObject::removeFromGroup2), this);
	using FunctionType = decltype(removeFromGroup2(p0))(*)(TeleportPortalObject*, int);
	static auto func = wrapFunction(base::get() + 0x1b8f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextAlertPopup::create(gd::string p0, float p1, float p2, int p3, gd::string p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(gd::string, float, float, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x2ab0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto TextAlertPopup::init(gd::string p0, float p1, float p2, int p3, gd::string p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(TextAlertPopup*, gd::string, float, float, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x2ab2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto TextAlertPopup::setLabelColor(cocos2d::ccColor3B p0) -> decltype(setLabelColor(p0)) {
	using FunctionType = decltype(setLabelColor(p0))(*)(TextAlertPopup*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x2ab5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextArea::create(gd::string str, char const* font, float scale, float width, cocos2d::CCPoint anchor, float lineHeight, bool disableColor) -> decltype(create(str, font, scale, width, anchor, lineHeight, disableColor)) {
	using FunctionType = decltype(create(str, font, scale, width, anchor, lineHeight, disableColor))(*)(gd::string, char const*, float, float, cocos2d::CCPoint, float, bool);
	static auto func = wrapFunction(base::get() + 0x320310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(str, font, scale, width, anchor, lineHeight, disableColor);
}

auto TextArea::setString(gd::string p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(TextArea*, gd::string);
	static auto func = wrapFunction(base::get() + 0x320680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextArea::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&TextArea::update), this);
	using FunctionType = decltype(update(p0))(*)(TextArea*, float);
	static auto func = wrapFunction(base::get() + 0x3210f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void TextArea::draw() {}

auto TextArea::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&TextArea::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(TextArea*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x320f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&TextGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TextGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x5da200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TextGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TextGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TextGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x5da380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextGameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TextGameObject::updateTextKerning), this);
	using FunctionType = decltype(updateTextKerning(p0))(*)(TextGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x5d9f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextGameObject::getTextKerning() -> decltype(getTextKerning()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TextGameObject::getTextKerning), this);
	using FunctionType = decltype(getTextKerning())(*)(TextGameObject*);
	static auto func = wrapFunction(base::get() + 0x5dad80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TimerTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&TimerTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(TimerTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1dc950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto TimerTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&TimerTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TimerTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1de820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TimerTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TimerTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TimerTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1dca60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TopArtistsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::init), this);
	using FunctionType = decltype(init())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x30fa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x310410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x3103a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::show), this);
	using FunctionType = decltype(show())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x310ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::loadListFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadListFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&TopArtistsLayer::loadListFinished), this);
	using FunctionType = decltype(loadListFinished(p0, p1))(*)(TopArtistsLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x310460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TopArtistsLayer::loadListFailed(char const* p0) -> decltype(loadListFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&TopArtistsLayer::loadListFailed), this);
	using FunctionType = decltype(loadListFailed(p0))(*)(TopArtistsLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x310520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TopArtistsLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&TopArtistsLayer::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(TopArtistsLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x310560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TOSPopup::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TOSPopup::init), this);
	using FunctionType = decltype(init())(*)(TOSPopup*);
	static auto func = wrapFunction(base::get() + 0x2ab8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void TOSPopup::keyBackClicked() {}

auto TransformTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&TransformTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(TransformTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1d33d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto TransformTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&TransformTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TransformTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1d3400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TransformTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TransformTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TransformTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1d37f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TriggerControlGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&TriggerControlGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(TriggerControlGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1e9410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto TriggerControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&TriggerControlGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TriggerControlGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1e91c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TriggerControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TriggerControlGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TriggerControlGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1e88d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TutorialLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialLayer::init), this);
	using FunctionType = decltype(init())(*)(TutorialLayer*);
	static auto func = wrapFunction(base::get() + 0x4e64f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TutorialLayer*);
	static auto func = wrapFunction(base::get() + 0x4e6f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TutorialPopup*);
	static auto func = wrapFunction(base::get() + 0x5dce50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialPopup::show), this);
	using FunctionType = decltype(show())(*)(TutorialPopup*);
	static auto func = wrapFunction(base::get() + 0x5dcf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::disableMenu() -> decltype(disableMenu()) {
	using FunctionType = decltype(disableMenu())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4d2bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::enableMenu() -> decltype(enableMenu()) {
	using FunctionType = decltype(enableMenu())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4d34a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::handleKeypress(cocos2d::enumKeyCodes p0, bool p1) -> decltype(handleKeypress(p0, p1)) {
	using FunctionType = decltype(handleKeypress(p0, p1))(*)(UILayer*, cocos2d::enumKeyCodes, bool);
	static auto func = wrapFunction(base::get() + 0x4d2d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UILayer::init(GJBaseGameLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UILayer*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4d1a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UILayer::resetAllButtons() -> decltype(resetAllButtons()) {
	using FunctionType = decltype(resetAllButtons())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4d3600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::toggleMenuVisibility(bool p0) -> decltype(toggleMenuVisibility(p0)) {
	using FunctionType = decltype(toggleMenuVisibility(p0))(*)(UILayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4d34c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void UILayer::draw() {}

auto UILayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d3740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d3920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d3a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d4260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UILayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4d42a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UILayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4d32c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&UILayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(UILayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4d3220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UILayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&UILayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(UILayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4d3270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UIObjectSettingsPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&UIObjectSettingsPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(UIObjectSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x584cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto UIOptionsLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2b0a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2b0c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2b0e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2b0f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UIOptionsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(UIOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b0f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UIOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&UIOptionsLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(UIOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto UIOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&UIOptionsLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(UIOptionsLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x2b04a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&UIOptionsLayer::getValue), this);
	using FunctionType = decltype(getValue(p0))(*)(UIOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b07b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UISettingsGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UISettingsGameObject::init), this);
	using FunctionType = decltype(init())(*)(UISettingsGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d68f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UISettingsGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&UISettingsGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(UISettingsGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1d7820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UISettingsGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&UISettingsGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(UISettingsGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1d6940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UpdateAccountSettingsPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x29ecb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UpdateAccountSettingsPopup::updateSettingsFinished() -> decltype(updateSettingsFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::updateSettingsFinished), this);
	using FunctionType = decltype(updateSettingsFinished())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x29eaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UpdateAccountSettingsPopup::updateSettingsFailed() -> decltype(updateSettingsFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::updateSettingsFailed), this);
	using FunctionType = decltype(updateSettingsFailed())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x29ebc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadActionPopup::create(UploadPopupDelegate* delegate, gd::string str) -> decltype(create(delegate, str)) {
	using FunctionType = decltype(create(delegate, str))(*)(UploadPopupDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x29ee10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, str);
}

auto UploadActionPopup::closePopup() -> decltype(closePopup()) {
	using FunctionType = decltype(closePopup())(*)(UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x29f760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UploadActionPopup::init(UploadPopupDelegate* delegate, gd::string str) -> decltype(init(delegate, str)) {
	using FunctionType = decltype(init(delegate, str))(*)(UploadActionPopup*, UploadPopupDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x29f010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, delegate, str);
}

auto UploadActionPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(UploadActionPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29f460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UploadActionPopup::showFailMessage(gd::string message) -> decltype(showFailMessage(message)) {
	using FunctionType = decltype(showFailMessage(message))(*)(UploadActionPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x29f610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, message);
}

auto UploadActionPopup::showSuccessMessage(gd::string message) -> decltype(showSuccessMessage(message)) {
	using FunctionType = decltype(showSuccessMessage(message))(*)(UploadActionPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x29f4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, message);
}

auto UploadActionPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadActionPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x29f790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void UploadListPopup::keyBackClicked() {}

auto UploadListPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadListPopup::show), this);
	using FunctionType = decltype(show())(*)(UploadListPopup*);
	static auto func = wrapFunction(base::get() + 0x365890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadListPopup::listUploadFinished(GJLevelList* p0) -> decltype(listUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJLevelList*>::func(&UploadListPopup::listUploadFinished), this);
	using FunctionType = decltype(listUploadFinished(p0))(*)(UploadListPopup*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x365330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UploadListPopup::listUploadFailed(GJLevelList* p0, int p1) -> decltype(listUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJLevelList*, int>::func(&UploadListPopup::listUploadFailed), this);
	using FunctionType = decltype(listUploadFailed(p0, p1))(*)(UploadListPopup*, GJLevelList*, int);
	static auto func = wrapFunction(base::get() + 0x365550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void UploadPopup::keyBackClicked() {}

auto UploadPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadPopup::show), this);
	using FunctionType = decltype(show())(*)(UploadPopup*);
	static auto func = wrapFunction(base::get() + 0x27e660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadPopup::levelUploadFinished(GJGameLevel* p0) -> decltype(levelUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&UploadPopup::levelUploadFinished), this);
	using FunctionType = decltype(levelUploadFinished(p0))(*)(UploadPopup*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x27e200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UploadPopup::levelUploadFailed(GJGameLevel* p0) -> decltype(levelUploadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&UploadPopup::levelUploadFailed), this);
	using FunctionType = decltype(levelUploadFailed(p0))(*)(UploadPopup*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x27e450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto URLCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&URLCell::init), this);
	using FunctionType = decltype(init())(*)(URLCell*);
	static auto func = wrapFunction(base::get() + 0x255320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto URLCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&URLCell::draw), this);
	using FunctionType = decltype(draw())(*)(URLCell*);
	static auto func = wrapFunction(base::get() + 0x255390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto VideoOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&VideoOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(VideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7ab1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto VideoOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&VideoOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(VideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7acc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto WorldLevelPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&WorldLevelPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(WorldLevelPage*);
	static auto func = wrapFunction(base::get() + 0x3ca580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto WorldLevelPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&WorldLevelPage::show), this);
	using FunctionType = decltype(show())(*)(WorldLevelPage*);
	static auto func = wrapFunction(base::get() + 0x3ca440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto WorldSelectLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&WorldSelectLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(WorldSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x3c7350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto WorldSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&WorldSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(WorldSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x3c7270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto WorldSelectLayer::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&WorldSelectLayer::scrollLayerWillScrollToPage), this);
	using FunctionType = decltype(scrollLayerWillScrollToPage(p0, p1))(*)(WorldSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3c7180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto WorldSelectLayer::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&WorldSelectLayer::scrollLayerScrolledToPage), this);
	using FunctionType = decltype(scrollLayerScrolledToPage(p0, p1))(*)(WorldSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3c7090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto WorldSelectLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&WorldSelectLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(WorldSelectLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3c73a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}
